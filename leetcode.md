- [Tag](#tag)
- [Time Complexities](#time-complexities)
  - [Constant Time — 𝑂(1)O(1)](#constant-time--𝑂1o1)
  - [Logarithmic Time — 𝑂(log⁡𝑛)](#logarithmic-time--𝑂log𝑛)
  - [Linear Time — 𝑂(𝑛^2)](#linear-time--𝑂𝑛2)
  - [Linearithmic Time — 𝑂(𝑛log𝑛)](#linearithmic-time--𝑂𝑛log𝑛)
  - [Quadratic Time — 𝑂(𝑛^2)](#quadratic-time--𝑂𝑛2)
- [Space Complexities](#space-complexities)
  - [Constant Space — 𝑂(1)](#constant-space--𝑂1)
- [Computation](#computation)
  - [Python](#python)
  - [Division and Modulus](#division-and-modulus)
  - [50. Pow(x, n)](#50-powx-n)
  - [263. Ugly Number](#263-ugly-number)
- [Random (Python)](#random-python)
- [Random](#random)
  - [nextInt](#nextint)
- [List (Python)](#list-python)
  - [Slice (Python)](#slice-python)
  - [__iter__() Python](#iter-python)
- [Array](#array)
  - [Arrays方法](#arrays方法)
  - [List ArrayList](#list-arraylist)
  - [26. Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
  - [27. Remove Element](#27-remove-element)
  - [35. Search Insert Position](#35-search-insert-position)
  - [48. Rotate Image](#48-rotate-image)
  - [54. Spiral Matrix](#54-spiral-matrix)
  - [56. Merge Intervals](#56-merge-intervals)
  - [66. Plus One](#66-plus-one)
  - [73. Set Matrix Zeroes](#73-set-matrix-zeroes)
  - [75. Sort Colors](#75-sort-colors)
  - [80. Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array-ii)
  - [88. Merge Sorted Array](#88-merge-sorted-array)
  - [118. Pascal's Triangle](#118-pascals-triangle)
  - [119. Pascal's Triangle II](#119-pascals-triangle-ii)
  - [189. Rotate Array](#189-rotate-array)
  - [209. Minimum Size Subarray Sum](#209-minimum-size-subarray-sum)
  - [287. Find the Duplicate Number](#287-find-the-duplicate-number)
  - [283. Move Zeroes](#283-move-zeroes)
  - [414. Third Maximum Number](#414-third-maximum-number)
  - [448. Find All Numbers Disappeared in an Array](#448-find-all-numbers-disappeared-in-an-array)
  - [485. Max Consecutive Ones](#485-max-consecutive-ones)
  - [487. Max Consecutive Ones II](#487-max-consecutive-ones-ii)
  - [498. Diagonal Traverse](#498-diagonal-traverse)
  - [498. Diagonal Traverse](#498-diagonal-traverse-1)
  - [724. Find Pivot Index](#724-find-pivot-index)
  - [747. Largest Number At Least Twice of Others](#747-largest-number-at-least-twice-of-others)
  - [905. Sort Array By Parity](#905-sort-array-by-parity)
  - [941. Valid Mountain Array](#941-valid-mountain-array)
  - [977. Squares of a Sorted Array](#977-squares-of-a-sorted-array)
  - [1089. Duplicate Zeros](#1089-duplicate-zeros)
  - [1295. Find Numbers with Even Number of Digits](#1295-find-numbers-with-even-number-of-digits)
  - [1299. Replace Elements with Greatest Element on Right Side](#1299-replace-elements-with-greatest-element-on-right-side)
  - [1346. Check If N and Its Double Exist](#1346-check-if-n-and-its-double-exist)
- [String (Python)](#string-python)
- [String](#string)
  - [Compare and substring](#compare-and-substring)
  - [toCharArray](#tochararray)
  - [StringBuilder](#stringbuilder)
  - [String, Integer, int](#string-integer-int)
  - [char, int](#char-int)
  - [Sort String](#sort-string)
  - [5. Longest Palindromic Substring](#5-longest-palindromic-substring)
  - [14. Longest Common Prefix](#14-longest-common-prefix)
  - [28. Find the Index of the First Occurrence in a String](#28-find-the-index-of-the-first-occurrence-in-a-string)
  - [67. Add Binary](#67-add-binary)
  - [151. Reverse Words in a String](#151-reverse-words-in-a-string)
  - [167. Two Sum II - Input Array Is Sorted](#167-two-sum-ii---input-array-is-sorted)
  - [344. Reverse String](#344-reverse-string)
  - [557. Reverse Words in a String III](#557-reverse-words-in-a-string-iii)
  - [561. Array Partition](#561-array-partition)
- [Linked List](#linked-list)
    - [Add](#add)
    - [Delete](#delete)
  - [Double linked list](#double-linked-list)
  - [2. Add Two Numbers](#2-add-two-numbers)
  - [19. Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
  - [21. Merge Two Sorted Lists](#21-merge-two-sorted-lists)
  - [61. Rotate List](#61-rotate-list)
  - [138. Copy List with Random Pointer](#138-copy-list-with-random-pointer)
  - [141. Linked List Cycle](#141-linked-list-cycle)
  - [142. Linked List Cycle II](#142-linked-list-cycle-ii)
  - [160. Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)
  - [203. Remove Linked List Elements](#203-remove-linked-list-elements)
  - [206. Reverse Linked List](#206-reverse-linked-list)
  - [234. Palindrome Linked List](#234-palindrome-linked-list)
  - [328. Odd Even Linked List](#328-odd-even-linked-list)
  - [430. Flatten a Multilevel Doubly Linked List](#430-flatten-a-multilevel-doubly-linked-list)
  - [707. Design Linked List](#707-design-linked-list)
- [Set (Python)](#set-python)
- [Hash Table (Python dict)](#hash-table-python-dict)
  - [defaultdict](#defaultdict)
  - [Counter](#counter)
- [HashSet](#hashset)
- [HashMap](#hashmap)
  - [2. Tow Sum](#2-tow-sum)
  - [3. Longest Substring Without Repeating Characters](#3-longest-substring-without-repeating-characters)
  - [36. Valid Sudoku](#36-valid-sudoku)
  - [49. Group Anagrams](#49-group-anagrams)
  - [136. Single Number](#136-single-number)
  - [202. Happy Number](#202-happy-number)
  - [205. Isomorphic Strings](#205-isomorphic-strings)
  - [217. Contains Duplicate](#217-contains-duplicate)
  - [219. Contains Duplicate II](#219-contains-duplicate-ii)
  - [220. Contains Duplicate III](#220-contains-duplicate-iii)
  - [349. Intersection of Two Arrays](#349-intersection-of-two-arrays)
  - [350. Intersection of Two Arrays II](#350-intersection-of-two-arrays-ii)
  - [380. Insert Delete GetRandom O(1)](#380-insert-delete-getrandom-o1)
  - [387. First Unique Character in a String](#387-first-unique-character-in-a-string)
  - [454. 4Sum II](#454-4sum-ii)
  - [599. Minimum Index Sum of Two Lists](#599-minimum-index-sum-of-two-lists)
  - [771. Jewels and Stones](#771-jewels-and-stones)
- [Tree](#tree)
  - [^^Heap](#heap)
    - [Heap Queue (Python)](#heap-queue-python)
    - [PriorityQueue](#priorityqueue)
  - [23. Merge k Sorted Lists](#23-merge-k-sorted-lists)
  - [239. Sliding Window Maximum](#239-sliding-window-maximum)
  - [264. Ugly Number II](#264-ugly-number-ii)
  - [347. Top K Frequent Elements](#347-top-k-frequent-elements)
  - [652. Find Duplicate Subtrees](#652-find-duplicate-subtrees)
  - [^^Binary Tree](#binary-tree)
  - [94. Binary Tree Inorder Traversal](#94-binary-tree-inorder-traversal)
  - [102. Binary Tree Level Order Traversal](#102-binary-tree-level-order-traversal)
  - [106. Construct Binary Tree from Inorder and Postorder Traversal](#106-construct-binary-tree-from-inorder-and-postorder-traversal)
  - [110. Balanced Binary Tree](#110-balanced-binary-tree)
  - [112. Path Sum](#112-path-sum)
  - [116. Populating Next Right Pointers in Each Node](#116-populating-next-right-pointers-in-each-node)
  - [144. Binary Tree Preorder Traversal](#144-binary-tree-preorder-traversal)
  - [145. Binary Tree Postorder Traversal](#145-binary-tree-postorder-traversal)
  - [236. Lowest Common Ancestor of a Binary Tree](#236-lowest-common-ancestor-of-a-binary-tree)
  - [297. Serialize and Deserialize Binary Tree](#297-serialize-and-deserialize-binary-tree)
  - [^^Trie](#trie)
  - [208. Implement Trie (Prefix Tree)](#208-implement-trie-prefix-tree)
  - [211. Design Add and Search Words Data Structure](#211-design-add-and-search-words-data-structure)
  - [336. Palindrome Pairs](#336-palindrome-pairs)
  - [421. Maximum XOR of Two Numbers in an Array](#421-maximum-xor-of-two-numbers-in-an-array)
  - [212. Word Search II](#212-word-search-ii)
  - [648. Replace Words](#648-replace-words)
  - [677. Map Sum Pairs](#677-map-sum-pairs)
  - [^^N-ary Tree](#n-ary-tree)
  - [429. N-ary Tree Level Order Traversal](#429-n-ary-tree-level-order-traversal)
  - [559. Maximum Depth of N-ary Tree](#559-maximum-depth-of-n-ary-tree)
  - [589. N-ary Tree Preorder Traversal](#589-n-ary-tree-preorder-traversal)
  - [590. N-ary Tree Postorder Traversal](#590-n-ary-tree-postorder-traversal)
  - [^^Binary Search Tree (BST)](#binary-search-tree-bst)
  - [98. Validate Binary Search Tree](#98-validate-binary-search-tree)
  - [108. Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
  - [173. Binary Search Tree Iterator](#173-binary-search-tree-iterator)
  - [235. Lowest Common Ancestor of a Binary Search Tree](#235-lowest-common-ancestor-of-a-binary-search-tree)
  - [450. Delete Node in a BST](#450-delete-node-in-a-bst)
  - [700. Search in a Binary Search Tree](#700-search-in-a-binary-search-tree)
  - [701. Insert into a Binary Search Tree](#701-insert-into-a-binary-search-tree)
  - [703. Kth Largest Element in a Stream](#703-kth-largest-element-in-a-stream)
- [TreeSet](#treeset)
- [Queue](#queue)
  - [BSF](#bsf)
  - [Deque or LinkedList](#deque-or-linkedlist)
  - [200. Number of Islands](#200-number-of-islands)
  - [279. Perfect Squares](#279-perfect-squares)
  - [542. 01 Matrix](#542-01-matrix)
  - [622. Design Circular Queue](#622-design-circular-queue)
  - [841. Keys and Rooms](#841-keys-and-rooms)
- [Stack](#stack)
  - [DSF](#dsf)
  - [20. Valid Parentheses](#20-valid-parentheses)
  - [84. Largest Rectangle in Histogram](#84-largest-rectangle-in-histogram)
  - [133. Clone Graph](#133-clone-graph)
  - [150. Evaluate Reverse Polish Notation](#150-evaluate-reverse-polish-notation)
  - [155. Min Stack](#155-min-stack)
  - [200. Number of Islands](#200-number-of-islands-1)
  - [225. Implement Stack using Queues](#225-implement-stack-using-queues)
  - [232. Implement Queue using Stacks](#232-implement-queue-using-stacks)
  - [394. Decode String](#394-decode-string)
  - [733. Flood Fill](#733-flood-fill)
  - [739. Daily Temperatures](#739-daily-temperatures)
- [Binary Search](#binary-search)
  - [4. Median of Two Sorted Arrays](#4-median-of-two-sorted-arrays)
  - [33. Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array)
  - [34. Find First and Last Position of Element in Sorted Array](#34-find-first-and-last-position-of-element-in-sorted-array)
  - [69. Sqrt(x)](#69-sqrtx)
  - [153. Find Minimum in Rotated Sorted Array](#153-find-minimum-in-rotated-sorted-array)
  - [154. Find Minimum in Rotated Sorted Array II](#154-find-minimum-in-rotated-sorted-array-ii)
  - [162. Find Peak Element](#162-find-peak-element)
  - [278. First Bad Version](#278-first-bad-version)
  - [367. Valid Perfect Square](#367-valid-perfect-square)
  - [374. Guess Number Higher or Lower](#374-guess-number-higher-or-lower)
  - [410. Split Array Largest Sum](#410-split-array-largest-sum)
  - [658. Find K Closest Elements](#658-find-k-closest-elements)
  - [704. Binary Search](#704-binary-search)
  - [719. Find K-th Smallest Pair Distance](#719-find-k-th-smallest-pair-distance)
  - [744. Find Smallest Letter Greater Than Target](#744-find-smallest-letter-greater-than-target)
  - [1051. Height Checker](#1051-height-checker)
- [Sorting 排序算法](#sorting-排序算法)
  - [快排 QuickSort](#快排-quicksort)
  - [912. Sort an Array](#912-sort-an-array)
  - [Merge Sort](#merge-sort)
    - [?couting sort？](#couting-sort)
- [Bit manupulation (python)](#bit-manupulation-python)
- [Bit manipulation](#bit-manipulation)
  - [进制](#进制)
  - [计算机中的整数表示](#计算机中的整数表示)
  - [位运算的概述和性质](#位运算的概述和性质)
  - [Java中的二进制输出](#java中的二进制输出)
  - [Java位运算](#java位运算)
  - [137. Single Number II](#137-single-number-ii)
  - [160. Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists-1)
  - [190. Reverse Bits](#190-reverse-bits)
  - [191. Number of 1 Bits](#191-number-of-1-bits)
  - [218. Bitwise AND of Numbers Range](#218-bitwise-and-of-numbers-range)
    - [Brian Kernighan 算法](#brian-kernighan-算法)
  - [371. Sum of Two Integers](#371-sum-of-two-integers)
  - [421. Maximum XOR of Two Numbers in an Array](#421-maximum-xor-of-two-numbers-in-an-array-1)
- [滑动窗口](#滑动窗口)
  - [674. Longest Continuous Increasing Subsequ](#674-longest-continuous-increasing-subsequ)
- [Recursion](#recursion)
  - [22. Generate Parentheses](#22-generate-parentheses)
  - [24. Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
  - [37. Sudoku Solver](#37-sudoku-solver)
  - [51. N-Queens](#51-n-queens)
  - [52. N-Queens II](#52-n-queens-ii)
  - [70. Climbing Stairs](#70-climbing-stairs)
  - [77. Combinations](#77-combinations)
  - [95. Unique Binary Search Trees II](#95-unique-binary-search-trees-ii)
  - [100. Same Tree](#100-same-tree)
  - [101. Symmetric Tree](#101-symmetric-tree)
  - [104. Maximum Depth of Binary Tree](#104-maximum-depth-of-binary-tree)
  - [240. Search a 2D Matrix II](#240-search-a-2d-matrix-ii)
  - [509. Fibonacci Number](#509-fibonacci-number)
  - [779. K-th Symbol in Grammar](#779-k-th-symbol-in-grammar)


# Tag
- Array
  - From right to left
  
- Two Pointers
  - One pointer point to iterate index, another pointer point to valid index
  - From right to left
  - From two ends
  - Find the middle, from middle to two ends
  - Iterate twice, first round collect info, second round process it
  - Slow pointer and fast pointer
    - fast pointer move twice as slow pointer
    - fast pointer move n steps (n from questions) in advance
  - For rotate problem, reverse and reverse part could achieve rotate effect
  - Use two pointers to reverse a string / list, by 
    - exchange two pointer if left < right 
    - use start and len-1-start and loop [start,(len-start)//2]
    - use left and right, and loop [left,left+(right-left)//2], len is right-left+1
  - 
- Sliding Window
  Normally need two pointers
  - Iternate left pointer in the range
    - Move left pointer to the valid start place
    - Assign right pointer to left pointer position, and move to valid end place (or the next position of valid end place)
    - Get a valid window and process
    - Assign left pointer to right pointer position
  - Use the outer loop to iternate the right pointer
    - Method 1.
      - While right < n:
      - Move right pointer to add valid element
      - Move left pointer to eliminate invalid element (This could use the outer while right < n loop)
    - Method 2. 
      - Check if the range valid in every outer loop
      - if not valid, then keep iterate the right pointer
      - if valid, inside the outer loop, loop left pointer 
  
- Cyclic Sort
  - Regard value at the index as the next index

- Floyd’s Cycle Detection
  - Any thing if there is a cycle, we could use it to check. A fast pointer, a slow pointer
  - 
- Linked List
  - Find the common patter from the very first elements, and apply them to each elements to see if it applied, adjust to fit all boundry senario. Find a common state of each step, and loop them.
  - Add dummy head to avoid first element boundry problem
  - Find interaction point, Connect two linked list by loop one and then go another one.
  - N th from the end, Two pointers, one go n step first, and then another from start, the first one from where it is, this find the nth from the end 

- Matrix
  - Set from and start then loop, the row start, column start, row end, column end could be change to satisfy the condition
  - Use (row + column) to indicate diagnoses
  - Use dirs [[0,1], [0,-1], [1,0], [-1,0]] to indicate four directions

- Math
  - Two Sum or sum questions, change the question to make reminder to 0, save each middiate value in a set, and check if (target - cur) in the set

- Dynamic Programming
  - 118 119 redo by using dynamic programming thoughts

- Hash Table
  - Check duplicate
  - Use space to optimize time

- Binary Tree
  - 前中后序：指根在哪个位置遍历
    - 前序（Preorder Traversal）：根 → 左 → 右
    - 中序（Inorder Traversal）：左 → 根 → 右
    - 后序（Postorder Traversal）：左 → 右 → 根
  - 唯一确定一棵树，即通过序列化后的结果，是否可以还原该树
    - 中序+前序
      - 前序第一个是根节点
      - 在中序中找到根的位置 → 左右子树大小就确定了
      - 然后递归划分即可
    - 中序+后序
      - 后序最后一个是根节点
      - 在中序中找根的位置，同样能划分左右子树
      - 再递归处理即可
    - 当空节点在序列化中用`null`等表示的时候，则只前序，或后序序列化就可以唯一确定一棵树。通常用**前序**
  
- Node
  - Define Node, integrate information in a node to save inforamtion at each node. Like min of current
  
- Stack
  - DFS
  - 

- Queue
  - BFS
    - in BFS, use queue to save each layer's value
    - loop the layer by using get the size before loop
    - check if valid in the loop, store next layer's value in the queue
- Heap
  - python默认最小堆，把数字乘 -1 存进去，就是最大堆
  - 可以存tuple进去，保存多个信息，也可以当数字相同时比较多组数据。比如存进去（数字+index），构成了一个排序的滑动窗口
  - 可以在tuple的信息前面使用一个count，来保证多存进去的信息即便不是comparable的，也可以在tuple里面
  
- Binary Search
  > Find upper bound to insert the target. The upper bound is the least value greater than target
  > Find lower bound to insert the target. The lower bound is the largest value greater than or equal to the target

  > The bound is where to insert the target to make the array keep sorted.
  > And when insert for example to index 2, it means the target now is inserted to index 2, and rest value from index 2, move right 1 position
  
  > Upper bound [-1,2,2,2,2,*12*] target 2, and finally check left > 0 and left - 1 == target
  
  > Lower bound [-1,*2*,2,2,2,12] target 2, and finally check left < size and left == target

  - Left should always be mid + 1, only this the range could shrink
  - right could be set to mid, and the position will be eliminate
  
- Recursion
  - Use visited matrix to record processed place
  - Set visited place as special value at the begaining of one round recursion, set it back after this round to restore the state. This is used when you want to use totally new visited matrix in every start point
  - We can check the condition before call the recursion, like within `for dir in dirs`, we do if 0 < x < m and somecondition: recursion
  - We can also check the condition at the start, and in `for dir in dirs`, we just check basic valid boundary and then start recursion, leave the consition check at the start. This is for the senario start the start point needs to be checked and possiblely be a solution
  

- Top down
  - Usually use recursion
  - One step one step to solve problem, final step get the solution


- Bottom up
  - Usually no recursion, use loop
  - Dynamic programming mindset
  - Solve basic problem first, find the connection to the larger problem, then solve that one, till the result

- Backtracking
  - Check valid at the beginning of the function
  - Iterate next valid steps, place valid position, recursively call, remove valid position

- Divide and conquer
  1. Divide, Divide the problem into a set of subproblems
  2. Conquer, Solve each subproblem recursively
  3. 
  4. Combine, Combine the results of each subproblem


# Time Complexities

## Constant Time — 𝑂(1)O(1)

Description: Execution time remains constant regardless of input size.
Example: Accessing a specific element in an array.

```python
def get_first_element(arr):
    return arr[0]

```
## Logarithmic Time — 𝑂(log⁡𝑛)

Description: Execution time grows logarithmically with input size.
Example: Binary search in a sorted array.
**Notice: if having odd, even array consideration, use the minimum [0,1] and [0] and [0,1,2]**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1


# Use recursion to return bool
def binary_search(arr, target):
    if not arr:
        return False
    mid = len(arr) // 2
    if arr[mid] < target:
        return binary_search(arr[mid+1:], target)
    elif arr[mid] > target:
        return binary_search(arr[:mid], target)
    else:
        return True

# use recursion to return index of target
def start(arr, target):
    return binary_search_recursion_index(arr, target, 0, len(arr) - 1)
def binary_search_recursion_index(arr, target, left, right):
    if left > right:
        return -1
    mid = left + (right - left) // 2
    if arr[mid] < target:
        return binary_search_recursion_index(arr, target, left + 1, right)
    elif arr[mid] > target:
        return binary_search_recursion_index(arr, target, left, right - 1)
    else:
        return mid
```
## Linear Time — 𝑂(𝑛^2)

Description: Execution time grows linearly with input size.
Example: Linear search or traversing an array.
```python
def linear_search(arr, target):
    for index, value in enumerate(arr):
        if value == target:
            return index
    return -1
```
## Linearithmic Time — 𝑂(𝑛log𝑛)
Description: Execution time grows proportionally to 
𝑛log
⁡
Example: Efficient sorting algorithms like Merge Sort and Quick Sort (average case).
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
## Quadratic Time — 𝑂(𝑛^2)

Description: Execution time grows proportionally to the square of the input size.
Example: Simple sorting algorithms like Bubble Sort and Selection Sort.
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
```
Exponential Time — 𝑂(2^𝑛)

Description: Execution time grows exponentially with input size, often impractical for large inputs.
Example: Naive recursive calculation of Fibonacci numbers.
```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```



# Space Complexities
## Constant Space — 𝑂(1)

Description: Requires a fixed amount of additional space regardless of input size.
Example: In-place algorithms like reversing an array without using extra storage.
```python
def reverse_array(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
    return arr
```
Linear Space — 𝑂(𝑛)O(n)

Description: Requires space proportional to the input size.
Example: Merge Sort, which uses additional arrays for merging.
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
Logarithmic Space — 𝑂(log𝑛)

Description: Requires space proportional to the logarithm of the input size, often seen in recursive algorithms due to stack space.
Example: Quick Sort's recursive implementation.
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
















![image-20230331142953809](./leetcode.assets/image-20230331142953809.png)







# Computation

## Python

```python
# Exponential
5**2
pow(5,2)

# Divide
## Double divide
5/2 = 2.5
4/2 = 2.0
## Floor divide
5 // 2 = 2
4 // 2 = 2

# Square root
result = math.sqrt(16)
>>> 4.0

result = 16**0.5
>>> 4.0

# Float to int
x = 5.2
int(x)
round(x)
```

## Division and Modulus



Java

Integer division

```java
5 / 3 = 1
5 / 2 = 2
```

Reminder / modulus operations

```java
5 % 3 = 2
5 % 2 = 1
```

Python

Integer division

```python
5 // 3 = 1
5 // 2 = 2
```

Reminder / modulus operations

```python
5 % 3 = 2
5 % 2 = 1
```

## 50. Pow(x, n)
Tag: Math
```python
class Solution:
    # TC: O(logn)
    # SC: O(logn)
    def myPow(self, x: float, n: int) -> float:
        d = {}
        d[0] = 1
        if n >= 0:
            return self.m_pow(x,n, d)
        else:
            return 1/self.m_pow(x,-n, d)

    def m_pow(self, x, n, d):
        if d.get(n) is not None:
            return d.get(n)
        r = 1 if n % 2 == 0 else x
        d[n] = r * self.m_pow(x, n//2, d) * self.m_pow(x, n//2, d)
        return d[n]

    # TC: O(logn)
    # SC: O(logn)
    def myPow(self, x: float, n: int) -> float:
        d = {}
        if n < 0:
            return 1/self.get_v(x, -n, d)
        else:
            return self.get_v(x, n, d)

    def get_v(self, x, n, d):
        if n == 0:
            d[n] = 1
            return 1
        if n == 1:
            d[n] = x
            return x
        if d.get(n):
            return d.get(n)
        big = self.get_v(x, n // 2, d)
        residual = self.get_v(x, n % 2, d)
        res = big * big * residual
        d[n] = res
        return res
```

## 263. Ugly Number
Tag: Math
```python
class Solution:
    # TC: O(n)
    # SC: O(1)
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 2 == 0 or n % 3 == 0 or n % 5 == 0:
            while n % 2 == 0:
                n //= 2
            while n % 3 == 0:
                n //= 3
            while n % 5 == 0:
                n //= 5
        return True if n == 1 else False
```

# Random (Python)
```python
import random

# 1. get rand int
random.randint(a,b) # a, b inclusive

# 2. get random element from non empty structure (list, tuple, string, etc.)
random.choice(my_list)

# 3. get value from [0, 1), return float
v = random.random()
```

# Random

## nextInt

```java
Random random = new Random();
random.nextInt(10); // 0 - 9 integer
// get 10-20
random.nextInt(20 - 10 + 1) + 10;
```


# List (Python)
The python list does not have fix len
```python
>>> print(type([]))
>>> <class 'list'>
# 1. Initialize a list of length 5 with default values (0)
nums = [0] * 5  # [0, 0, 0, 0, 0]
>>> len(nums)
>>> 5
# The list can append more element which will increase the list len
nums.append(1)
>>> len(nums)
>>> 6
# 1.1 Initialize a list with specific values
nums = [1, 3, 5, 6, 7]
>>> len(nums)
>>> 5

# 2. Set value
nums[0] = 100
>>> nums[0]
>>> 100

# 3. add value
nums.append(5)
>>> nums[len(nums) - 1]
>>> 5
# 3.1 add at index 2
# nums.insert(index, value)
nums.insert(2, 8)

# 4. Len of list
>>> len(nums)
>>> 6

# 5. remove element
# 5.1 Remove the first occurance of value in list nums, if value is not in the list, raise ValueError
# O(n). Find O(n), shift O(n)
nums.remove(value) 

# 5.2 Remove the element in index, return the pop's element, raise IndexError if index of out out range. 
# O(n-i) -> O(n). Find, and shift rest element left by one
value = nums.pop(index) 

# 5.3 Remove element in index range, include start not include end, not raise any error
# O(n-i) -> O(n)
del nums[start:end]

# 5.4 Remove in place
def remove_ele(value, nums):
    nums_len = len(nums)
    j = 0
    for i in nums_len:
        if nums[i] == value:
            continue
        else:
            nums[j] = nums[i]
            j+=1
    new_len = j
    return nums, new_len

def remove_ele(index, nums):
    nums_len = len(nums)
    for i in range(index + 1, nums_len)
        nums[i - 1] = nums[i]
    # Optionally, remove the last one
    nums_len -= 1
    nums = nums[:nums_len]

    return nums, nums_len

# 6. Sort
# nums.sort, sort in place, return None 
# nums.sort(key=func, reverse=True|False) asc
# key: A function to specify the sorting criteria(s)
# reverse: default is false
nums.sort() # asc
nums.sort(reverse=True) # des
def get_len(ele):
    return len(ele)
nums = ["abcd", "ac", "abc", "D"]
>>> nums.sort(key=get_len)
>>> nums
>>> ["D", "ac", "abc", "abcd"]

nums.reverse() # reverse itself, no return
reversed_nums = nums[::-1] # slice reverse
reversed_nums = list(reversed(arr)) # 返回迭代器, 配合list使用

left, right = 0, len(arr) - 1
while left < right:
    arr[left], arr[right] = arr[right], arr[left]
    left += 1
    right -= 1

nums.reverse() # reverse itself, no return
reversed_nums = nums[::-1] # slice reverse
reversed_nums = list(reversed(arr)) # 返回迭代器, 配合list使用

left, right = 0, len(arr) - 1
while left < right:
    arr[left], arr[right] = arr[right], arr[left]
    left += 1
    right -= 1

# 7. Copy range
# from index 1 to 4 (1 inclusive, 4 exclusive)
part_array = nums[1:4]

# 7.1 Copy
v1 = list(nums)
v2 = nums.copy()

# 8. Fill array with a specific value
arr = [-1] * 10

# 9. print multi-dimentional arrays
matrix = [
    [1, 2, 3],
    [4, 5, 6]
]
print(matrix[row][col]) # 2

# 10. Iterate
for ele in nums:
    print(ele)

for i in range(len(nums)):
    print(nums[i])

# 11. Clear all
nums.clear()

# 12. Comparable
nums1 = [1]
nums2 = [1]
>>> nums1 == nums2
>>> True

>>> nums1 is nums2
>>> False

# 13. Concat
nums1 = [1]
nums2 = [1]
nums_total = nums1 + nums2
nums_total = nums1.extend(nums2)
```

## Slice (Python)
```python
arr[start:stop:step]

# 切片
print(arr[::1])   # [10, 20, 30, 40, 50] 正常顺序
print(arr[::2])   # [10, 30, 50] 隔一个取一个
print(arr[::-1])  # [50, 40, 30, 20, 10] 完整反转
```

## __iter__() Python
以下都实现了__iter__方法，可以使用 for, in, iter(), next()
```python
list, tuple, str, set, dict, range, bytes, bytearray, file, zip, map, filter, enumerate, reversed, deque, frozenset
```

# Array

**创建Array**


```java
int[] nums = new int[5]; // {0,0,0,0,0} 初始化都是0
>>> nums.length
>>> 5
int[] nums = {1,3,5,6,7}; // 带初始化
>>> nums.length
>>  5
```



**添加值 insert value**

```java
nums[0] = 5;
nums[2] = 3;
```



**删除**

不是真正的把array长度变短，而是创建变量length，来表示array的新长度

```java
// 删除第i位
let length = int_array.length;
for (int i = 1; i < length; i++) {
    // Shift each element one position to the left
    int_array[i - 1] = int_array[i];
}

length--;
```



## Arrays方法

```java
int[] array = new int[10];
// 1. Sort
Arrays.sort(arr); // 升序
Arrays.sort(arr, compare);
// custom comparator
List<String> list = Arrays.asList("Banana", "Apple", "Orange", "Mango");
// 使用匿名类创建自定义 Comparator
Collections.sort(list, new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length(); // 按字符串长度排序
    }
});

// Use lambda
 list.sort((s1, s2) -> s1.length() - s2.length());

// 2. Copy range
int[] partArray = Arrays.copyOfRange(array, from. to); // from inclusive, to exclusive
// 3. Fill array with a specific value;
Arrays.fill(array, -1);
// 4. 打印多维数组
Arrays.deepToString(mulArr);
arr[row][col]
```



## List ArrayList

```java
 // 1. initialize
List<Integer> v0 = new ArrayList<>();
List<Integer> v1;                           // v1 == null
// 2. cast an array to a vector
Integer[] a = {0, 1, 2, 3, 4};
v1 = new ArrayList<>(Arrays.asList(a));
v1 = new ArrayList<>(Arrays.asList(1,2,3,4,7,8));
// 3. make a copy
List<Integer> v2 = v1;                      // another reference to v1
List<Integer> v3 = new ArrayList<>(v1);     // make an actual copy of v1
// copy a certain range to new ArrayList
List<Integer> v4 = Arrays.copyOfRange(left, right); // include left, exclude right
// 4. get length
System.out.println("The size of v1 is: " + v1.size());
// 5. access element
System.out.println("The first element in v1 is: " + v1.get(0));
// 6. iterate the vector
// size
System.out.print("[Version 1] The contents of v1 are:");
for (int i = 0; i < v1.size(); ++i) {
    System.out.print(" " + v1.get(i));
}
System.out.println();
System.out.print("[Version 2] The contents of v1 are:");
for (int item : v1) {
    System.out.print(" " + item);
}
System.out.println();
// 7. modify element
v2.set(0, 5);       // modify v2 will actually modify v1
System.out.println("The first element in v1 is: " + v1.get(0));

// 8. add element
v2.add(8);
// add element at index
v2.add(2, 8); // add 8 at index 2
// 9. clear all
v2.clear();
// 10. to array
int[] array = Arrays.toArray(v1);
```





```java
在末尾添加一个元素：void add(E e)
在指定索引添加一个元素：void add(int index, E e)
删除指定索引的元素：E remove(int index)
删除某个元素：boolean remove(Object e)
获取指定索引的元素：E get(int index)
获取链表大小（包含元素的个数）：int size()
```



`v1 = new ArrayList<>(Arrays.asList(a));`

```java
public ArrayList(Collection<? extends E> c)
// 继承Collection的类有
/*
List
	ArrayList
    LinkedList
    Vector
Set
	HashSet
    LinkedHashSet
    TreeSet
Queue
	PriorityQueue
    LinkedList（同时实现了 Queue 和 Deque）
    ArrayDeque
Deque
	ArrayDeque
	LinkedList
*/
    
Arrays.asList();

public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}

/*
<T>: 这是一个 泛型声明，表示这个方法是泛型方法。<T> 定义了一个类型参数 T，它在这个方法的上下文中可以用来表示任意类型。

List<T>: 这是这个方法的返回值类型，表示它返回一个 List，其中的元素类型是 T。

T... a: 这是可变参数（varargs），表示方法可以接收任意数量的类型为 T 的参数。实际上，它是一个数组，方法内部会将传入的参数打包成一个数组。
Arrays.asList(1, 2, 3);      // T 是 Integer，参数是 {1, 2, 3}
Arrays.asList("a", "b");
*/
```





## 26. Remove Duplicates from Sorted Array
Tag: Array, Sliding Window, Two Pointers
![image-20230613161652475](./leetcode.assets/image-20230613161652475.png)

```python
class Solution6(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        valid = 1
        for i in range(1, len(nums)):
            if nums[i - 1] != nums[i]:
                nums[valid] = nums[i]
                valid += 1
        return valid
```
**滑动窗口**

从第二位开始遍历，用k记录有多少个重复的数字，同时用来标记该赋值的地方

​	如果第二位与第一位不一样，则给第一位赋值

​	如果一样，则跳过本轮赋值，k+1

```
class Solution {
    public int removeDuplicates(int[] nums) {
        int k = 0;
        for (int i = 1; i < nums.length; i++) {
            if(nums[i-1] != nums[i]){
                nums[i-k] = nums[i];
                // or k++ here, and return k+1
            }else{
                k++;
            }
        }

        return nums.length - k;
    }
}
```



## 27. Remove Element
Tag: Array, Two Pointers 

![image-20230613160127119](./leetcode.assets/image-20230613160127119.png)

```python
# TC: O(n)
# SC: O(1)
class Solution5(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        n = len(nums)
        if n == 0:
            return 0
        valid = 0
        for i in range(n):
            if nums[i] != val:
                nums[valid] = nums[i]
                valid += 1
        
        return valid

        # Or:
        n = len(nums)
        if n == 0:
            return 0
        i = 0
        j = n - 1
        while i != j:
            if nums[i] != val:
                i += 1
            else:
                k = nums[i]
                nums[i] = nums[j]
                nums[j] = k
                j -= 1

        return i+1 if nums[i] != val else i
```

遍历，增加一个k来表示有效数字的index

​	如果不等于val，则把当前值赋值给k位置

​	如果等于val，则跳过本轮赋值

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int k = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] != val){
                nums[k] = nums[i];
                k++;
            }
        }
        return k;
    }
}
```

## 35. Search Insert Position

![image-20250709001237696](./leetcode.assets/image-20250709001237696.png)

范围是 [0,...,len-1]的话，记住此时target是可以等于左右的

所以当target<mid的时候，则target不在mid中，所以下一次right就是mid-1

**记住自己的边界表示什么！**

```
    public int searchInsert(int[] nums, int target) {
        
        
        int left = 0;
        int right = nums.length - 1;
        while (left <= right){
            int mid = (right + left) / 2;
            if(target < nums[mid]){
                right = mid-1;
            }else if(target>nums[mid]){
                left = mid+1;
            }else {
                return mid;
            }
        }
        return left;
    }
```



## 48. Rotate Image

![image-20250709001255051](./leetcode.assets/image-20250709001255051.png)

```java
// 一下旋转只适用nxn矩阵    
// clockwise, 先上下对称，再ij对调
// anticlockwise, 先ij对调，再上下对称
```

```java
   public void rotate(int[][] matrix){

        // clockwise, 先上下对称，再ij对调
        // anticlockwise, 先ij对调，再上下对称
        int n = matrix.length;
        for (int i = 0; i < n / 2; i++) {
            int[] temp = matrix[i];
            matrix[i] = matrix[n - 1 - i];
            matrix[n - 1 - i] = temp;
        }

        for (int i = 0; i < matrix.length; i++) {
            for (int j = i; j < matrix.length; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        
        // 算出的公式，不太建议，不如下面的规律好用
//        int n = matrix.length;
//        int i=0, j = 0;
//        while (i < n-1){
//            j = i;
//            while(j<n-1-i){
//                int temp = matrix[i][j];
//                matrix[i][j] = matrix[n-1-j][i];
//                matrix[n-1-j][i] = matrix[n-1-i][n-1-j];
//                matrix[n-1-i][n-1-j] = matrix[j][n-1-i];
//                matrix[j][n-1-i] = temp;
//                j++;
//            }
//            i++;
//        }
    }
```

## 54. Spiral Matrix
Tag: Array, Matrix
![image-20230625180740585](./leetcode.assets/image-20230625180740585.png)
```python
class Solution16:
    # TC: (m*n)
    # SC: (1)
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        m = len(matrix) -1
        n = len(matrix[0]) -1
        res = []
        i_start = 0
        j_start = 0
        while True:
            i = i_start
            for j in range(j_start, n + 1, 1):
                res.append(matrix[i][j])
            i_start += 1
            j = n
            for i in range(i_start, m + 1, 1):
                res.append(matrix[i][j])
            n -= 1
            i = m
            if m < i_start or n < j_start:
                break
            for j in range(n, j_start - 1, -1):
                res.append(matrix[i][j])
            m -= 1
            j = j_start
            for i in range(m, i_start - 1, -1):
                res.append(matrix[i][j])
            j_start += 1
            if m < i_start or n < j_start:
                break
        return res
```

方法1：

一圈一圈绕

方法2：

外面圈+往里一层，递归

```
public List<Integer> spiralOrder(int[][] matrix) {

        // 一圈一圈绕
        int top = 0;
        int left = 0;
        int down = matrix.length - 1;
        int right = matrix[0].length - 1;
        List<Integer> l = new ArrayList<>();
        while (top <= down && left<=right){
            for (int i = left; i <= right; i++) {
                l.add(matrix[top][i]);
            }
            top++;
            for (int i = top; i <= down ; i++) {
                l.add(matrix[i][right]);
            }
            right--;

            for (int i = right; i >= left && top <= down; i--) {
                l.add(matrix[down][i]);
            }
            down--;
            for (int i = down; i>= top && left <= right; i--) {
                l.add(matrix[i][left]);
            }
            left++;
        }
        return l;

        // int r = matrix.length;
        // int c = matrix[0].length;

        // int[] tp = {0,0};
        // int[] br =  {r-1, c-1};
        // return order(matrix,tp, br);
    }

    public List<Integer> order(int[][] matrix, int[] topLeft, int[] bottomRight){
        int c = bottomRight[1] - topLeft[1];
        int r = bottomRight[0] - topLeft[0];
        if(c<0 || r<0){
            return null;
        }
        List<Integer> l = new ArrayList<>();
        for (int i = topLeft[1]; i <= bottomRight[1]; i++) {
            l.add(matrix[topLeft[0]][i]);
        }
        for (int i = topLeft[0]+1; i <= bottomRight[0]; i++) {
            l.add(matrix[i][bottomRight[1]]);
        }
        for (int i = bottomRight[1] -1; i >= topLeft[1] && r>0; i--) {
            l.add(matrix[bottomRight[0]][i]);
        }
        for (int i = bottomRight[0] -1; i >= topLeft[0]+1 && c>0; i--) {
            l.add(matrix[i][topLeft[1]]);
        }
        int[] tl = {topLeft[0]+1, topLeft[1]+1};
        int[] br = {bottomRight[0]-1, bottomRight[1]-1};
        List<Integer> nl = order(matrix, tl, br);
        if(nl !=null){
            l.addAll(nl);
        }
        return l;
    }
```



## 56. Merge Intervals

![image-20230622153539388](./leetcode.assets/image-20230622153539388.png)

```java
[[1,4],[0,4]]

[[1,4],[2,3]]

[[2,3],[4,5],[6,7],[8,9],[1,10]]
```

从左往右，下一个的0位比上一位的1位低的时候，可以纳入进来。所有可以纳入进来的，1值取最大

（所以前提就是，首位要排序，这样得到的0位是最小的）

```java
    public int[][] merge(int[][] intervals) {
        List<int[]> al = new ArrayList<>();
        int[] next = new int[2];
        Arrays.sort(intervals, (int[] num1, int[] nums2) -> num1[0] - nums2[0]);
        next = intervals[0];
        for (int i = 1; i < intervals.length; i++) {
            if(intervals[i][0] > next[1]){
                al.add(next.clone());
                next = intervals[i];
            }else{
                next[1] = Math.max(next[1], intervals[i][1]);
            }
        }
        al.add(next);

        return al.toArray(new int[al.size()][]);
    }
```


## 66. Plus One
Tag: Array

![image-20250709001310163](./leetcode.assets/image-20250709001310163.png)

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        n = len(digits)
        add_on = 1
        for i in range(n-1, -1, -1):
            total = digits[i] + add_on
            add_on = total // 10
            rest = total % 10
            digits[i] = rest
        if add_on != 0:
            digits.insert(0, add_on)
        return digits
```



## 73. Set Matrix Zeroes

![image-20250709001332163](./leetcode.assets/image-20250709001332163.png)

每一行的第一个记录该行的状态（有0则第一位置为0）

第一列的第一个记录该列的状态（用col变量记录第一列的状态，00已经记录了第一行的状态）

```java
   int col = -1;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if(matrix[i][j] == 0){
                    if(j == 0){
                        col = 0;
                    }else{
                        matrix[0][j] = 0;
                    }
                    matrix[i][0] = 0;
                }
            }
        }

        for (int i = matrix.length - 1; i >= 0; i--) {
            for (int j = matrix[0].length -1; j >= 1; j--) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
            if (col == 0) {
                matrix[i][0] = 0;
            }
        }
```



## [75. Sort Colors](https://leetcode.cn/problems/sort-colors/)

![image-20230618174123859](./leetcode.assets/image-20230618174123859.png)

解决思路，partition

![image-20230618174107159](./leetcode.assets/image-20230618174107159.png)

**滑动窗口**

partition2

[0...zero] = 0

(zero...i] = 1

(i...tow] = 未知

(two...len-1] = 2

还可以别的分法，如[i...tow] = 未知，解答取决于怎么partition

```
        int len = nums.length;
        if (len < 2) {
            return;
        }
        int zero = -1;
        int two = len - 1;
        int i = -1;
        while (i < two) {
            if (nums[i+1] == 0) {
                zero++;
                swap(nums, i+1, zero);
                i++;
            } else if (nums[i+1] == 1) {
                i++;
            } else {
                swap(nums, i+1, two);
                two--;
            }
        }
```



## 80. Remove Duplicates from Sorted Array II

![image-20230618162140197](./leetcode.assets/image-20230618162140197.png)



**滑动窗口**

```
```

**滑动2**

```
    public int removeDuplicates(int[] nums) {
        int k = 0;
        boolean hasShowTwice = false;

        for (int i = 1; i < nums.length; i++) {
            if(nums[k] != nums[i]){
                k++;
                nums[k] = nums[i];
                hasShowTwice = false;
            }else if(!hasShowTwice){
                k++;
                nums[k] = nums[i];
                hasShowTwice = true;
            }
        }

        return k + 1;
    }
```



## 88. Merge Sorted Array
Tag: Array, Two Pointers

![image-20230612175447132](./leetcode.assets/image-20230612175447132.png)

```python
# TC: O(m+n)
# SC: O(1)
class Solution4(object):
    # 从右往左

    # 如果从左往右的话，即便加上两个数组中数字交换，也每次都sort nums2，来保证nums2是用最小数和nums1中的数字在做比较，复杂度高
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: None Do not return anything, modify nums1 in-place instead.
        """
        i = m - 1
        j = n - 1
        if n == 0:
            return
        for cur in range(m + n - 1, -1, -1):
            # i -> cur
            if i == -1 or j == -1:
                break
            if nums1[i] >= nums2[j]:
                nums1[cur] = nums1[i]
                i-=1
            else:
                nums1[cur] = nums2[j]
                j-=1
        while j >= 0:
            nums1[j] = nums2[j]
            j-=1
```

**solution 1**

```
 void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
     int i = m - 1, j = n - 1, k = m + n - 1;
     while(i >= 0 and j >= 0) {
         if(nums1[i] < nums2[j]) {
             nums1[k--] = nums2[j--];
         } else {
             nums1[k--] = nums1[i--];
         }
     }
     while(j >= 0) {
         nums1[k--] = nums2[j--];
     }
 }
```



**solution 2**

遍历m+n，从右往左比较两个数组的有效位

​	如果有一边已经全部遍历完，则只赋值另外一边

​	如果左边的比右边的大

​		赋值左边的到当前遍历位置

​		左边有效位--

​	如果右边的比左边的大

​		赋值右边的到当前遍历位置

​		右边有效位--

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
		int k = m + n;
        for (int i = k - 1; i >= 0; i--) {
            if (m == 0) {
                nums1[i] = nums2[n - 1];
                n--;
                continue;
            }
            if (n == 0) {
                nums1[i] = nums1[m - 1];
                m--;
                continue;
            }
            if (nums1[m - 1] >= nums2[n - 1]) {
                nums1[i] = nums1[m - 1];
                m--;
            } else {
                nums1[i] = nums2[n - 1];
                n--;
            }
        }
    }
}
```



## 118. Pascal's Triangle
Tag: Array, Dynamic Programming

![image-20250709001351802](./leetcode.assets/image-20250709001351802.png)

```python
class Solution:
    # TC: O(n^2)
    # SC: O(1)
    def generate(self, numRows: int) -> List[List[int]]:
        res = [
            [1]
        ]
        if numRows == 1:
            return res
        for i in range(1, numRows, 1):
            last_row = res[i - 1]
            cur_len = i + 1
            cur = [1]
            for j in range(1, len(last_row), 1):
                cur.append(last_row[j] + last_row[j-1])
            cur.append(1)
            res.append(cur)
        return res
```
方法：

121 ->

1211 ->

1 (1+2) (2+1) 1



```java
    public List<List<Integer>> generate(int numRows) {

       	List<List<Integer>> l = new ArrayList<>(numRows);
        List<Integer> l0 = new ArrayList<>();
        for (int i = 0; i < numRows; i++) {
            l0.add(1);
            for (int j = l0.size()-2; j >= 1; j--) {
                l0.set(j, l0.get(j)+l0.get(j-1));
            }
            l.add(new ArrayList<>(l0));
        }
        return l;


        //         List<List<Integer>> l = new ArrayList<>(numRows);
        // List<Integer> l0 = new ArrayList<>();
        // l0.add(1);
        // l.add(l0);
        // for (int i = 1; i < numRows; i++) {
        //     List<Integer> tempL = new ArrayList<>(i+1);
        //     tempL.add(1);
        //     List<Integer> lastL = l.get(i-1);
        //     for (int j = 1; j < lastL.size(); j++) {
        //         tempL.add(lastL.get(j-1) + lastL.get(j));
        //     }
        //     tempL.add(1);
        //     l.add(tempL);
        // }
        // return l;
    }
```

## 119. Pascal's Triangle II
Tag: Array, Dynamic Programming
```python
class Solution:
    # TC: O(n^2)
    # SC: O(1)
    def getRow(self, rowIndex: int) -> List[int]:
        res = [1]
        for i in range(0, rowIndex, 1):
            res.append(1)
            n = len(res)
            for j in range(n-2, 0, -1):
                res[j] += res[j-1]
        return res
```

## 189. Rotate Array
Tag: Array, Rotate, Two Pointers
![image-20230630234029078](./leetcode.assets/image-20230630234029078.png)
```python
class Solution:
    # TC: O(n)
    # SC: O(1)
    # Use start and end is better, reduce calculations
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = k % n
        self.rotate_range(nums, 0, n-1)
        self.rotate_range(nums, 0, k - 1)
        self.rotate_range(nums, k, n-1)

    def rotate_range(self, nums: List[int], start: int, end: int) -> None:
        while start < end:
            temp = nums[start]
            nums[start] = nums[end]
            nums[end] = temp
            start += 1
            end -= 1

    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = k % n
        for i in range(n//2):
            temp = nums[i]
            nums[i] = nums[n - 1- i]
            nums[n - 1- i] = temp
        for i in range(k//2):
            temp = nums[i]
            nums[i] = nums[k - 1- i]
            nums[k - 1- i] = temp
        for i in range(k, (n-k)//2 + k, 1):
            temp = nums[i]
            nums[i] = nums[n + k - 1 - i]
            nums[n + k - 1 - i] = temp
```

方法：

先全部反转

反转 0 到 k - 1

反转 k 到 最后

```java
    public void rotate(int[] nums, int k) {
        k = k % nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k-1);
        reverse(nums, k, nums.length - 1);

    }

    public void reverse(int[] nums, int start, int end){
        while (start < end){
            int temp = nums[start];
            nums[start++] = nums[end];
            nums[end--] = temp;
        }
    }
```



## 209. Minimum Size Subarray Sum
tag: Array, Two Pointers, Sliding Windows

![image-20250709001419039](./leetcode.assets/image-20250709001419039.png)

```python
class Solution:
    # TC: O(n) right pointer move n times and left pointer move at most n times
    # SC: O(1)
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0 # 0 - n-1
        right = 0 # 1 - n
        n = len(nums)
        sm = 0
        res = float('inf')
        while right < n:
            sm += nums[right]
            right += 1 # is larger than 1 bit
            while sm >= target:
                res = min(res, right - left)
                sm -= nums[left]
                left += 1
        return 0 if res == float('inf') else res

    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0 # 0 - n-1
        right = 1 # 1 - n
        n = len(nums)
        sm = 0
        res = n
        while left < right and right <= n:
            while sm < target and right <= n:
                sm += nums[right-1]
                right += 1
            if sm < target:
                return res if res != n else 0
            while sm >= target and left < right:
                sm -= nums[left]
                left += 1
            res = min(res, right - left)
        return res
```

方法1：

一个一个加，然后判断

方法2：

右指针直接加到大于等于target的地方，

左指针直接减到小于target的地方

```
    public int minSubArrayLen(int target, int[] nums) {
        int min = Integer.MAX_VALUE;
        int sum = 0;
        int j = 0;
        int i = 0;
        while (j < nums.length){
            sum += nums[j++];
            while (sum >= target){
                sum -= nums[i++];
                min = Math.min(min, j-i+1);
            }
        }
        return min == Integer.MAX_VALUE ? 0: min;

//  int left = 0, right = 0;
//         int min = Integer.MAX_VALUE;
//         int sum = 0;
//         while (left < nums.length && right<nums.length){
//             while (right < nums.length && sum < target){
//                 sum += nums[right];
//                 right++;
//             }
//             if(left == 0 && right == nums.length && sum < target){
//                 return 0;
//             }
//             while (left<nums.length && sum >= target){
//                 sum -= nums[left];
//                 left++;
//             }

//             min = Math.min(min, right-left+1);
//         }
//         return min;
    }
```

## 287. Find the Duplicate Number
Tag: Array, Floyd’s Cycle Detection
```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # no change nums and const extra space
        slow = 0
        fast = 0

        slow = nums[slow]
        fast = nums[nums[fast]]

        while nums[slow] != nums[fast]:
            slow = nums[slow]
            fast = nums[nums[fast]]

        slow = 0
        while nums[slow] != nums[fast]:
            slow = nums[slow]
            fast = nums[fast]
        return nums[slow]
```

## 283. Move Zeroes
Tag: Array
![image-20230614214439581](leetcode.assets/image-20230614214439581.png)


```python
# TC: O(n)
# SC: O(1)
class Solution(object):
    def moveZeroes(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        cur = 0
        n = len(nums)
        for i in range(n):
            if nums[i] != 0:
                temp =nums[cur]
                nums[cur] = nums[i]
                nums[i] = temp
                cur+=1

        # cur = 0
        # n = len(nums)
        # for i in range(n):
        #     if nums[i] != 0:
        #         nums[cur] = nums[i]
        #         cur += 1

        # for j in range(cur, n, 1):
        #     nums[j] = 0
```


和26题一样的解法

```java
    public void moveZeroes(int[] nums) {
        int position = 0;

        for (int i = 0; i < nums.length; i++) {
            if(nums[i] != 0){
                nums[position] = nums[i];
                position ++;
            }
        }

        for (int i = position; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
```

或者：

从左到右，遇到不是0的，则与最左边的0交换，一直到结尾

```java
        int snowBallSize = 0;
        for (int i=0;i<nums.length;i++){
            if (nums[i]==0){
                snowBallSize++;
            }
            else if (snowBallSize > 0) {
                int t = nums[i];
                nums[i]=0;
                nums[i-snowBallSize]=t;
            }
        }
```





## 414. Third Maximum Number
Tag: Array

![image-20250709001437210](./leetcode.assets/image-20250709001437210.png)

```python
# TC: O(n)
# SC: O(1)
class Solution(object):
    def thirdMax(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        m1 = None
        m2 =None
        m3 =None
        for ele in nums:
            if ele == m1 or ele == m2 or ele == m3:
                continue
            if m1 is None or ele > m1:
                m3 = m2
                m2 = m1
                m1 = ele
            elif m2 is None or ele > m2:
                m3 = m2
                m2 = ele
            elif m3 is None or ele> m3:
                m3 = ele
        return m1 if m3 is None else m3
```




方法1：

先sort，然后用HashSet来装所有的元素

如果set大于等于3，则取倒数第三个值

否则，取最大的值


a


方法2：

用三个变量来标记三个最大的值

在遍历的时候

​	若某一个最大值为空或者大于某一个最大值，则变更前三大数字



```
    public int thirdMax(int[] nums) {
        //         Arrays.sort(nums);
        // HashSet<Integer> hs = new HashSet<Integer>();
        // for (int i = nums.length - 1; i > -1 ; i--) {
        //     hs.add(nums[i]);
        //     if(hs.size() == 3){
        //         return nums[i];
        //     }
        // }
        // return nums[nums.length -1];

        Integer first = null;
         Integer second = null;
         Integer third = null;
         for (Integer num : nums) {
             if(num.equals(first) || num.equals(second) || num.equals(third)){
                    continue;
             }
             if(first == null || num > first){
                 third = second;
                 second = first;
                 first = num;
             }else if(second == null || num > second){
                 third = second;
                 second = num;
             } else if (third == null ||num > third) {
                 third = num;
             }
         }


         return third == null ? first : third;

    }
```





## 448. Find All Numbers Disappeared in an Array
Tag: Array, Cyclic Sort
![image-20230616193351698](leetcode.assets/image-20230616193351698.png)


```python
# TC: O(n)
# SC: O(n)
class Solution(object):
    def findDisappearedNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        n = len(nums)
        output = [0] * (n + 1)
        for ele in nums:
            output[ele] = 1
        res = []
        for i in range(1, len(output), 1):
            if output[i] == 0:
                res.append(i)
        return res

# Iterate each positions value as its an index
# TC: O(2n) -> O(n)
# SC: O(1)
class Solution(object):
    def findDisappearedNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        n = len(nums)
        for i in range(n):
            cur = i
            nv = nums[cur]
            while nv != cur + 1:
                temp = nums[nv - 1]
                nums[nv - 1] = nv
                cur = nv - 1
                nv = temp
        res = []
        for i in range(n):
            if nums[i] != i + 1:
                res.append(i + 1)
        return res
```



方法0：

遍历

​	把第i位与其该在的位置交换 ----> 一直换到第i位正确，或者第i位与其该在的位置数字一样才停止  `!(nums[i] == i+1 || nums[i] == nums[nums[i] - 1])`

遍历找出第i位不是i+1的数字

```java
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i] != i+1 && nums[i] != nums[nums[i] - 1]){
                int temp = nums[nums[i] - 1]; // 调换记得先调换不影响nums[i]值的那个数字，否则调换失败
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }
        ArrayList<Integer> al = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] != i+1){
                al.add(i+1);
            }
        }
        return al;
    }
```



方法1：

把nums[i] 的值看成index，把对应位数的数字变成负数来表示该位有数

```java
	public List<Integer> findDisappearedNumbers(int[] nums) {
			for (int i = 0; i < nums.length; i++) {
            int index;
            if (nums[i] < 0) {
                index = nums[i] * -1 -1;
            }else{
                index = nums[i]-1;
            }
            
            nums[index] = nums[index] < 0 ? nums[index] : nums[index] * -1;
        }

        ArrayList<Integer> al = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] > 0){
                al.add(i+1);
            }
        }
        return al;
    }
```



方法2：

用一个长度相当的新的数组，用它的index有值来表示原来数组的某个位置有数

然后查找从1-n，没有被标记的index为没有出现的数字

```java
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int[] resultArr = new int[nums.length + 1];
        for (int num:
             nums) {
            resultArr[num] = 1;
        }
        ArrayList<Integer> resultList = new ArrayList<>();

        for (int i = 1; i < nums.length + 1; i++) {
            if(resultArr[i] != 1){
                resultList.add(i);
            }
        }
        return resultList;
    }
```





## [485. Max Consecutive Ones](https://leetcode.com/problems/max-consecutive-ones/)
tag: Array, Two Pointers, Sliding Window

![image-20250709001457325](./leetcode.assets/image-20250709001457325.png)

```python
# TC: O(n)
# SC: O(1)
class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        max_value = 0
        cur_value = 0
        for ele in nums:
            if ele == 1:
                cur_value += 1
                max_value = max(max_value, cur_value)
            else:
                cur_value = 0
        return max_value

# TC: O(n)
# SC: O(1)
class Solution1(object):
    def findMaxConsecutiveOnes(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        left = 0
        right = 0
        max_cons = 0
        nums_len = len(nums)
        while left < nums_len:
            left = right
            while left < nums_len and nums[left] == 0:
                left += 1
            right = left
            while right < nums_len and nums[right] == 1:
                right += 1
            max_cons = max(max_cons, right - left)
        return max_cons
```


```java
    public int findMaxConsecutiveOnes(int[] nums) {
    // 双指针
        int start = 0;
        int right = 0;
        int max = 0;
        while (start<nums.length && right<nums.length){
            start = right;
            while (start<nums.length && nums[start] == 0){start++;}
            right = start;
            while (right<nums.length && nums[right] == 1){right++;}
            max = Math.max(right-start, max);
        }
        return max;
   // 一般解法
        int max = 0;
        int count = 0;
        for(int i: nums){
            count = i == 1 ? count + 1 : 0;
            max = count > max ? count : max;
        }
        return max;
    }
```



## [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/)





![image-20230618105323042](./leetcode.assets/image-20230618105323042.png)



```java
        int[] pre = new int[nums.length];
        int[] suff = new int[nums.length];
		// pre
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] == 1){
                if(i == 0){
                    pre[i] = 1;
                }else{
                    pre[i] = pre[i-1] + 1;
                }
            }else{
                pre[i] = 0;
            }
        }
		// suff
        for (int i = nums.length - 1; i >= 0; i--) {
            if(nums[i] == 1){
                if(i == nums.length - 1){
                    suff[i] = 1;
                }else{
                    suff[i] = suff[i+1] + 1;
                }
            }else{
                suff[i] = 0;
            }
        }
		// all 1: [1,1,1,1]
        if(pre[nums.length - 1] == nums.length){
            return nums.length;
        }
		// pre+i0+suff
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] == 0){
                int len = 0;
                // 下面这种写法考虑到了 0 和 n-1的情况
                if(i > 0) {
                    len+=pre[i-1];
                }
                if(i < nums.length -1){
                    len+=suff[i+1];
                }
                ans = Math.max(len + 1, ans);
            }
        }
        return ans;
```

## 498. Diagonal Traverse
## 498. Diagonal Traverse
Tag: Array, Matrix
![image-2025062649801](./leetcode.assets/image-2025062649801.png)

```python
**class Solution:
    # TC: O(m*n)
    # SC: O(1)
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        m = len(mat)
        n = len(mat[0])
        i = 0
        j = 0
        res = []
        while True:
            res.append(mat[i][j])
            if i == m - 1 and j == n - 1:
                break
            if (i + j) % 2 == 0:
                if i == 0 or j == n - 1:
                    if j < n - 1:
                        j += 1
                    else:
                        i += 1
                else:
                    i -= 1
                    j += 1
            else:
                if i == m - 1 or j == 0:
                    if i < m - 1:
                        i += 1
                    else:
                        j += 1
                else:
                    i += 1
                    j -= 1
        return res
        return res
```

## 724. Find Pivot Index
Tag: Array
![image-20230622105748130](./leetcode.assets/image-20230622105748130.png)

![image-20230622105816122](./leetcode.assets/image-20230622105816122.png)

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        # TC: O(n)
        # SC: O(1)
        r_sum = 0
        for ele in nums:
            r_sum += ele
        l_sum = 0
        n = len(nums)
        for i in range(n):
            r_sum -= nums[i]
            if i > 0:
                l_sum += nums[i-1]
            if l_sum == r_sum:
                return i
        return -1
```

```java
  public int pivotIndex(int[] nums) {
  
  // 这个没有考虑负数，以为两边都是正数，审题！
//        int sum1 = 0;
//        int sum2 = 0;
//        int left = 0;
//        int right = nums.length - 1;
//
//        while (left<right){
//            if(sum1 >= sum2){
//                sum2 += nums[right--];
//            }else {
//                sum1 += nums[left++];
//            }
//        }
//
//        if(sum1 == sum2){
//            return left;
//        }
//        return -1;

        int sum = 0;
        for (int num :
                nums) {
            sum += num;
        }
        int left = 0;
        for (int i = 0; i < nums.length; i++) {
            if(i != 0){
                left += nums[i-1];
            }
            sum -= nums[i];
            if(left == sum){
                return i;
            }
        }

        return -1;
    }
```

## 747. Largest Number At Least Twice of Others
Tag: Array

![image-20250709001525817](./leetcode.assets/image-20250709001525817.png)

```python
class Solution:
    # TC: O(n)
    # SP: O(1)
    def dominantIndex(self, nums: List[int]) -> int:
        l = None
        l2 = None
        idx = -1
        n = len(nums)
        for i in range(n):
            ele = nums[i]
            if l is None:
                l = ele
                idx = i
            else:
                if ele > l:
                    l2 = l
                    l = ele
                    idx = i
                elif l2 is None:
                    l2 = ele
                elif ele > l2:
                    l2 = ele
        return idx if l >= l2*2 else -1
```

## 905. Sort Array By Parity
Tag: Array, Two Pointers

![image-20250709001542586](./leetcode.assets/image-20250709001542586.png)

```python
# TC: O(n)
# SC: O(1)
class Solution(object):
    def sortArrayByParity(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        cur = 0
        n = len(nums)
        for i in range(n):
            if nums[i] %2 == 0:
                temp = nums[i]
                nums[i] = nums[cur]
                nums[cur] = temp
                cur += 1
        return nums
```
遍历，用position标记下一个偶数放的位置

​	如果遇到偶数，与position交换，position++



```
        int position = 0;
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] % 2 == 0){
                int temp = nums[position];
                nums[position] = nums[i];
                nums[i] = temp;
                position++;
            }
        }
        return nums;
```



创建新数组，遍历，使用一头一尾两个index表示偶数与非偶数的位置

​	如果遇到偶数，放开头

​	如果不是偶数，放结尾

```
		int[] result = new int[nums.length];
        int position = 0;
        int none = nums.length - 1;
        for (int num : nums) {
            if (num % 2 == 0) {
                result[position++] = num;
            }else{
                result[none--] = num;
            }
        }

        return result;
```



## 941. Valid Mountain Array
Tag: Array, Two Pointers

![image-20250709001606788](./leetcode.assets/image-20250709001606788.png)

```python
# TC: O(n)
# SC: O(1)
class Solution8(object):
    def validMountainArray(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        up = 0
        n = len(arr)
        down = n - 1
        while up < n - 1:
            if arr[up] < arr[up+1]:
                up += 1
            else:
                break

        while down > 0:
            if arr[down] < arr[down-1]:
                down-=1
            else:
                break
        return True if up == down and up > 0 and down < n - 1 else False
```

从头开始查，升序到尽头的index1

从尾开始查，降序到尽头的index2

比较两个index，且不是两头时，则时mountain array

solution

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        int n = arr.length;
        int i = 0;
        int j = n-1;
        while (i+1 < n && arr[i] < arr[i+1]){
            i++;
        }
        while(j-1 >= 0 && arr[j] < arr[j-1]){
            j--;
        }
        return i > 0 && j < n-1 && i == j;
    }
}
```

solution 1

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        
        int maxIndex = 0;
        boolean up = false;
        boolean down = false;
        for (int i = 0; i < arr.length; i++) {
            if(arr[maxIndex] < arr[i]){
                maxIndex = i;
            }
        }
        for(int i = 1; i <= maxIndex; i++){
            if(arr[i] <= arr[i-1]){
                return false;
            }
            up = true;
        }

        for(int i = maxIndex+1; i < arr.length; i++){
            if(arr[i] >= arr[i-1]){
                return false;
            }
            down = true;
        }
        return up && down;
    }
}
```

solution 2

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        if(arr.length < 3){
            return false;
        }
        boolean door = true;
        boolean up = false;
        boolean down = false;
        for (int i = 1 ; i < arr.length; i++) {
            if(arr[i] == arr[i-1]){
                return false;
            }
            if(door){
                if(arr[i] > arr[i-1]){
                    up = true;
                }else{
                    door = false;
                    down = true;
                }
            }else{
                if(arr[i] > arr[i-1]){
                    return false;
                }
            }
        }
        return up && down;
    }
}
```



## [977. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/)
Tag: Array, Two Pointers
![image-20230617170845425](./leetcode.assets/image-20230617170845425.png)

```python
# from ends to middle
# TC: O(n)
# SC: O(n)
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        left = 0
        right = len(nums) - 1
        res = [0] * len(nums)
        i = right
        while left <= right:
            if nums[left] ** 2 < nums[right] ** 2:
                res[i] = nums[right] ** 2
                right -= 1
            else:
                res[i] = nums[left] ** 2
                left += 1
            i -= 1
        return res

# from middle to two ends
# TC: O(n)
# SC: O(n)
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        nums_len = len(nums)
        left = 0
        right = 0
        res = [0] * nums_len
        i = 0
        for index in range(nums_len):
            if nums[index] < 0:
                left = index
                continue
            else:
                break
        right = left + 1
        while left >= 0 and right < nums_len:
            if nums[left]**2 < nums[right]**2:
                res[i] = nums[left]**2
                left -= 1
            else:
                res[i] = nums[right]**2
                right += 1
            i+=1
        while left >= 0:
            res[i] = nums[left] ** 2
            left -= 1
            i += 1
        while right < nums_len:
            res[i] = nums[right] ** 2
            right += 1
            i += 1
        return res


```


用两个指针标记头和尾，比较他们的绝对值大小，从result数组的结尾开始赋值



```
    public int[] sortedSquares(int[] nums) {
        int i = 0;
        int j = nums.length - 1;

        int[] result = new int[nums.length];
        for (int k = nums.length - 1; k >= 0; k--) {
            if(Math.abs(nums[i]) > Math.abs(nums[j])){
                result[k] = nums[i] * nums[i];
                i++;
            }else{
                result[k] = nums[j] * nums[j];
                j--;
            }
        }
        return  result;
    }
```





## [1089. Duplicate Zeros](https://leetcode.com/problems/duplicate-zeros/)
Tag: Array, Two Pointers
![image-20230612171217969](./leetcode.assets/image-20230612171217969.png)

```python
# TC: O(n)
# SC: O(1)
class Solution3(object):
    def duplicateZeros(self, arr):
        """
        :type arr: List[int]
        :rtype: None Do not return anything, modify arr in-place instead.
        """
        i = 0
        zeros = 0
        last_zero = False
        n = len(arr)
        while i + zeros < n:
            if arr[i] == 0:
                if i + zeros == n - 1:
                    last_zero = True
                else:
                    zeros += 1
            i += 1
        j = n - 1
        while j >= 0:
            if j == n - 1 and last_zero:
                arr[j] = 0
                j -= 1
                continue
            if arr[j - zeros] == 0:
                arr[j] = 0
                arr[j - 1] = 0
                zeros -= 1
                j -= 2
            else:
                arr[j] = arr[j - zeros]
                j -= 1

```



1. 算出一共往右边移动了几位，用两个变量来记录

   1. 第一个变量记录往右边移动了几位
   2. 第二个变量记录特殊情况，即当中间某一位0被移动到最后一位时，不用复制0（因为已经达到数组的最后）

   过程：

   遍历的长度从0到 总长度 - 移动的位数

   ​	如果遇到0

   ​		如果此时是 总长度 - 移动的位数 ----> 则上述第二个变量为true，即最后一位为不用复制的0

   ​		如果不是 总长度 - 移动位数 ----> 则第一个变量++

2. 从数组最右边开始赋值，从右到左遍历

   ​	如果是最后一位，且变量2为true ----> 则只赋值最后一位为0，进入下一轮循环

   ​	（其实此时里面有另一个循环，是从长度 - 位移，到0的循环）

   ​	如果长度 - 位移是0

   ​		赋值当前位数和上一位为0

   ​		外循环减少一轮

   ​		位移减少1

   ​	如果不是0

   ​		当前数组为 = 长度 - 位数的数组值

   ```java
   class Solution {
       public void duplicateZeros(int[] arr) {
           if(arr.length == 1){
               System.out.println(arr[0]);
               return;
           }
   
           int leftShift = 0;
           boolean isZeroEndButNotDouble = false;
           for(int i = 0; i < arr.length - leftShift; i++){
               if(arr[i] == 0){
                   if(i == arr.length - leftShift - 1){
                       isZeroEndButNotDouble = true;
                       break;
                   }
                   leftShift++;
               }
           }
   
           for(int j = arr.length - 1; j >= 0; j--){
               if(j == arr.length - 1 && isZeroEndButNotDouble){
                   arr[j] = 0;
                   continue;
               }
               if(arr[j - leftShift] == 0){
                   arr[j] = 0;
                   leftShift--;
                   j--;
                   arr[j] = 0;
               }else{
                   arr[j] = arr[j - leftShift];
               }
           }
   
       }
   }
   ```

   

## [1295. Find Numbers with Even Number of Digits](https://leetcode.com/problems/find-numbers-with-even-number-of-digits/)

Tag: Array

![image-20250709001623086](./leetcode.assets/image-20250709001623086.png)


```python
# TC: O(n)
# SC: O(1)
class Solution(object):
    def findNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        count = 0
        for ele in nums:
            if len(str(ele)) % 2 == 0:
                count += 1
        return count
```


## 1299. Replace Elements with Greatest Element on Right Side
Tag: Array
![image-20230614152908705](leetcode.assets/image-20230614152908705.png)

```python
# TC: O(n)
# SC: O(1)
class Solution9(object):
    def replaceElements(self, arr):
        """
        :type arr: List[int]
        :rtype: List[int]
        """
        # 1. Two for loop, find the biggest
        # 2. From right to left
        max_value = -1
        n = len(arr)
        for i in range(n-1, -1, -1):
            if arr[i] > max_value:
                # switch
                temp = max_value
                max_value = arr[i]
                arr[i] = temp
            else:
                arr[i] = max_value
        return arr
```

从右往左遍历，用max记录右边最大值

​	如果当前值比最大值大，两个值替换

```
    public int[] replaceElements(int[] arr) {

        int max = -1;
        for (int i = arr.length - 1; i >= 0 ; i--) {
            if(arr[i] > max){
                int tempMax = arr[i];
                arr[i] = max;
                max = tempMax;
            }else{
                arr[i] = max;
            }
        }
        return arr;
    }
```





## 1346. Check If N and Its Double Exist
Tag: Array

![image-20230613163829541](./leetcode.assets/image-20230613163829541.png)

```python
# TC: O(n)
# SC: O(n)
class Solution7(object):
    def checkIfExist(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        s = set()
        for ele in arr:
            if ele * 2 in s or (ele % 2 == 0 and ele // 2 in s):
                return True
            else:
                s.add(ele)
        return False
```


**solution 1**

利用hashset

如果里面有当前数字的一半或者两倍，则为true，否则添加进去

```

```





**solution 2**

ez题目，一个一个找就行

O(n^2)

遍历

​	如果当前值的2倍在整个列表中（再遍历）有的话，则返回true

都没有，返回false

```java
class Solution {
    public boolean checkIfExist(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            if(checkn(arr, i)){
                return true;
            }
        }
        return false;
    }

    public static boolean checkn(int[] arr, int index){
        for (int i = 0; i < arr.length; i++) {
            if(i == index){
                continue;
            }
            if(arr[i] == arr[index]*2){
                return true;
            }
        }
        return false;
    }
}
```



# String (Python)

```python
# 1. compare
'aaa' == 'aaa' # True
# 2. Concatenate
s1 = "hello"
s1 += " world"
# 3. Find character
idx = s1.find('o') # first occurrence
idx = s1.rfind('o') # last occurrence
# 4. Substring
s1[6:11] # from inclusive, end exclusive
# 5. toCharArray
char_list = list(s1)
char_list[4]
# Convert back to string
"".join(char_list)
# 6. StringBuilder, use string and list


# 7. Convert int to str
n = 1
s = str(1)
>>> s
>>> "1"
s = int(s)
>>> 1
# 8. Convert char to int
>>> ord('a')
>>> 97
>>> ord('a') - ord('0')
>>> 0
a = '0'
ord(a) - ord('0') # 0
ord(a) - ord('0') # 0
# 9. Sort string
# sorted and reversed return an iterator
"".join(sorted(s))
"".join(reversed(s))
# 10. format string
'''
{[变量]:[填充][对齐][宽度][,][.精度][类型]}
填充：
默认不填充
- 0：填充0

对齐：
默认有对齐
- <: 左对齐
- ^: 居中
- >: 有对齐

宽度：
默认原始宽度
- 数字：总宽度，包括小数点，不包括千分位分隔

分隔符：
- .: 小数点分隔
- ,: 千分位分隔

精度：
- 数字：小数点后保留的位数

类型：
- f：固定点（小数）
- e / E：科学计数法
- g / G：自动选择科学计数或浮点
- d：整数
- o/x/b：八进制/十六进制/二进制
'''
x = 3.14159
print("{:.2f}".format(x))   # 输出: 3.14
print(f"{x:.2f}")           # f-string 写法：3.14

print(f"{x:08.2f}") # 00003.14 最后输出的总宽度，最少是8，包括小数点。如果整数过多，则会超出8位
print(f"{'hi':*>6}")  # 输出: '****hi'。字符串的format中，可以用任意单个字符作为补充

print(f"{5:031b}") # 0是补充，31是宽度，b是类型
```

# String

## Compare and substring

```java
// compare using equals
System.out.println("s1 and s2: " + s1.equals(s2));
// compare using compareTo
System.out.println("s1 and s2: " + (s1.compareTo(s2) == 0));

String s1 = "Hello World";
// 1. concatenate
s1 += "!";
System.out.println(s1);
// 2. find
System.out.println("The position of first 'o' is: " + s1.indexOf('o'));
System.out.println("The position of last 'o' is: " + s1.lastIndexOf('o'));
// 3. get substring
System.out.println(s1.substring(6, 11));
//For instance, if the length of the string is N, the time complexity of both finding operation and substring operation is O(N).
```

## toCharArray

```java
// If you want your string to be mutable, there are some substitutions:
String s = "Hello World";
char[] str = s.toCharArray();
str[5] = ',';
System.out.println(str);

// revert char[] back to string
new String(str); // better
// or
String.valueOf(str);
```

## StringBuilder

```java
//  If you have to concatenate strings often, it will be better to use some other data structures like StringBuilder. The below code runs in O(n) complexity.
int n = 10000;
StringBuilder str = new StringBuilder();
StringBuilder str = new StringBuilder("ABCD");
// using stringbuilder, time complexity is O(n), if using str +=, time complexity is O(n^2)
for (int i = 0; i < n; i++) {
    str.append("hello");
}
String s = str.toString();

// append
str.append("hello");

// index char by index
char c = str.charAt(0);

// delete substring
str.delete(0,2);

// indexOf, lastIndexOf
// length
int l = str.length();

// toString
str.toString();
```

## String, Integer, int

```java
// String to int
String str = "123";
int num = Integer.parseInt(str);
// String to Integer;
Integer num = Integer.valueOf(str);
// int to String;
String s = String.valueOf(num);
String s = Integer.toString(num);
String s = num + "";
```

## char, int

```java
// char 是基于 Unicode 的字符编码，而字符在底层实际上被表示为整数（char 的数值范围是 0 到 65535），int则表示 -2^31 到 2^31-1，在算数运算和比较时，char会自动转换为int，这是安全的。
char a = '0';
int num = a - '0';
'h' == 104; // true

```

## Sort String

```java
    String sortString(String s){
        char[] cs = s.toCharArray();
        Arrays.sort(cs);
        return new String(cs);
    }
```









## 5. Longest Palindromic Substring

![image-20230623220147856](./leetcode.assets/image-20230623220147856.png)

```java
class Solution {
  public String longestPalindrome(String s) {
  
        // Optimized two pointer, 优化地方：当下一个值与当前值相同时，必定是在该回文中
        int start = 0;
        int len = 1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            int j = i;
            while(j+1 < s.length() && s.charAt(j+1) == c){ // 找到后面与当前值不相同当index，然后再从两头开始搜索
                j++;
            }
            if(j-i+1 > len){
                start = i;
                len = j-i+1;
            }
            if(i-1 >= 0 && j+1 < s.length()){
                int extend = search2(s, i-1, j+1);
                if(j-i +1 + (2*extend) > len){
                    start = i-extend;
                    len = j-i+1+ (2*extend);
                }
            }
            i = j;
        }
        return s.substring(start,start+len);
  	
        // dp dynamic programming
//        boolean[][] state = new boolean[s.length()][s.length()];
//        for (int i = 0; i < state.length; i++) {
//                state[i][i] = true;
//        }
//        int start = 1, len = 1;
//        for (int i = state[0].length - 1; i >= 0; i--) {
//            for (int j = i+1; j <= state[0].length - 1; j++) {
//                if(s.charAt(i) == s.charAt(j) && (state[i+1][j-1] || j-i == 1)){
//                    state[i][j] = true;
//                    if(j-i+1 > len){
//                        start = i;
//                        len = j - i + 1;
//                    }
//                }else{
//                    state[i][j] = false;
//                }
//            }
//        }
//
//        return s.substring(start, start + len);

        
        // 从i开始向两边扩散（加上i和i+1相同的情况），双指针
        // String str = s.substring(0,1);
        // for (int i = 0; i < s.length(); i++) {
        //     char c = s.charAt(i);
        //     if(i-1 >= 0 && i+1 < s.length()){
        //         String temp = search(s, i-1, i+1);
        //         if(temp.length() > str.length()){
        //             str = temp;
        //         }
        //     }
        //     if(i+1 < s.length() && s.charAt(i+1) == c){
        //         if(str.length() < 2){
        //             str = s.substring(i, i+2);
        //         }
        //         String temp = search(s, i-1, i+2);
        //         if(temp.length() > str.length()){
        //             str = temp;
        //         }
        //     }
        // }
        // return str;
    }
    
    public String search(String s, int l, int r){ // 从l，r开始向两边搜索，返回搜索到的最长的字符串
        while (l>=0 && r<s.length()){
            if(s.charAt(l) == s.charAt(r)){
                l--;
                r++;
            }else{
                return s.substring(l+1, r);
            }
        }
        return s.substring(l+1, r);
    }
    
    public int search2(String s, int l, int r){ // 从l，r开始向两边搜索，返回单边增加了多少
        int i = 0;
        while (l>=0 && r<s.length()){
            if(s.charAt(l) == s.charAt(r)){
                l--;
                r++;
                i++;
            }else{
                return i;
            }
        }
        return i;
    }
}
```





## 14. Longest Common Prefix
Tag: String, Trie
![image-20230623111648066](./leetcode.assets/image-20230623111648066.png)
```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        # String
        # TC: O(m*n)
        # SC: O(1)
        common  = strs[0]
        n = len(strs)
        for i in range(1,n,1):
            m_l = min(len(common), len(strs[i]))
            for j in range(m_l, -1, -1):
                if common[:j] == strs[i][:j]:
                    common = common[:j]
                    break
            if len(common) == 0:
                return ""
        return common
```
```java
String result = strs[0];
for (String str :strs) {
    if(result.length() > str.length()){
        result = result.substring(0,str.length());
    }
    for (int j = 0; j < Math.min(str.length(), result.length()); j++) {
        if(result.charAt(j) != str.charAt(j)){
            result = str.substring(0,j);
            if(j == 0){
                return "";
            }
        }
    }
}
return result;
```

## 28. Find the Index of the First Occurrence in a String
Tag: String
![image-20230625235532477](./leetcode.assets/image-20230625235532477.png)
```python
class Solution:
    # TC: O(m*n) slice caused O(stop-start)
    # SC: O(1)  ignoring temporary slices since they’re garbage collected
    def strStr(self, haystack: str, needle: str) -> int:
        res  = 0
        n = len(haystack)
        l = len(needle)
        for i in range(n):
            if i+l <= n and haystack[i: i+l] == needle:
                return i
        return -1
    def strStr(self, haystack: str, needle: str) -> int:
        # TC: O(m*n)
        # SC: O(1)
        res  = 0
        n = len(haystack)
        l = len(needle)
        for i in range(n):
            if haystack[i] == needle[0]:
                all_match = True
                for j in range(1, l, 1):
                    if i+j < n and haystack[i + j] == needle[j]:
                        pass
                    else:
                        all_match = False
                        break
                if all_match:
                    return i
        return -1
        
```
注意substring

i的范围在  i=0; i<haystack.len 的时候， substring取 i,i+1，取一个字符

所以当substring取len个字符，即 i到i+len的时候，haystack.len - (len-1)

```java
    public int strStr(String haystack, String needle) {
        int len = needle.length();

        for (int i = 0; i < haystack.length() - (len-1); i++) {
            if(haystack.substring(i, i+1+len-1).equals(needle)){
                return i;
            }
        }
        return -1;
    }
```



## 67. Add Binary

![image-20230625234204745](./leetcode.assets/image-20230625234204745.png)

注意输入的取值范围，大于32位的Integer 4 byte，大于64位的long 8byte。只做单纯二进制加法

方法：

carry记录进位，sum%2, sum/2取值

```
	public String addBinary(String a, String b) {
        int al = a.length() - 1;
        int bl = b.length() - 1;
        StringBuilder sb = new StringBuilder();
        int sum;
        int carry = 0;
        while (al >= 0 || bl >= 0 ){
            sum = carry;
            if (al >= 0){
                sum+=a.charAt(al--) - '0';
            }

            if (bl >= 0){
                sum+=b.charAt(bl--) - '0';
            }
            sb.append(sum % 2);
            carry = sum / 2;
        }
        if(carry != 0){
            sb.append(carry);
        }
        
        return  sb.reverse().toString();
    }
```



## 151. Reverse Words in a String
Tag: String, Two Pointers, Sliding Window
![image-20230623220232747](./leetcode.assets/image-20230623220232747.png)

![image-20230623220252930](./leetcode.assets/image-20230623220252930.png)
```python
class Solution:
    # TC: O(n)
    # SC: O(1) or O(n)
    def reverseWords(self, s: str) -> str:
        # sliding windows
        # use list save each words
        n = len(s)
        left = n-1
        right = n-1
        res = []
        while left >= 0:
            right = left
            while s[right] == ' ' and right >= 0:
                right -= 1
            left = right
            while s[left] != ' ' and left >= 0:
                left -= 1
            if left != right:
                res.append(s[left+1: right + 1])
        return " ".join(res)

```
方法1:

- 反转string
- 反转每个单词
- 清除多余的空格

方法2:

- 筛出每个单词并保存（stack）
- 反向穿起来

方法3:

- java内置方法
- 先trim两边的空格
- 再通过 空格+ 正则分开单词
- 再通过Collections.reverse反转单词顺序
- 再通过String.join 连接所有单词

```

 class Solution {

    public String reverseWords(String s) {
        // reverse all string
        // reverse each word
        // clean spaces
        char[] chars = s.toCharArray();
        reverse(chars, 0 , s.length()-1);
        reverseWord(chars);
        return cleanSpaces(chars);

        // java build-in method
//        String[] words = s.trim().split(" +");
//        Collections.reverse(Arrays.asList(words));
//        return String.join(" ",words);

        // save each word, concat reversely
//        Stack<int[]> stack = new Stack<>();
//        int[] starAndLen = {-1,-1};
//        boolean isWord = false;
//        for (int i = 0; i < s.length(); i++) {
//            if(s.charAt(i) == ' '){
//                if(!isWord){
//                    continue;
//                }
//                starAndLen[1] = i-1;
//                stack.push(starAndLen.clone());
//                isWord = !isWord;
//            }else{
//                if(!isWord){
//                    starAndLen[0] = i;
//                    isWord = true;
//                }
//            }
//        }
//        if(isWord){
//            starAndLen[1] = s.length()-1;
//            stack.push(starAndLen.clone());
//        }
//        StringBuilder sb = new StringBuilder();
//        while (!stack.empty()){
//            int[] temp = stack.pop();
//            sb.append(s, temp[0], temp[1]+1);
//            sb.append(" ");
//        }
//        return sb.substring(0,sb.length()-1);
    }

    public void reverse(char[] chars, int i , int j){
        while (i<j){
            char temp = chars[i];
            chars[i++] = chars[j];
            chars[j--] = temp;
        }
    }

    public void reverseWord(char[] chars){
        int i = 0, j=0;
        int n = chars.length;
        while (i<n){
            while (i<j || i<n && chars[i] == ' ')i++; // 右边是skip space（到达non-space地方）, 左边是到下一个space到地方
            while (j<i || j<n && chars[j]!= ' ')j++; // 右边是skip non-space，左边是到下一个non-space的地方
            reverse(chars, i, j-1);

            // can also write as below
//            while (i<n && chars[i] == ' ')i++;
//            j=i+1;
//            while (j<n && chars[j] != ' ')j++;
//            reverse(chars, i, j-1);
//            i=j;
        }

        // whole as this
//        int start;
//        for (int i = 0; i < chars.length; i++) {
//            if(chars[i] != ' '){
//                start = i;
//                while (i < chars.length && chars[i] != ' '){
//                    i++;
//                }
//                reverse(chars, start, i-1);
//            }
//        }
    }

    public String cleanSpaces (char[] chars){
        int i = 0, j = 0, n = chars.length;
        while (j<n){
            while (j<n && chars[j] == ' ')j++; // i skip space
            while (j<n && chars[j] != ' ')chars[i++] = chars[j++]; // keep non space
            while (j<n && chars[j] == ' ')j++; // i skip space
            if(j<n)chars[i++] = ' '; // 上一步skip space，且还没有到n，说明还有单词，所以可以加空格
        }
        return new String(chars, 0, i);
    }

    public String cleanSpaces2 (char[] chars){
        StringBuilder sb = new StringBuilder();
        sb.append(chars[0]);
        for (int i = 1; i < chars.length; i++) {
            if (chars[i-1] == ' ' && chars[i] == ' ') {
                continue;
            }
            sb.append(chars[i]);
        }
        return sb.toString().trim();
    }
}

```

## 167. Two Sum II - Input Array Is Sorted
Tag: Array, Two Pointers
![image-20230626130345826](./leetcode.assets/image-20230626130345826.png)
```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        # TC: O(n)
        # SC: O(1)
        n = len(numbers)
        start = 0
        end = n - 1
        while start != end:
            t = numbers[start] + numbers[end]
            if t == target:
                return [start + 1, end + 1]
            elif t < target:
                start += 1
            else:
                end -= 1
        return [0,0]
```

暴力解法会超时

用双指针，因为一定会有解，从两边开始找

```java
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        while (true){
            if(numbers[left] + numbers[right] > target){
                right --;
            }else if(numbers[left] + numbers[right] < target){
                left++;
            }else {
                return new int[]{left+1, right+1};
            }
        }     
    }
```



## 344. Reverse String
Tag: Array, String
![image-20230626120252825](./leetcode.assets/image-20230626120252825.png)
```python
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        l = 0
        r = len(s) - 1
        while l < r:
            s[l],s[r] = s[r],s[l]
            l += 1
            r -= 1

        # TC: O(n)
        # SC: O(1)
        n = len(s)
        for i in range(n//2):
            temp = s[i]
            s[i] = s[n-1-i]
            s[n-1-i] = temp
```
```java
    public void reverseString(char[] s) {
                for (int i = 0; i < s.length/2; i++) {
            char temp = s[i];
            s[i] = s[s.length - 1- i];
            s[s.length - 1- i] = temp;
        }
    }
```

## 557. Reverse Words in a String III
Tag: String, Two Pointers, Sliding Window

![image-20250709001650950](./leetcode.assets/image-20250709001650950.png)

```python
class Solution:
    # TC: O(n + n) O(n)
    # SC: O(n)
    # When reverse single word, we could also use two pointers and exchagne them in half word length to reduce half time complexity
    def reverseWords(self, s: str) -> str:
        res = []
        left = 0
        right = 0
        n = len(s)
        while right < n:
            left = right
            while left < n and s[left] == ' ':
                left += 1
            right = left
            while  right < n and s[right] != ' ':
                right += 1
            res.append(s[left:right][::-1])
        return ' '.join(res)

    def reverse_str(self, s: str, left: int, right: int)->str:
        res = ''
        for i in range(right, left - 1, -1):
            res += s[i]
        return res
```

## 561. Array Partition

![image-20230626120714206](./leetcode.assets/image-20230626120714206.png)

```java
    public int arrayPairSum(int[] nums) {
                Arrays.sort(nums);
        int sum = 0;
        for (int i = 0; i < nums.length; i+=2) {
            sum += nums[i];
        }
        return sum;
    }
```


# Linked List



```java
// Definition for singly-linked list.
public class SinglyListNode {
    int val;
    SinglyListNode next;
    SinglyListNode(int x) { val = x; }
}
```

### Add

![image-20241016124418815](./leetcode.assets/image-20241016124418815.png)

### Delete

![image-20241016124446709](./leetcode.assets/image-20241016124446709.png)

Constructor

```
LinkedList()

LinkedList(Collection<? extends E> c)
```

## Double linked list

```java
// Definition for doubly-linked list.
class DoublyListNode {
    int val;
    DoublyListNode next, prev;
    DoublyListNode(int x) {val = x;}
}
```



Build-in LinkedList

```java
LinkedList<Integer> deque = new LinkedList<>();
// 1. add first
deque.addFirst(10); // [10]
// 2. add to last
deque.addLast(20);  // [10, 20]
// 3. remove first
deque.removeFirst();
// 4. remove last
deque.removeLast();
```







## [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)
Tag: Linked List,
![image-20230812012940487](leetcode.assets/image-20230812012940487.png)
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# TC: O(max(m, n))
# SC: O(max(m, n)) but answer is not count as space complexity, so O(1)
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: Optional[ListNode]
        :type l2: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        dummy_h = ListNode(0)
        h = dummy_h
        add_on = 0
        while l1 is not None or l2 is not None or add_on != 0:
            a1 = 0 if l1 is None else l1.val
            a2 = 0 if l2 is None else l2.val
            total = a1 + a2 + add_on
            add_on = total // 10
            h.next = ListNode(total % 10)
            h = h.next
            if l1 is not None:
                l1 = l1.next
            if l2 is not None:
                l2 = l2.next
            
        return dummy_h.next
```


```java
 public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // return addTwoNumbers2(l1,l2,0);

        // Method2:
          ListNode head = new ListNode(0);
        ListNode prev = head;
        int add = 0;
        while (l1!=null || l2 != null || add != 0){
            ListNode cur = l1 != null ? l1:(l2 != null? l2 : new ListNode(0));
            int v = (l1!=null ? l1.val: 0) + (l2 != null ? l2.val : 0) + add;
            add = v / 10;
            v %= 10;
            cur.val = v;
            head.next = cur;
            head = head.next;

            l1 = l1 == null ? l1:l1.next;
            l2 = l2 == null ? l2:l2.next;
        }
        return prev.next;
        
        //  ListNode head = new ListNode();
        // ListNode originHead = head;
        // int v = 0;
        // int add = 0;
        // while (l1!=null || l2 != null || add != 0){
        //     v = (l1!=null ? l1.val: 0) + (l2 != null ? l2.val : 0) + add;
        //     add = v / 10;
        //     v %= 10;
        //     head.val = v;
        //     if((l1 == null || l1.next == null) &&(l2 == null || l2.next == null) && add == 0){
        //         break;
        //     }
        //     head.next = new ListNode();
        //     l1 = l1 == null ? l1:l1.next;
        //     l2 = l2 == null ? l2:l2.next;
        //     head = head.next;
        // }
        // return originHead;
    }
    public ListNode addTwoNumbers2(ListNode l1, ListNode l2, int add) {
        if(l1 == null && l2 == null){
            if(add == 1){
                return new ListNode(1);
            }else{
                return null;
            }
        }
        int v = (l1!=null ? l1.val: 0) + (l2 != null ? l2.val : 0) + add;
        if(v >= 10){
            v = v-10;
            add = 1;
        }else{
            add = 0;
        }

        if(l1 == null && l2!=null){
            l2.val = v;
            l2.next = addTwoNumbers2(l1, l2.next, add);
            return l2;
        }
        if(l2 == null && l1!=null){
            l1.val = v;
            l1.next = addTwoNumbers2(l1.next, l2, add);
            return l1;
        }

        l1.val = v;
        l1.next = addTwoNumbers2(l1.next,l2.next,add);
        return l1;
    }
}
```



## [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
Tag: Linked List, Two Pointers

![image-20230730123537955](./leetcode.assets/image-20230730123537955.png)

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# TC: O(n)
# SC: O(1)
class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: Optional[ListNode]
        :type n: int
        :rtype: Optional[ListNode]
        """
        dumy_h = ListNode(0)
        dumy_h.next = head
        p1 = dumy_h
        p2 = dumy_h

        while n > 0:
            p1 = p1.next
            n-=1
        while p1.next is not None:
            p1 = p1.next
            p2 = p2.next
        p2.next = p2.next.next
        return dumy_h.next
        
        # 下面方法跑了两遍
        # TC: O(2n)
        # SC: O(1)
        # dumy_h = ListNode(0)
        # dumy_h.next = head
        # p = dumy_h
        # i = 0
        # while p is not None:
        #     p = p.next
        #     i += 1
        # steps = i - n
        # p = dumy_h
        # while steps - 1 > 0:
        #     p= p.next
        #     steps -= 1
        # p.next = p.next.next
        # return dumy_h.next
        
        # 下面没有使用dummy head，多了许多判断和漏了边界条件，可以添加dummy head
        # p = head
        # i = 0
        # while p is not None:
        #     p = p.next
        #     i += 1
        # if i == 1 and n == 1:
        #     return None
        # if n == i:
        #     return head.next
        # steps = i - n
        # p = head
        # while steps -1 > 0:
        #     p = p.next
        #     steps -= 1
        # p.next = p.next.next if p.next is not None else None
        # return head
```

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
                // method1: two pointers, let the fast pointer step n steps first, and when it reaches the end
        // the slow pointer is at the n-1 from end.
        ListNode p1 = new ListNode();
        ListNode p2;
        ListNode p3;
        p2=p1;
        p3=p1;
        p1.next = head;
        int t = n+1;
        while (t-->0){
            p2=p2.next;
        }
        while (p2!=null){
            p2 = p2.next;
            p1=p1.next;
        }
        p1.next = p1.next.next;
        return p3.next;
        //         if(head.next == null){
        //     return null;
        // }
        // ListNode p1 = head;
        // ListNode p2 = head;
        // while (n-->0){
        //     p2=p2.next;
        // }
        //         if(p2==null){
        //     head = head.next;
        //     return head;
        // }
        // while (p2.next!=null){
        //     p1=p1.next;
        //     p2=p2.next;
        // }
        // p1.next = p1.next.next;
        // return head;
        // int size = 1;
        // ListNode hs = head;
        // while (hs.next!=null){
        //     hs=hs.next;
        //     size++;
        // }
        // hs=head;
        // if(n == size){
        //     return head.next;
        // }
        // int pass = size - n-1;

        // while(pass-- != 0){
        //     hs=hs.next;
        // }
        // hs.next=hs.next.next;

        // return head;
    }
}
```

## 21. Merge Two Sorted Lists
Tag: Linked List, Recursion
![image-20230811230822528](leetcode.assets/image-20230811230822528.png)
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def mergeTwoLists(self, list1, list2):
        """
        :type list1: Optional[ListNode]
        :type list2: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        # TC: O(m+n)
        # SC: O(1)
        dummy_h = ListNode(0)
        h = dummy_h
        while list1 is not None and list2 is not None:
            if list1.val < list2.val:
                h.next = list1
                list1 = list1.next
            else:
                h.next = list2
                list2 = list2.next
            h=h.next
        if list1 is None:
            h.next = list2
        else:
            h.next = list1
        
        return dummy_h.next

        # Recursion
        # TC: O(m+n)
        # SC: O(m+n)
        if list1 is None:
            return list2
        
        if list2 is None:
            return list1

        
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```
```java
public class ez21MergeTwoSortedLists {

    public static void main(String[] args) {
        ListNode l1 = new ListNode(1);
        ListNode l2 = new ListNode(2);
        ListNode l3 = new ListNode(4);
        l1.next = l2;
        l2.next= l3;


        ListNode n1 = new ListNode(1);
        ListNode n2 = new ListNode(3);
        ListNode n3 = new ListNode(4);
        n1.next = n2;
        n2.next = n3;

        ez21MergeTwoSortedLists test = new ez21MergeTwoSortedLists();
        ListNode result = test.mergeTwoLists(l1, n1);
        System.out.println();
    }

    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        if(list1 == null){
            return list2;
        }
        if(list2 == null){
            return list1;
        }
        if(list1.val < list2.val){
            list1.next = mergeTwoLists(list1.next,list2);
            return list1;
        }else{
            list2.next=mergeTwoLists(list1,list2.next);
            return list2;
        }

        // Method1: merge one list into another
//        // list1 as origin,
//        // merge list2 into list1
//        if(list1 == null){
//            return list2;
//        }
//        if(list2 == null){
//            return list1;
//        }
//
//        if(list1.val < list2.val){
//            return merge(list1, list2);
//        }else{
//            return merge(list2, list1);
//        }

        // Method2: merge two lists into a new listnode
        //    if(list1 == null){
        //        return list2;
        //    }
        //    if(list2 == null){
        //        return list1;
        //    }
        //     ListNode head = new ListNode();
        //     ListNode originHead = head;
        //     while(list1 != null && list2 != null){
        //         if(list1.val <= list2.val){
        //             head.val = list1.val;
        //             list1 = list1.next;
        //         }else{

        //             head.val = list2.val;
        //             list2 = list2.next;
        //         }
        //         head.next = new ListNode();
        //         head = head.next;
        //     }
        //     if(list1 == null){
        //         head.val = list2.val;
        //         head.next = list2.next;
        //     }else{
        //         head.val = list1.val;
        //         head.next = list1.next;
        //     }
        //     return originHead;

    }

    public ListNode merge(ListNode list1, ListNode m){
        ListNode origin = list1;
        ListNode next =  origin.next;
        while (m != null){
            if(next == null){
                origin.next = m;
                break;
            }
            if(m.val >= origin.val && m.val <= next.val){
                origin.next = new ListNode(m.val, next);
                m = m.next;
            }
            origin = origin.next;
            next = origin.next;
        }
        return list1;
    }

}

```

## 61. Rotate List
Tag: Linked List, Two Pointers

![image-20250624193546358](./leetcode.assets/image-20250624193546358.png)

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def rotateRight(self, head, k):
        """
        :type head: Optional[ListNode]
        :type k: int
        :rtype: Optional[ListNode]
        """
        # TC: O(n)
        # SC: O(1)
        if head is None:
            return head
        l = 0
        h = head
        while h is not None:
            h = h.next
            l += 1
        res = k % l
        if res == 0:
            return head
        fast = head
        while res > 0:
            fast = fast.next
            res -= 1
        slow = head
        while fast.next is not None:
            fast = fast.next
            slow = slow.next
        n_h = slow.next
        slow.next = None
        fast.next = head
        return n_h
```




## 138. Copy List with Random Pointer
Tag: Linked List, Hash Table

![image-20250624184003479](./leetcode.assets/image-20250624184003479.png)

![image-20250624184008240](./leetcode.assets/image-20250624184008240.png)



先复制，连接，再拆分

![image-20250624193230942](./leetcode.assets/image-20250624193230942.png)




```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x, next=None, random=None):
        self.val = int(x)
        self.next = next
        self.random = random
"""
class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        # 先连接复制，再拆分
        # TC: O(n)
        # SC: O(1)
        if head is None:
            return head
        h = head
        while head is not None:
            next = head.next
            head.next = Node(head.val)
            head.next.next = next
            head = next
        head = h
        while head is not None:
            if head.random is not None:
                head.next.random = head.random.next
            head = head.next.next
        head = h
        res = head.next
        while head is not None:
            next = head.next.next
            if next is not None:
                head.next.next = next.next
            head.next = next
            head = next
        return res


        # Hashtable
        # TC: O(n)
        # SC: O(n)
        d = {}
        dummy_n = Node(0)
        n = dummy_n
        h = head
        while head is not None:
            temp = Node(head.val)
            n.next = temp
            d[head] = temp
            n = n.next
            head = head.next
        n = dummy_n.next
        while h is not None:
            if h.random is not None:
                n.random = d.get(h.random)
            h = h.next
            n = n.next
        return dummy_n.next


```


## 141. Linked List Cycle
Tag: Two Pointers, Floyd’s Cycle Detection
![image-20230705201832794](./leetcode.assets/image-20230705201832794.png)

![image-20230705201914153](./leetcode.assets/image-20230705201914153.png)
```python
# TC: O(n)
# SC: O(1)
class Solution11(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        fast = head
        slow = head

        while fast is not None and fast.next is not None and fast.next.next is not None:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```

Solution:

1. Using two pointers
2. One go one step each time, another go two steps each time.
3. If there is a circle, the longer step will catch up the shorter step pointer.

```java
    public boolean hasCycle(ListNode head) {
        ListNode n1 = head;
        ListNode n2 = head;

        while(n2 != null && n2.next != null && n2.next.next != null ){
            n2 = n2.next.next;
            n1 = n1.next;
            if(n1 == n2){
                return true;
            }
        }
        return false;
    }
```

## 142. Linked List Cycle II
Tag: Two Pointers, Floyd’s Cycle Detection
![image-20230709134411097](./leetcode.assets/image-20230709134411097.png)

![image-20230709134423752](./leetcode.assets/image-20230709134423752.png)

![image-20230709134440423](./leetcode.assets/image-20230709134440423.png)

![image-20230709134440423](./leetcode.assets/image-2025062101.png)
```python
'''
x len to circle start
k the first round steps
r circle len

2k - k = nr
because: 
nr = x + a
so:
x = nr - a
so:
x = n-1 (r) + rest
A new pointer start from start and the slower pointer also start move from where it is. They will meet at the start of the circle
'''
# TC: O(n)
# SC: O(1)
class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        fast = head
        slow = head

        while fast is not None and fast.next is not None:
            fast = fast.next.next
            slow = slow.next
            if fast is slow:
                break
        if fast is None or fast.next is None:
            return None
        
        ano_start = head
        while True:
            if ano_start is slow:
                break
            ano_start = ano_start.next
            slow = slow.next
        return slow

```

using two pointers, one of them one step at a time. another pointer each take two steps. Suppose the first meet at step ***k***,the length of the Cycle is ***r***. so..**2k-k=nr,k=nr**
Now, the distance between the start node of list and the start node of cycle is ***s***. the distance between the start of list and the first meeting node is ***k***(the pointer which wake one step at a time waked k steps).the distance between the start node of cycle and the first meeting node is ***m***, so...**s=k-m,
s=nr-m=(n-1)r+(r-m),here we takes n = 1**..so, using one pointer start from the start node of list, another pointer start from the first meeting node, all of them wake one step at a time, the first time they meeting each other is the start of the cycle.

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null){
            return null;
        }
        ListNode p1 = head;
        ListNode p2 = head;
        while(p2.next != null && p2.next.next != null){
            p1 = p1.next;
            p2 = p2.next.next;
            if(p1.equals(p2) ){
                break;
            }
        }
        
        if(p2.next == null || p2.next.next == null){
            return null;
        }

        ListNode p3 = head;
        while(p1 != p3){
            p1 = p1.next;
            p3 = p3.next;
        }
        return p1;
    }
}
```



## 160. Intersection of Two Linked Lists

![image-20230709134125181](./leetcode.assets/image-20230709134125181.png)

![image-20230709134142175](./leetcode.assets/image-20230709134142175.png)

Solution 1:

Add one ListNode to another, so to get two same size of ListNodes.

```
        ListNode a = headA;
        ListNode b = headB;

        while(a != b){
            a = a == null ? headB : a.next;
            b = b == null ? headA : b.next;
        }

        return a;
```



My solution:

1. Find each size of two ListNode as **sizeA** **sizeB**.
2. Cut the extra part that one ListNode is longer than another, which is **diff of sizeA and sizeB**, Making two ListNodes as same size.
3. Two ListNodes start go next one step every time, finding if there is a common node.

```java
     		
// solution 2 get The Diff
				ListNode a = headA;
        ListNode b = headB;
        int sizeA = 0;
        int sizeB = 0;
        while(a != null){
            sizeA ++;
            a = a.next;
        }
        while(b != null){
            sizeB ++;
            b = b.next;
        }

        a = headA;
        b = headB;
        int diff = sizeA - sizeB;
        
        if(diff != 0){
            if(diff > 0){
                while(diff != 0){
                    a = a.next;
                    diff--;
                }
            }else{
                while (diff != 0){
                    b = b.next;
                    diff++;
                }
            }
        }
        
        while(a != null){
            if(a.equals(b)){
                return a;
            }
            a = a.next;
            b = b.next;
        }
        return null;
    }
```

## [203. Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/)
Tag: Linked List, Recursion
![image-20230730123223316](./leetcode.assets/image-20230730123223316.png)
```python

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution(object):
    def removeElements(self, head, val):
        """
        :type head: Optional[ListNode]
        :type val: int
        :rtype: Optional[ListNode]1
        """
        dummy_h = ListNode(0)
        dummy_h.next = head
        h = dummy_h
        while h.next is not None:
            if h.next.val == val:
                h.next = h.next.next
            else:
                h = h.next
        return dummy_h.next

        # TC: O(n)
        # SC: O(n)
        # Recursion, 局部变量，返回地址，参数等会压入call stack
        # if head is None:
        #     return head
        # head.next = self.removeElements( head.next,val)
        # if head.val == val:
        #     return head.next
        # return head

```

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
           // recursive
        if(head == null){
            return null;
        }
        head.next = removeElements(head.next,val);
        if(head.val == val){
            return head.next;
        }else{
            return head;
        }
        // ListNode n = new ListNode();
        // ListNode n2 = new ListNode();
        // n2 = n;
        // n.next = head;
        // while (n.next!=null){
        //     if (n.next.val == val) {
        //         n.next = n.next.next;
        //     }else {
        //         n=n.next;
        //     }
        // }
        // return n2.next;
    }
}
```



## [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)
Tag: Linked List
![image-20230730123703471](./leetcode.assets/image-20230730123703471.png)
```python
# TC: O(n)
# SC: O(1)
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def reverseList(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
    
        prev = None
        while head is not None:
            next = head.next
            head.next = prev
            prev = head
            head = next

        return prev
```
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
public ListNode reverseList(ListNode head) {

        // ListNode prev = null;
        // ListNode next;

        // while (head != null){
        //     next = head.next;            
        //     head.next = prev;
        //     prev = head;
        //     head = next;
        // }
        // return prev;

                return reverseList(head, null);


        // if(head == null){
        //     return null;
        // }
        // ListNode newHead = head;
        // while(newHead.next != null){
        //     newHead = newHead.next;
        // }
        // reverse(head);
        // return newHead;x
    }

    // return the tail of the List
    public ListNode reverse(ListNode head){
        if(head.next == null){
            return head;
        }
        ListNode reversedTail = reverse(head.next);
        head.next = null;
        reversedTail.next = head;
        return head;
    }

        public ListNode reverseList(ListNode head, ListNode prev){
        if(head == null){
            return prev;
        }
        ListNode next = head.next;
        head.next = prev;
        prev = head;
        head = next;
        return reverseList(head, prev);
    }
}
```

## [234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)
Tag: Linked List, Two Pointers
![image-20230730141848828](./leetcode.assets/image-20230730141848828.png)
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def isPalindrome(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: bool
        """
        # TC: O(n)
        # SC: O(1)
        slow = head
        fast = head
        while fast.next is not None and fast.next.next is not None:
            slow = slow.next
            fast = fast.next.next
        h2 = slow.next

        if fast.next is None:
            # total len is odd, slow is at middle
            h1 = self.reverse(head, slow)
        else:
            # total len is even, slow is at first half end
            h1 = self.reverse(head, slow.next)
        
        while h1 is not None:
            if h1.val != h2.val:
                return False
            h1 = h1.next
            h2 = h2.next
        return True
        
    def reverse(self, head, h2):
        prev = None
        while head is not h2:
            next = head.next
            head.next = prev
            prev = head
            head = next
        return prev
```
```
public boolean isPalindrome(ListNode head) {
              ListNode p1 = head;
        ListNode p2 = head;

        while (p2!=null&& p2.next !=null){
            p1 = p1.next;
            p2 = p2.next.next;
        }
        p1 = reverseLinkedList(p1,null);
        while (p1 != null){
            if(p1.val == head.val){
                p1= p1.next;
                head = head.next;
            }else{
                return false;
            }
        }
        return true;
    }

    public ListNode reverseLinkedList(ListNode head, ListNode prev){
        if(head == null){
            return prev;
        }
        ListNode next = head.next;
        head.next = prev;
        prev = head;
        head = next;
        return reverseLinkedList(head, prev);
    }
```



## [328. Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list/)
Tag: Linked List
![image-20230730121254899](./leetcode.assets/image-20230730121254899.png)
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def oddEvenList(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        # TC: O(n)
        # SC: O(1)
        if head is None or head.next is None:
            return head
        
        odd = head
        even = head.next
        res = head
        dummy_even = head.next

        while even is not None and even.next is not None:
            odd.next = even.next
            even.next = even.next.next
            odd = odd.next
            even = even.next
        odd.next = dummy_even
        return res
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
                if(head == null){
            return null;
        }
        ListNode p1 = head;
        ListNode p3;
        ListNode p2 = head.next;
        p3 = p2;


        while (p2 != null && p2.next != null){
            p1.next = p1.next.next;
            p2.next = p2.next.next;
                        p1 = p1.next;
            p2=p2.next;
        }
        p1.next = p3;
        return head;
    }
}
```


## 430. Flatten a Multilevel Doubly Linked List
Tag: Linked List
![image-20250624181521323](./leetcode.assets/image-20250624181521323.png)

![image-20250624181528959](./leetcode.assets/image-20250624181528959.png)


```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
"""
# TC: O(n)
# SC: O(1)
class Solution(object):
    def flatten(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        dummy_h = head
        while head is not None:
            if head.child is None:
                head = head.next
            else:
                next = head.next
                child = head.child
                while child.next is not None:
                    child = child.next
                head.next = head.child
                head.child.prev = head
                head.child = None
                if next is not None:
                    child.next = next
                    next.prev = child
                head = head.next
        return dummy_h
```





## 707. Design Linked List

![image-20230705201602427](./leetcode.assets/image-20230705201602427.png)

![image-20230705201649208](./leetcode.assets/image-20230705201649208.png)

```java
class MyLinkedList {
    Node head;
    int size;
    public MyLinkedList() {
        size = 0;
    }
    
    public int get(int index) {
        if(index >= size){
            return -1;
        }
        Node tempNode = head;
        for(int i = 0; i < index; i++){
            tempNode = tempNode.next;
        }
        return tempNode.val;
    }
    
    public void addAtHead(int val) {
        Node tempHead = new Node(val, head);
        this.head = tempHead;
        size++;
    }
    
    public void addAtTail(int val) {
        Node tail = new Node(val);
        if(head == null){
            head = tail;
        }else{
            Node tempNode = head;
            while(tempNode.next != null){
                tempNode = tempNode.next;
            }
            tempNode.next = tail;
        }
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        if(index == 0){
            addAtHead(val);
        }else if(index == size){
            addAtTail(val);
        }else if(index >= size){
            return;
        }else{
            Node addNode = new Node(val);
            Node prev = head;
            for(int i = 0; i < index - 1; i++){
                prev = prev.next;
            }
            addNode.next = prev.next;
            prev.next = addNode;
            size++;
        }
    }
    
    public void deleteAtIndex(int index) {
        if(index >= size || index < 0){
            return;
        }
        if(index == 0){
            if(head.next == null){
                head = null;
            }else{
                head = head.next;
            }
            size--;
        }else{
            Node prev = head;
            for(int i = 0; i < index - 1; i++){
                prev = prev.next;
            }
            prev.next = prev.next.next;
            size--;
        }
    }

}

class Node{
    int val;
    Node next;

    public Node(){}

    public Node(int val, Node next){
        this.next = next;
        this.val = val;
    }

    public Node(int val){
        this.val = val;
    }


}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```


# Set (Python)

```python
# in, add, remove 在set中，平均 TC 为 O(1),最坏为O(n), SC 为 O(n)
# 1. 初始化 set
hash_set = set()

# 2. 添加新元素, add 无返回
hash_set.add(3)
hash_set.add(2)
hash_set.add(1)

# 3. 移除元素（如果元素不存在会报错，建议使用 discard）
hash_set.remove(2)  # 2没在set中时报错
hash_set.discard(2) # 安全不报错

# 4. 判断元素是否存在
if 2 not in hash_set:
    print("Key 2 is not in the hash set.")
if 2 in hash_set:
    pass

# 5. 获取大小
print(f"The size of hash set is: {len(hash_set)}")

# 6. 遍历 set
for i in hash_set:
    print(i, end=" ")
print("are in the hash set.")

# 7. 清空 set
hash_set.clear()

# 8. 判断是否为空
if not hash_set:
    print("hash set is empty now!")

# 9. 过滤列表，只保留出现在另一个集合中的元素（retainAll）
cars = ["Volvo", "BMW"]
valid = {"Volvo"}

# retainAll: Python 中用 set 过滤
cars = [car for car in cars if car in valid]

print(cars)  # ['Volvo']

# 10. filter out掉另一个set中的元素
cars = ["Volvo", "BMW"]
valid = {"Volvo"}
res = cars.difference(valid)
# res: "BMW"

# 11. &, -, ^
# intersection
# union
# difference
# symmetric diff
# Only valid on sets
```
| 操作符 | 方法名           | 含义                   | 示例                             |           |                              |
| --- | ------------- | -------------------- | ------------------------------ | --------- | ---------------------------- |
| `&` | `set1 & set2` | 交集（intersection）     | `{1,2} & {2,3}` → `{2}`        |           |                              |
|  `` ` `` | ``set1 ` set2`` | 并集（union） | `{1,2} \| {2,3}` → `{1,2,3}` |
| `-` | `set1 - set2` | 差集（difference）       | `{1,2,3} - {2,3}` → `{1}`      |           |                              |
| `^` | `set1 ^ set2` | 对称差集（symmetric diff） | `{1,2,3} ^ {2,3,4}` → `{1, 4}` |           |                              |



# Hash Table (Python dict)
```python
# in, add, remove 在dict中，平均 TC 为 O(1),最坏为O(n), SC 为 O(n)
# 1. initialize a dict
d = {}

# 2. insert a new (key, value) pair only if key not present, return original value if key exists, return default value if not exist
value = d.setdefault(0, 0)
>>> 0
value = d.setdefault(0, 3)
>>> 0

# 3. insert or update key, return old value if exist, or None
result = d.get(1)  # get if exist, or return None
result = d.get(1, 5)  # get if exist, or return default
d[1] = 1
d[1] = 2

# replace: if old value matches, update to new value
if hashmap.get(1) == 2:
    hashmap[1] = 3
    result = True
else:
    result = False

# replace without old value
result = hashmap.get(1)
if 1 in hashmap:
    hashmap[1] = 2

# getOrDefault
v = hashmap.get(1, 0)
hashmap[1] = v + 1

# 4. get the value of a specific key
print("The value of key 1 is:", hashmap.get(1))

# 5. delete a key
hashmap.pop(2, None)  # no error if key doesn't exist

# 6. check if key exists
if 2 not in hashmap:
    print("Key 2 is not in the hash map.")

# check if a value is in the hash map
if 2 not in hashmap.values():
    print("Value 2 is not in the hash map.")

# 7. get the size of hash map
print("The size of hash map is:", len(hashmap))

# 8. iterate the hash map
for k, v in hashmap.items():
    print(f"({k},{v})", end=" ")

print("\nKeys:", list(hashmap.keys()))
print("Values:", list(hashmap.values()))
print("are in the hash map.")

# 9. clear the hash map
hashmap.clear()

# 10. check if the hash map is empty
if not hashmap:
    print("hash map is empty now!")

```

## defaultdict

```python
# defaultdict
from collections import defaultdict
# 1. Initialize
d = defaultdict(int)

```

## Counter
```python
# 1. Initialize
counter = Counter('2113412345') # fill an iterable object
>>> Counter({'2': 2, '1': 2, '3': 2, '4': 2, '5': 1}) # Return a dict like object, which has methods keys, values, items, get

# 2. Get most k common elements
# Return a list of tuples
counter.most_common(3)
>>> [('2', 2), ('1', 2), ('3', 2)]
```


# HashSet

```java
   public static void main(String[] args) {
        // 1. initialize the hash set
        Set<Integer> hashSet = new HashSet<>();     
        // 2. add a new key, return true if the value is not in the set or false otherwise.
        boolean exist = hashSet.add(3);
        hashSet.add(2);
        hashSet.add(1);
        // 3. remove the key
        hashSet.remove(2);        
        // 4. check if the key is in the hash set
        if (!hashSet.contains(2)) {
            System.out.println("Key 2 is not in the hash set.");
        }
        // 5. get the size of the hash set
        System.out.println("The size of has set is: " + hashSet.size());     
        // 6. iterate the hash set
        for (Integer i : hashSet) {
            System.out.print(i + " ");
        }
        System.out.println("are in the hash set.");
        // 7. clear the hash set
        hashSet.clear();
        // 8. check if the hash set is empty
        if (hashSet.isEmpty()) {
            System.out.println("hash set is empty now!");
        }
       // 9. Remove items from a list which do not belong to a specified collection
        ArrayList<String> cars = new ArrayList<String>();
        cars.add("Volvo");
        cars.add("BMW");

        ArrayList<String> valid = new ArrayList<String>();
        valid.add("Volvo");

        cars.retainAll(valid);

        System.out.println(cars); // [Volvo]

    }
```



# HashMap

```java
    // 1. initialize a hash map
    Map<Integer, Integer> hashmap = new HashMap<>();
    // 2. insert a new (key, value) pair
    hashmap.putIfAbsent(0, 0);
    hashmap.putIfAbsent(2, 3);
    // 3. insert a new (key, value) pair or update the value of existed key, return old value if exist or null otherwise.
    int result = hashmap.put(1, 1);
    hashmap.put(1, 2);
	// replace, if old value provide, return true if replaced or false otherwise. if no old value, return old value if exist or null if the entry with the key does not exist.
	int result = hashmap.replace(1,2,3); // key, oldValue, newValue
	int result = hashmap.replace(1,2);
	// getOrDefault
	int v = hashmap.getOrDefault(1,0);
	hashmap.put(1,v+1);
    // 4. get the value of specific key
    System.out.println("The value of key 1 is: " + hashmap.get(1));
    // 5. delete a key
    hashmap.remove(2);
    // 6. check if a key is in the hash map
    if (!hashmap.containsKey(2)) {
        System.out.println("Key 2 is not in the hash map.");
    }
	// check if a value is in the hash map
	if(!hashmap.containsValue(2)){
        System.out.println("Value 2 is not in the hash map.");
    }
    // 7. get the size of the hash map
    System.out.println("The size of hash map is: " + hashmap.size()); 
    // 8. iterate the hash map
    for (Map.Entry<Integer, Integer> entry : hashmap.entrySet()) {
        System.out.print("(" + entry.getKey() + "," + entry.getValue() + ") ");
    }
	hashmap.keySet();
	hashmap.values();
    System.out.println("are in the hash map.");
    // 9. clear the hash map
    hashmap.clear();
    // 10. check if the hash map is empty
    if (hashmap.isEmpty()) {
        System.out.println("hash map is empty now!");
    }
	
```
## 2. Tow Sum
Tag: Hash Table, Array
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for i in range(len(nums)):
            if d.get(target - nums[i]) is None:
                d[nums[i]] = i
            else:
                return [d.get(target - nums[i]), i]
        return []
```

## 3. Longest Substring Without Repeating Characters
![image-20250702001](leetcode.assets/image-20250702001.png)
Tag: Hash Table, Two Pointers, String, Sliding Window
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # TC: O(n)
        # SC: O(n)
        start = 0
        end = 0
        res = 0
        window = set()
        n = len(s)
        while end < n:
            while end < n and s[end] not in window:
                window.add(s[end])
                end += 1
            res = max(res, end - start)
            # while end < n and  s[end] in window:
            window.remove(s[start])
            start += 1
        return res
                
```


## 36. Valid Sudoku
Tag: Array, Hash Table, Matrix
```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        # TC: O(1)
        # SC: O(1)
        rows = [set() for _ in range(9)]
        cols = [set() for _ in range(9)]
        boxes = [set() for _ in range(9)]
        for i in range(9):
            for j in range(9):
                v = board[i][j]
                if v == '.':
                    continue
                box_idx = (i // 3) * 3 + j // 3
                if v in rows[i]  or v in cols[j] or v in boxes[box_idx]:
                    return False
                rows[i].add(v)
                cols[j].add(v)
                boxes[box_idx].add(v)
                
        return True
```

## 49. Group Anagrams
Tag: Hash Table, Array, String
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # TC: O(n * k log k) sort O(k log k)，其中k为要排序的字符串长度
        # SC: O(nk)
        res = []
        d = {}
        n = len(strs)
        for i in range(n):
            ele = strs[i]
            s = ''.join(sorted(ele))
            if s in d:
                res[d.get(s)].append(ele)
            else:
                d[s] = len(res)
                res.append([ele])
        return res

        # TC: O(n * k)
        # SC: O(26 n) -> O(n)
        res = []
        d = {}
        n = len(strs)
        for i in range(n):
            ele = strs[i]
            temp = [0]*26
            for char in ele:
                temp[ord(char) - ord('a')] += 1
            s = tuple(temp)
            # s = ','.join([str(char) for char in temp])
            if s in d:
                res[d.get(s)].append(ele)
            else:
                d[s] = len(res)
                res.append([ele])
        return res
```

## 136. Single Number
Tag: Hash Table, Array
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def singleNumber(self, nums: List[int]) -> int:
        s = set()
        for ele in nums:
            if ele in s:
                s.remove(ele)
            else:
                s.add(ele)
        return s.pop()
```

## 202. Happy Number
Tag: Hash Table
```python
class Solution:
    def isHappy(self, n: int) -> bool:
        # TC: O()
        # SC: O()
        st = set()
        while n not in st:
            st.add(n)
            s = str(n)
            n = 0
            for i in s:
                v = ord(i) - ord('0')
                n += v**2
            if n == 1:
                return True
        return False

    def isHappy(self, n: int) -> bool:
        # TC: O(n)
        # SC: O(1)
        slow = self.get_value(n)
        fast = self.get_value(n)
        fast = self.get_value(fast)
        while slow != fast:
            slow = self.get_value(slow)
            fast = self.get_value(fast)
            fast = self.get_value(fast)
        return True if slow == 1 else False

    def get_value(self, n: int) -> int:
        sm = 0
        while n:
            tmp = n % 10
            sm += tmp ** 2
            n //= 10
        return sm
```

## 205. Isomorphic Strings
Tag: Hash Table, Array
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        n1 = [-1] * 128
        n2 = [-1] * 128
        for i in range(len(s)):
            a = s[i]
            b = t[i]
            if n1[ord(a)] != n2[ord(b)]:
                return False
            n1[ord(a)] = i
            n2[ord(b)] = i
        return True

        s_t={}
        t_s={}
        for i in range(len(s)):
            if (s_t.get(s[i], t[i]) != t[i]) or (t_s.get(t[i], s[i]) != s[i]):
                return False
            s_t[s[i]] = t[i]
            t_s[t[i]] = s[i]
        return True
```

## 217. Contains Duplicate
Tag: Hash Table, Array
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def containsDuplicate(self, nums: List[int]) -> bool:
        s = set()
        for ele in nums:
            if ele in s:
                return True
            else:
                s.add(ele)
        return False
```

## 219. Contains Duplicate II
Tag: Hash Table, Array, Sliding Window
```python
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        # TC: O(n)
        # SC: O(n)
        # dict
        d = {}
        n = len(nums)
        for i in range(n):
            if nums[i] in d and i - d[nums[i]] <= k:
                return True
            else:
                d[nums[i]] = i
        return False

        
        # TC: O(n)
        # SC: O(n)
        # set sliding window
        s = set()
        n = len(nums)
        for i in range(n):
            if i > k:
                s.discard(nums[i - k - 1])
            if nums[i] in s:
                return True
            else:
                s.add(nums[i])
        return False
```
## 220. Contains Duplicate III
Tag: Math, HashMap, Bucket Sort, Sliding Window
```python
class Solution:
    # TC: O(n)
    # SC: O(indexDiff)
    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:
        d = {}
        size = valueDiff + 1
        for i in range(len(nums)):
            # Python // round to -inf
            id = nums[i] // size
            if id in d:
                return True
            if (id - 1) in d and nums[i] - d.get(id - 1) <= valueDiff:
                return True
            if (id + 1) in d and d.get(id + 1) - nums[i] <= valueDiff:
                return True
            d[id] = nums[i]
            if len(d) > indexDiff:
                d.pop((nums[i - indexDiff] // size), None)
        return False
```

## 349. Intersection of Two Arrays
Tag: Hash Table, Array
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1) & set(nums2))

        # TC: O(n)
        # SC: O(n)
        s = set()
        s2 = set()
        for ele in nums1:
            s.add(ele)
        for ele in nums2:
            if ele in s:
                s2.add(ele)
        return list(s2)
```

## 350. Intersection of Two Arrays II
Tag: Hash Table, Array
```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # TC: O(n)
        # SC: O(n)
        count = {}
        for ele in nums1:
            v = count.setdefault(ele, 0)
            count[ele] = v+1
        res = []
        for ele in nums2:
            v = count.get(ele, 0)
            if v > 0:
                res.append(ele)
                count[ele] -= 1
        return res
```

## 380. Insert Delete GetRandom O(1)
Tag: Hash Table, Array, Randomized
```python
class RandomizedSet:
    # All TC: O(1)
    # SC: O(n)
    def __init__(self):
        self.l = []
        self.d = {}

    def insert(self, val: int) -> bool:
        if val in self.d:
            return False
        else:
            self.d[val] = len(self.l)
            self.l.append(val)
            return True

    def remove(self, val: int) -> bool:
        if val not in self.d:
            return False
        else:
            val_idx = self.d[val]
            last_v = self.l[-1]
            self.l[val_idx] = last_v
            self.d[last_v] = val_idx
            self.l.pop()
            self.d.pop(val)
            return True

    def getRandom(self) -> int:
            return choice(self.l)

```

## 387. First Unique Character in a String
Tag: Hash Table, String
```python
class Solution:
        # TC: O(n)
        # SC: O(1)
        # lowercase letters as list
        nums = [0]*26
        n = len(s)
        for i in range(n):
            nums[ord(s[i]) - ord('a')] += 1
        for i in range(n):
            if nums[ord(s[i]) - ord('a')] == 1:
        return i

        # TC: O(n)
        # SC: O(n)
        # dict    def firstUniqChar(self, s: str) -> int:
        d = {}
        n = len(s)
        for i in range(n):
            if s[i] not in d:
                d[s[i]] = 1
            else:
                d[s[i]] += 1
        for i in range(n):
            if d.get(s[i]) == 1:
                return i
        return -1
```

## 454. 4Sum II
Tag: Hash Table, Array
```python
class Solution:
    ## TC: O(n^2)
    ## SC: O(n^2)
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        s = {}
        for ele1 in nums3:
            for ele2 in nums4:
                v = ele1 + ele2
                s[v] = s.setdefault(v, 0) + 1
        res = 0
        for ele1 in nums1:
            for ele2 in nums2:
                v = -(ele1+ele2)
                if v  in s:
                    res += s[v]
        return res
```

## 599. Minimum Index Sum of Two Lists
Tag: Hash Table
```python
class Solution:
    # TC: O(m + n)
    # SC: O(m)
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d = {}
        for i in range(len(list1)):
            d[list1[i]] = i
        m = len(list1) + len(list2)
        res = []
        for i in range(len(list2)):
            idx1 = d.get(list2[i])
            if idx1 is not None:
                if i + idx1 < m:
                    res.clear()
                    res.append(list2[i])
                    m = i + idx1
                elif i+idx1 == m:
                    res.append(list2[i])
        return res
```
## 771. Jewels and Stones
Tag: Hash Table
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        s = set(jewels)
        res = 0
        for ele in stones:
            if ele in s:
                res += 1
        return res
```


# Tree

## ^^Heap

堆（Heap）是一种特殊的树形数据结构，通常是完全二叉树。它满足堆属性，即对于最大堆（Max-Heap），父节点的值总是大于或等于子节点的值；对于最小堆（Min-Heap），父节点的值总是小于或等于子节点的值

### Heap Queue (Python)
```python
# 默认最小堆
import heapq
# 1. Initialize
l = []

# 2. Push
heapq.heappush(l, 5) # push element 5 into l, maintain heap feature

# 3. Pop
v = heapq.heappop(l) # pop the min element

# 4. Peek
l[0] # get the min element

# 5. Get n largets / smallest element
heapq.nsmallest(
    n: int, 
    iterable: Iterable[_S], 
    key: (_S) -> SupportsDunderLT | SupportsDunderGT | None = None) # iterable是可iterable对象，key是比较的函数，与sorted里的key一样。

# 6. Heapify，把一个数组转化为堆结构
heapq.heapify(l) # 此后l[0] 就是最小的了

# 7. heappushpop(heap, item)
# 当你需要将一个新元素加入堆，并且只保留堆中较大的元素时（常用于构建最大 N 个值的最小堆）。
# 它的效率比单独调用 heappush() 和 heappop() 更高，因为只需调整一次堆结构。
heapq.heappushpop(heap, item)
res = heapq.heappushpop(heap, 2) 
```


### PriorityQueue

Java中没有直接命名为`Heap`的类，但提供了`PriorityQueue`类，它内部使用堆结构来实现。`PriorityQueue`默认是一个最小堆（Min-Heap），也可以通过自定义比较器（Comparator）来实现最大堆（Max-Heap）或其他顺序。

```java
// This is the default min-heap
int comparator(a1, a2){
	return a1-a2;
}
```

```java
import java.util.PriorityQueue;

public class Main {
    public static void main(String[] args) {
        // 创建一个最小堆 (Min-Heap)
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        // 插入元素
        minHeap.add(10);
        minHeap.add(4);
        minHeap.add(15);

        // 获取最小值（不删除）
        System.out.println(minHeap.peek()); // 输出: 4

        // 删除最小值
        System.out.println(minHeap.poll()); // 输出: 4

        // 现在的最小值
        System.out.println(minHeap.peek()); // 输出: 10

        // 创建一个最大堆 (Max-Heap)
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

        maxHeap.add(10);
        maxHeap.add(4);
        maxHeap.add(15);

        // 获取最大值
        System.out.println(maxHeap.peek()); // 输出: 15
    }
}
```

offer/add

poll/remove

peek

offer的时间复杂度为 `O(log(n))` n为queue的size

## 23. Merge k Sorted Lists
Tag: Heap, Linked List, Divide and Conquer, Merge Sort
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    # Heapq
    # TC: O(kn x logk) # k lists, the longest list length is n. Add and pop of priorityqueue is logk
    # SC: O(k)
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        q = []
        h = ListNode(0)
        dummy_h = h
        counter = 0
        for l in lists:
            if l is not None:
                heapq.heappush(q, (l.val, counter, l))
                counter += 1
        while len(q):
            val, _, node = heapq.heappop(q)
            h.next = node
            h = h.next
            if node.next is not None:
                heapq.heappush(q, (node.next.val, counter, node.next))
                counter += 1
        return dummy_h.next

    # Divide and Conquer
    # TC: O(kn x logk) 2n, 4n, ---> 2n + ... + 4n total log k. (2n + 2/k n) log k / 2 = kn logk
    # SC: O(logk)
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        return self.merge(lists, 0, len(lists) - 1)

    def merge(self, lists, l, r):
        if l == r:
            return lists[l]
        if l > r:
            return None
        mid = (l + r) // 2
        return self.mergeTwoLists(self.merge(lists, l, mid), self.merge(lists, mid+1, r))

    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:
        dummy_h = ListNode(0)
        h = dummy_h
        while list1 is not None and list2 is not None:
            if list1.val < list2.val:
                h.next = list1
                list1 = list1.next
            else:
                h.next = list2
                list2 = list2.next
            h = h.next

        while list1 is not None:
            h.next = list1
            h = h.next
            list1 = list1.next
        while list2 is not None:
            h.next = list2
            h = h.next
            list2 = list2.next
        return dummy_h.next

    # Merge each two lists
    # TC: O(k^2 n) n, 2n, 3n, kn ---> (n + kn)k / 2 = kn + k^2 n = k^2 n
    # SC: O(1)
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        # h = ListNode(0)
        cur = None
        for l in lists:
            cur = self.mergeTwoLists(l, cur)
        return cur

    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:
        dummy_h = ListNode(0)
        h = dummy_h
        while list1 is not None and list2 is not None:
            if list1.val < list2.val:
                h.next = list1
                list1 = list1.next
            else:
                h.next = list2
                list2 = list2.next
            h = h.next

        while list1 is not None:
            h.next = list1
            h = h.next
            list1 = list1.next
        while list2 is not None:
            h.next = list2
            h = h.next
            list2 = list2.next
        return dummy_h.next
```

## 239. Sliding Window Maximum
Tag: Heap, 
```python
class Solution:
    # Priority Queue, 首先放入 -nums[i] 形成最大堆， 放入tuple (-nums[i], i) 去判断index是否在window中
    # TC: O(n logn)
    # SC: O(n)
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)
        res = [-q[0][0]]
        for i in range(k, n):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] < i-k+1:
                heapq.heappop(q)
            res.append(-q[0][0])
        return res

    # 维护一个windowrange内的单调双边队列，递减的。右边添加的时候，把小于该值的pop出去，然后左边把不在window内的也popleft出去。append 第一个元素即可
    # TC: O(n)
    # SC: O(k)
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        q = deque()
        for i in range(k):
            while q and nums[i] > nums[q[-1]]:
                q.pop()
            q.append(i)
        res = [nums[q[0]]]

        for i in range(k, n):
            while q and nums[i] > nums[q[-1]]:
                q.pop()
            q.append(i)

            while q[0] <= i - k:
                q.popleft()
            res.append(nums[q[0]])
        return res

    # 分块 + 预处理
    # TC: O(n)
    # SC: O(n)
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        prefix = [0] * n
        suffix = [0] * n
        
        for i in range(0, n, k):
            m1 = float('-inf')
            m2 = float('-inf')
            for j in range(i, min(i + k, n)):
                m1 = max(m1, nums[j])
                prefix[j] = m1
            for j in range(min(i + k, n) - 1, i - 1, -1):
                m2 = max(m2, nums[j])
                suffix[j] = m2

        res = []
        for i in range(n - k + 1):
            res.append(max(suffix[i], prefix[i + k - 1]))
        return res


```

## 264. Ugly Number II
Tag: Heap, Hash Table, Math, Dynamic Programming

![image-20250710230451564](./leetcode.assets/image-20250710230451564.png)

```python
class Solution:
    # TC: O(n logn)
    # SC: O(n)
    def nthUglyNumber(self, n: int) -> int:
        l = []
        heapq.heappush(l, 1)
        last = None
        s = set()
        while n > 0:
            last = heapq.heappop(l)
            if 2*last not in s:
                heapq.heappush(l, 2*last)
                s.add(2*last)
            if 3*last not in s:
                heapq.heappush(l, 3*last)
                s.add(3*last)
            if 5*last not in s:
                heapq.heappush(l, 5*last)
                s.add(5*last)
            n -= 1
        return last

    # TC: O(n)
    # SC: O(n)
    def nthUglyNumber(self, n: int) -> int:
        dp = [0] * (n+1)
        dp[1] = 1
        p2 = p3 = p5 = 1
        for i in range(2, n+1):
            m = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)
            dp[i] = m
            if m == dp[p2] * 2:
                p2 += 1
            if m == dp[p3] * 3:
                p3 += 1
            if m == dp[p5] * 5:
                p5 += 1
        return dp[n]
```

## 347. Top K Frequent Elements
Tag: Array, Hash Table, Heap (Priority Queue), Counting, Sorting, Bucket Sort, Quickselect, Divide and Conquer
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # TC: O(n*logk)
        # SC: O(m) # m is unique keys
        counter = Counter(nums) # O(n) O(m)
        return heapq.nlargest(k, counter, counter.get) # O(n*logk)
        
        # TC: O(n*logk)
        # SC: O(m) # m is unique keys
        d = {}
        for ele in nums:
            d[ele] = d.setdefault(ele, 0) + 1
        v = list(d.values())
        v.sort(reverse=True)
        m = v[k-1]
        res = [k for k,v in d.items() if v >= m]
        return res
```
## 652. Find Duplicate Subtrees
Tag: Hash Table, Tree, Depth-First Search, Binary Tree
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    # TC: O(n^2)
    # SC: O(n^2) # n is number of tree node
    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        hm = {}
        res = []
        self.traverse(hm,res,root)
        return res

    # preorder traverse
    def traverse(self, hm: dict, res: List[Optional[TreeNode]], root: Optional[TreeNode]) -> str:
        if root == None:
            return 'None'
        serializer = str(root.val) + ',' + self.traverse(hm, res, root.left) + ',' + self.traverse(hm, res, root.right)
        if serializer in hm and hm.get(serializer) == 2:
            res.append(root)
        hm[serializer] =  hm.setdefault(serializer, 1) + 1
        return serializer
```

## ^^Binary Tree

## 94. Binary Tree Inorder Traversal
Tag: Bianry Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root == None:
            return res
        res.extend(self.inorderTraversal(root.left))
        res.append(root.val)
        res.extend(self.inorderTraversal(root.right))
        return res
```

## 102. Binary Tree Level Order Traversal
Tag: Bianry Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []
        q = deque()
        if root is None:
            return res
        q.append(root)
        while len(q):
            r = []
            for _ in range(len(q)):
                node = q.popleft()
                r.append(node.val)
                if node.left is not None:
                    q.append(node.left)
                if node.right is not None:
                    q.append(node.right)
            res.append(r)
        return res
```
## 106. Construct Binary Tree from Inorder and Postorder Traversal
Tag: Recursion, Binary Tree
```python
# 1. Use index instead of slice arrays in every round
# 2. Use a dict to save the inorder values and index instead of index search everytime
# TC: O(n)
# SC: O()
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:

        def helper(in_left, in_right, post_left, post_right):
            if in_left > in_right:
                return None

            root = postorder[post_right]
            root_index = inorder_hashmap[root]
            left_size = root_index - in_left
            root_node = TreeNode(
                val=root,
                left=helper(in_left, root_index-1, post_left, post_left + left_size - 1),
                right=helper(root_index+1, in_right, post_left + left_size, post_right-1)
            )
            return root_node
        inorder_hashmap = {}
        for i, v in enumerate(inorder):
            inorder_hashmap[v] = i
        return helper(0, len(inorder) - 1, 0, len(postorder) - 1)
```
## 110. Balanced Binary Tree
Tag: Binary Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def dfs(node):
            if node is None:
                return 0
            left = dfs(node.left)
            right = dfs(node.right)
            if abs(left - right)  > 1 or left == -1 or right == -1:
                return -1
            return 1 + max(left, right)
        return dfs(root) != -1
```
## 112. Path Sum
Tag: Binary Tree, Math, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root is None:
            return False
        if root is not None and root.left is None and root.right is None:
            return True if targetSum == root.val else False
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```
## 116. Populating Next Right Pointers in Each Node
Tag: Binary Tree, Queue
```python
class Solution:
    # TC: O(n)
    # SC: O(1)
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if root is None:
            return root
        head = root
        while head.left:
            leftmost = head
            while head is not None:
                head.left.next = head.right
                if head.next:
                    head.right.next = head.next.left
                head = head.next
            head = leftmost.left
        return root
        
    # TC: O(n)
    # SC: O(n)
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        q = deque()
        if root is None:
            return root

        q.append(root)
        while len(q):
            n = len(q)
            start = None
            for _ in range(n):
                next = q.popleft()
                if next.left is not None:
                    q.append(next.left)
                if next.right is not None:
                    q.append(next.right)
                if start is not None:
                    start.next = next
                start = next
        return root
```

## 144. Binary Tree Preorder Traversal
Tag: Bianry Tree, Recursion
```python
class Solution:
    # TC: O(n) n is total node
    # SC: O(h) h is the height of the tree
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        self.traverse(root,res)
        return res

    def traverse(self, root, res):
        if root is None:
            return
        res.append(root.val)
        self.traverse(root.left, res)
        self.traverse(root.right, res)
    # TC: O(n)
    # SC: O(h)
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root is None:
            return res
        res.append(root.val)
        res.extend(self.preorderTraversal(root.left))
        res.extend(self.preorderTraversal(root.right))
        return res
```

## 145. Binary Tree Postorder Traversal
Tag: Bianry Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root == None:
            return res
        res.extend(self.postorderTraversal(root.left))
        res.extend(self.postorderTraversal(root.right))
        res.append(root.val)
        return res
```
## 236. Lowest Common Ancestor of a Binary Tree
Tag: Binary Tree, Recursion
```python
class Solution:
    # If the func does not found any p q in root, return None
    # If the func found one node, return the node
    # If the func found two nodes, return their root
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root == None or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left != None and right != None:
            return root
        return left if left is not None else right
```
## 297. Serialize and Deserialize Binary Tree
Tag: Binary Tree, Recursion
```python
class Codec:
    # TC: O(n)
    # SC: O(h)
    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = []
        self.helper(root, res)
        return ",".join(str(i) for i in res)

    def helper(self, root, res):
        if root is not None:
            res.append(root.val)
            self.helper(root.left, res)
            self.helper(root.right, res)
        else:
            res.append(None)
            return

    # TC: O(n)
    # SC: O(h)
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        idx = 0
        data = data.split(",")
        data = [int(i) if i != "None" else None for i in data]
        
        def helper():
            nonlocal idx
            if data[idx] is None:
                idx += 1
                return None
            root = TreeNode(data[idx])
            idx += 1
            left = helper()
            right = helper()
            root.left = left
            root.right = right
            return root

        return helper()
```


## ^^Trie
Typically, a trie is used to store strings, and it split the string part by part, Each Trie node represents a string (a prefix). Each node might have several children nodes while the paths to different children nodes represent different characters.
![image.png](./leetcode.assets/image-20250717001.png)

Also know as **prefix tree** cause all descendants of a node has common prefix
Represent a Trie
```python
class TrieNode:
    N = 26
    children = new TrieNode[N]

from typing import Dict
class TrieNode:
    children: Dict[str, TrieNode] = {}
    
    // you might need some extra values according to different cases

```

## 208. Implement Trie (Prefix Tree)
Tag: Trie, Array, Hash Table
```python
# dict
class Trie:
    def __init__(self):
        self.d = {}

    # TC: O(n) # n is word len
    # SC: O(s*n) # s is each word, n is len
    def insert(self, word: str) -> None:
        trie = self
        for c in word:
            if c not in trie.d:
                trie.d[c] = Trie()
            trie = trie.d[c]
        trie.d['is_end'] = True

    def search(self, word: str) -> bool:
        trie = self
        for c in word:
            if c not in trie.d:
                return False
            trie = trie.d[c]
        return True if trie.d.get('is_end') else False

    def startsWith(self, prefix: str) -> bool:
        trie = self
        for c in prefix:
            if c not in trie.d:
                return False
            trie = trie.d[c]
        return True

class Trie:
    # TC: O(1)
    # SC: O(1)
    def __init__(self):
        self.children = [0] * 26
        self.is_word = False

    # TC: O(n) # n is word len
    # SC: O(s*n*26) # s is each word, n is len
    def insert(self, word: str) -> None:
        cur = self
        for i in range(len(word)):
            c = word[i]
            idx = ord(c) - ord('a')
            if cur.children[idx] == 0:
                cur.children[idx] = Trie()
            cur = cur.children[idx]
        cur.is_word = True

    def search(self, word: str) -> bool:
        cur = self
        for c in word:
            idx = ord(c) - ord('a')
            if cur.children[idx] == 0:
                return False
            cur = cur.children[idx]
        return True if cur.is_word else False

    def startsWith(self, prefix: str) -> bool:
        cur = self
        for c in prefix:
            idx = ord(c) - ord('a')
            if cur.children[idx] == 0:
                return False
            cur = cur.children[idx]
        return True
```
## 211. Design Add and Search Words Data Structure
Tag: Trie, Hash Map, Array, String
```python
class Trie:
    def __init__(self):
        self.children = {}
        self.is_word = False

class WordDictionary:

    def __init__(self):
        self.node = Trie()
    
    # TC: O(len(w))
    # SC: O(len(w)*w count)
    def addWord(self, word: str) -> None:
        node = self.node
        for w in word:
            if w not in node.children:
                node.children[w] = Trie()
            node = node.children[w]
        node.is_word = True

    # TC: O() all added word characters count
    def search(self, word: str) -> bool:
        return self.search_with_node(word, self.node)

    def search_with_node(self, word: str, node: Trie) -> bool:
        for i in range(len(word)):
            w = word[i]
            if w == '.':
                for v in node.children.values():
                    if self.search_with_node(word[i+1:], v):
                        return True
            if w not in node.children:
                return False
            node = node.children[w]
        return True if node.is_word else False
```

## 336. Palindrome Pairs
Tag: String, Array, Hash Table, Trie
```python

class Solution:
    # TC: O(n*w*w) n len(words), w len(word), prefix = word[:j] O(w), is_palindrome O(w)
    # SC: O(n)
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backwords, res = {}, []
        backwords = {word[::-1]: i for i,word in enumerate(words)}

        for i, word in enumerate(words):
            if word in backwords and i != backwords[word]:
                res.append([i, backwords[word]])
            if word != '' and '' in backwords and word == word[::-1]:
                res.append([i, backwords['']])
                res.append([backwords[''], i])
            for j in range(len(word)):
                if word[:j] in backwords and word[j:] == word[:j-1:-1]:
                    res.append([i, backwords[word[:j]]])
                if word[j:] in backwords and word[:j] == word[j-1::-1]:
                    res.append([backwords[word[j:]], i])
        return res

class Solution:

    def is_palindrome(self, s):
        return s == s[::-1]
    # TC: O(n*w*w) n len(words), w len(word), prefix = word[:j] O(w), is_palindrome O(w)
    # SC: O(n)
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        res = set()
        word_to_idx = {word: i for i, word in enumerate(words)}
        for i, word in enumerate(words):
            for j in range(len(word) + 1):
                prefix = word[:j]
                suffix = word[j:]
                if self.is_palindrome(prefix):
                    reversed_suffix = suffix[::-1]
                    if reversed_suffix in word_to_idx and word_to_idx[reversed_suffix] != i:
                        res.add(f'{word_to_idx[reversed_suffix]},{i}')
                if self.is_palindrome(suffix):
                    reversed_prefix = prefix[::-1]
                    if reversed_prefix in word_to_idx and word_to_idx[reversed_prefix] != i:
                        res.add(f'{i},{word_to_idx[reversed_prefix]}')
        return [[int(part) for part in item.split(',')] for item in list(res)]
```
## 421. Maximum XOR of Two Numbers in an Array
Tag: Trie, Bit Manipulation
```python
class Solution:
    # TC: O(n*31)
    # SC: O(31*2 = 1)
    def findMaximumXOR(self, nums: List[int]) -> int:
        root = Trie()
        self.add(root, nums[0])
        res = 0
        for i in range(1, len(nums), 1):
            res = max(self.check(root, nums[i]), res)
            self.add(root,nums[i])
        return res

    def add(self, node, num):
        N = 30
        for i in range(N, -1, -1):
            cur_bit = num >> i & 1
            if cur_bit == 1:
                if node.left is None:
                    node.left = Trie()
                node = node.left
            else:
                if node.right is None:
                    node.right = Trie()
                node = node.right

    def check(self, node, num):
        N = 30
        x = 0
        for i in range(N, -1, -1):
            cur_bit = num >> i & 1
            if cur_bit == 1:
                if node.right:
                    node = node.right
                    x = x * 2 + 1
                else:
                    node = node.left
                    x = x * 2
            else:
                if node.left:
                    node = node.left
                    x = x * 2 + 1
                else:
                    node = node.right
                    x = x * 2
        return x

class Trie:
    def __init__(self):
        self.left = None
        self.right = None
```
## 212. Word Search II
Tag: Trie, Recursion, DFS
```python
class Solution:
    # TC: O(len(words)*len(word) + m*n*4^len(word))
    # SC: O(len(words)*len(word) + len(word))
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        root = Trie()
        for word in words:
            self.add(root, word)
        m = len(board)
        n = len(board[0])
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]

        res = set()
        def dfs(node, i, j):
            if board[i][j] not in node.children:
                return
            # 记录i，j，设置#，结束后设置回来，去重
            ch = board[i][j]
            nxt = node.children.get(board[i][j])
            if nxt.word is not None:
                res.add(nxt.word)
                # 剪枝
                nxt.word = None
                # 这里不return，也不remove nxt，是因为情况 abc , ab的时候，如果先走了ab，提前剪枝，会导致abc找不到
            board[i][j] = "#"
            for xi, yi in dirs:
                x = i + xi
                y = j + yi
                if 0 <= x < m and 0 <= y < n:
                    dfs(nxt, x, y)
            board[i][j] = ch
            # 该节点没用的时候，剪枝
            if len(nxt.children) == 0:
                node.children.pop(ch, None)

        for i in  range(m):
            for j in range(n):
                dfs(root, i, j)
        return list(res)
    
    def add(self, node, word):
        for w in word:
            if w not in node.children:
                node.children[w] = Trie()
            node = node.children.get(w)
        node.word = word

class Trie:
    def __init__(self):
        self.children = {}
        self.word = None
```

## 648. Replace Words
Tag: Trie, Hash Map, Array, String
```python
class Trie:
    def __init__(self):
        self.children = {}
        self.is_root = False

class Solution:
    # TC: O(dn) d is dict, s is sentence, n is average len of word
    # SC: O(dn)
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        dummy_h = Trie()
        for root in dictionary:
            head = dummy_h
            for k in root:
                if k not in head.children:
                    head.children[k] = Trie()
                head = head.children[k]
            head.is_root = True

        res = []
        words = sentence.split(' ')
        for word in words:
            i = 0
            head = dummy_h
            for k in word:
                if k not in head.children:
                    i = len(word)
                    break
                head = head.children[k]
                i += 1
                if head.is_root:
                    break
            res.append(word[0:i])
        return " ".join(res)
```

## 677. Map Sum Pairs
Tag: Trie, Hash Map
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.total = 0

class MapSum:
    def __init__(self):
        self.map = {}
        self.trienode = TrieNode()
    # TC: O(n) n is key len
    # SC: O(n*k) k is total inserted k
    def insert(self, key: str, val: int) -> None:
        delta = val - self.map.get(key, 0)
        trie = self.trienode
        for k in key:
            if k not in trie.children:
                trie.children[k] = TrieNode()
            trie = trie.children[k]
            trie.total += delta
        self.map[key] = val

    def sum(self, prefix: str) -> int:
        trie = self.trienode
        for k in prefix:
            if k not in trie.children:
                return 0
            trie = trie.children[k]
        return trie.total
```
## ^^N-ary Tree
```python
# Definition for a Node.
class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children
```

## 429. N-ary Tree Level Order Traversal
Tag: N-ary Tree, Recursion
```python
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        res = []
        q = deque()
        if root is not None:
            q.append(root)
        while len(q):
            size = len(q)
            res.append([])
            for _ in range(size):
                node = q.popleft()
                res[-1].append(node.val)
                for c in node.children:
                    q.append(c)
        return res
```
## 559. Maximum Depth of N-ary Tree
Tag: N-ary Tree, Recursion, Dynamic Programming, Top-down, Bottom-up
```python
class Solution:
    # Bottom-up, calculation bottom node first, then up to the root
    # TC: O(n)
    # SC: O(h)
    def maxDepth(self, root: 'Node') -> int:
        if root is None:
            return 0
        return 1 + max((self.maxDepth(c) for c in root.children), default = 0)

class Solution:
    # Top-down
    # TC: O(n)
    # SC: O(h)
    def maxDepth(self, root: 'Node') -> int:
        self.ans = 0
        def dfs(node, depth):
            if node is None:
                return
            self.ans = max(self.ans, depth + 1)
            for c in node.children:
                dfs(c, depth + 1)
        dfs(root, 0)
        return self.ans
```

## 589. N-ary Tree Preorder Traversal
Tag: N-ary Tree, Recursion
```python
class Solution:
    # TC: O(n) # n is total node count
    # SC: O(h) # h is tree height
    def preorder(self, root: 'Node') -> List[int]:
        res = []
        def helper(node):
            if node is None:
                return
            res.append(node.val)
            for c in node.children:
                helper(c)
        helper(root)
        return res
```

## 590. N-ary Tree Postorder Traversal
Tag: N-ary Tree, Recursion
```python
class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        res = []
        def helper(node):
            if node is None:
                return
            for c in node.children:
                helper(c)
            res.append(node.val)
        helper(root)
        return res
```


## ^^Binary Search Tree (BST)
A binary search tree (BST), a special form of a binary tree, satisfies the binary search property:

- The value in each node must be greater than (or equal to) any values stored in its left subtree.
- The value in each node must be less than (or equal to) any values stored in its right subtree.


- Inorder of BST is sorted


## 98. Validate Binary Search Tree
Tag: Binary Search Tree, Recursion

For method 1, the path is all the way up from left below to right above
![image.png](./leetcode.assets/image-20250717002.png)
And if there is right node, it works like this, the root of the right node has already been poped, and the right node is in between of it's left and parent of it's root
![image.png](./leetcode.assets/image-20250717003.png)
If only go right, it push one, pop one, check each node along the way
![image.png](./leetcode.assets/image-20250717004.png)
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    # Along the left nodes direction, all the way to the end
    # and then go up, and right
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        smallest = float('-inf')
        stack = []
        while root is not None or len(stack):
            while root is not None:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if root.val <= smallest:
                return False
            smallest = root.val
            root = root.right
        return True

    # TC: O(n)
    # SC: O(h)
    # The smallest and largest are defined by the nodes along the way to the specific node. That's also the defination of Binary Search Tree. Insert a new node to the left if it's less the root or right if larger than the root
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        return self.helper(root, float('-inf'), float('inf'))
    def helper(self, root, smallest, largest):
        if root is None:
            return True
        if root.val <= smallest or root.val >= largest:
            return False
        return self.helper(root.left, smallest, root.val) and self.helper(root.right, root.val, largest)
```
## 108. Convert Sorted Array to Binary Search Tree
Tag: Binary Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def helper(left, right):
            if left > right:
                return None
            mid = (left + right) // 2
            root = TreeNode(nums[mid])
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root
        return helper(0, len(nums) - 1)
```
## 173. Binary Search Tree Iterator
Tag: Binary Search Tree, Recursion
```python
class BSTIterator:
    # TC: O(n)
    # SC: O(n)
    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        self.root = root

    def next(self) -> int:
        while self.root:
            self.stack.append(self.root)
            self.root = self.root.left
        next = self.stack.pop()
        self.root = next.right
        return next.val

    def hasNext(self) -> bool:
        return self.root is not None or len(self.stack) > 0
```
## 235. Lowest Common Ancestor of a Binary Search Tree
Tag: Binary Search Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root is None:
            return root
        if q.val < root.val and p.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return  root

        # while True:
        #     if q.val < root.val and p.val < root.val:
        #         root = root.left
        #     elif p.val > root.val and q.val > root.val:
        #         root = root.right
        #     else:
        #         return  root

    # TC: O(n)
    # SC: O(h)
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root is None or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left is not None and right is not None:
            return root
        return left if left is not None else right
```

## 450. Delete Node in a BST
Tag: Binary Search Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if root is None:
            return root
        if key < root.val:
            root.left = self.deleteNode(root.left, key)
        elif key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            if root.left is None:
                return root.right
            if root.right is None:
                return root.left
            node = self.get_successor(root.right)
            root.val = node.val
            root.right = self.deleteNode(root.right, node.val)
        return root

    def get_successor(self, root):
        while root.left:
            root = root.left
        return root
```

## 700. Search in a Binary Search Tree
Tag: Binary Search Tree, Recursion
```python
# TC: O(logn) n is the total nodes, normally balance tree. O(n) the worst case
# SC: O(logn). O(n) the worst case
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root == None:
            return None
        
        if root.val == val:
            return root
        elif root.val < val:
            return self.searchBST(root.right, val)
        else:
            return self.searchBST(root.left, val)
```
## 701. Insert into a Binary Search Tree
Tag: BST, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root is None:
            return TreeNode(val)
        if root.val > val:
                root.left = self.insertIntoBST(root.left,val)
        else:
                root.right = self.insertIntoBST(root.right, val)
        return root

    # TC: O(n)
    # SC: O(1)
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root is None:
            return TreeNode(val)
        parent = None
        cur = root
        while cur is not None:
            parent = cur
            if cur.val > val:
                cur = cur.left
            else:
                cur = cur.right
        node = TreeNode(val)
        if parent.val > val:
            parent.left = node
        else:
            parent.right = node
        return root
```
## 703. Kth Largest Element in a Stream
Tag: Binary Search Tree, Recursion, Heap
```python
class KthLargest:
    # TC: O(n) heapify, O(logn) push pop
    # SC: O(k)
    def __init__(self, k: int, nums: List[int]):
        # TC: O(n) heapify On
        heapq.heapify(nums)
        self.k = k
        self.minheap = nums
        while len(self.minheap) > k:
            heapq.heappop(self.minheap)
        
    def add(self, val: int) -> int:
        if len(self.minheap) < self.k:
            heapq.heappush(self.minheap, val)
        else:
            heapq.heappushpop(self.minheap, val)
        return self.minheap[0]

    # 使用二叉树，思路见 https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/142/conclusion/1009/
    # 当构成平衡二叉树的时候才可以，不平衡的时候会树结构不好，会超时
#     def __init__(self, k: int, nums: List[int]):
#         self.root = None
#         self.k = k
#         for i in range(len(nums)):
#             self.root=self.insert(self.root, nums[i])

#     def add(self, val: int) -> int:
#         self.root = self.insert(self.root, val)
#         return self.find(self.root, self.k)

#     def find(self, head, k):
#         right_count = head.right.count if head.right is not None else 0
#         total_right_count = right_count + head.weight
#         if right_count < k <= total_right_count:
#             return head.val
#         elif k > total_right_count:
#             return self.find(head.left, k-total_right_count)
#         else:
#             return self.find(head.right, k)

#     def insert(self, head, val):
#         if head is None:
#             return Node(val)
#         head.count += 1
#         if val < head.val:
#             head.left = self.insert(head.left,val)
#         elif val > head.val:
#             head.right = self.insert(head.right,val)
#         else:
#             head.weight += 1
#         return head


# class Node:
#     def __init__(self, val:int, count:int=1,weight:int=1,left:'Node'=None,right:'Node'=None):
#         self.val = val
#         self.count = count
#         self.weight = weight
#         self.left = left
#         self.right = right
```

# TreeSet

```java
// 从小到大排序的

// 1. create treeset
TreeSet<Integer> treeSet = new TreeSet<>();
// 2. add element
treeset.add(5);
// 3. remove element
treeset.remove(5);
// 4. size
treeset.size();
// 5. query
treeset.contains(5);
// 6. query first
treeset.first();
// 7. query last
treeset.last();
// 8. equal or larget given element
treeset.ceiling(3); // 5
treeset.higher(4); // only larger
// 9. equal or smaller than given element
treeset.floor(5); // 5
treeset.lower(5); // only smaller
// 10. delete first
treeset.pollFirst();
// 11. delete last
treeset.pollLast();
```





# Queue

**FIFO**

the first element added to the queue will be processed first

![image-20241106104525767](./leetcode.assets/image-20241106104525767.png)

**Enqueue**

Add at the end of the queue

**Dequeue**

Remove the first element

```python
from collections import deque
# deque is a two ends queue
# 1. Initialize
q = deque()

# 2. Add element (append at right)
q.append(1)
q.append(2)

q.appendleft(2)

# 3. Add and remove from left
q.popleft() # Queue, FIFO

# 4. Pop elemnt (remove from right)
q.pop() # Stack, FILO

# 5. Lenght
len(q)

# 6. Queue is empty
not q

# 7. Rotate n times
q.rotate(n)

# 8. Clear
q.clear()

# 9. Extend queue
q.extend([4,5])
q.extendleft([4,5])

# 10. Set size of queue
dq = deque(maxlen=3) # 最多保留3个元素，超出会自动从另一端(左边)弹出
```

```java
public class Main {
    public static void main(String[] args) {
        // 1. Initialize a queue.
        Queue<Integer> q = new LinkedList();
        // 2. Get the first element - return null if queue is empty.
        System.out.println("The first element is: " + q.peek());
        // 3. Push new element.
        q.offer(5);
        q.offer(13);
        q.offer(8);
        q.offer(6);
        // 4. Pop an element.
        q.poll();
        // 5. Get the first element.
        System.out.println("The first element is: " + q.peek());
        // 7. Get the size of the queue.
        System.out.println("The size is: " + q.size());
    }
}
```

## BSF
```java
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue<Node> queue;  // store all nodes which are waiting to be processed
    int step = 0;       // number of steps needed from root to current node
    // initialize
    add root to queue;
    // BFS
    while (queue is not empty) {
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                add next to queue;
            }
            remove the first node from queue;
        }
        step = step + 1;
    }
    return -1;          // there is no path from root to target
}
```


## Deque or LinkedList

```java
LinkedList<Integer> deque = new LinkedList<>();
// 1. add first
deque.addFirst(10); // [10]
// 2. add to last
deque.addLast(20);  // [10, 20]
// 3. remove first
deque.removeFirst();
// 4. remove last
deque.removeLast();
```

## 200. Number of Islands
Tag: BFS, Matrix, Array
```python
    def numIslands(self, grid: List[List[str]]) -> int:
        q = deque()
        islands = 0
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]

        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    q.append([i,j])
                    islands+=1
                while len(q):
                    size = len(q)
                    for _ in range(size):
                        node = q.popleft()
                        for dir in dirs:
                            x = dir[0] + node[0] 
                            y = dir[1] + node[1]
                            if x >= 0 and x < len(grid) and y >= 0 and y < len(grid[0]) and grid[x][y] == '1':
                                grid[x][y] = '0'
                                q.append([x,y])
        return islands
```

## 279. Perfect Squares
Tag: Queue, Math
```python
class Solution:
    # TC: O(n logn)
    # SC: O(n)
    def numSquares(self, n: int) -> int:
        squares = [i**2 for i in range(1,n+1,1)]
        visited = set()
        step = 0
        q = deque()
        q.append(n)
        while len(q):
            size = len(q)
            step += 1
            for _ in range(size):
                cur = q.popleft()
                for square in squares:
                    reminder = cur - square
                    if reminder == 0:
                        return step
                    if reminder < 0:
                        break
                    if reminder not in visited:
                        q.append(reminder)
                        visited.add(reminder)
        return -1
```

## 542. 01 Matrix 
Tag: Queue, Matrix
```python
class Solution:
    # TC: O(m x n)
    # SC: O(1)
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])
        res = [[float('inf')] * n for _ in range(m) ]
        q = deque()
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    q.append([i, j])
                else:
                    mat[i][j] = -1
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]
        while len(q):
            size = len(q)
            for _ in range(size):
                node = q.popleft()
                for i,j in dirs:
                    x = node[0] + i
                    y = node[1] + j
                    if 0 <= x < m and 0 <= y < n and mat[x][y] == -1:
                        mat[x][y] = mat[node[0]][node[1]] + 1
                        q.append([x,y])
        return mat

# DFS timeout， 太多重复的地方，剪枝不够
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])
        res = [[float('inf')] * n for _ in range(m) ]
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    res[i][j] = 0
                    self.dfs(mat,i ,j, res)
        return res

    def dfs(self, mat, r, c, res):
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]
        for dx, dy in dirs:
            x = r + dx
            y = c + dy
            if x >= 0 and x < len(mat) and y >= 0 and y < len(mat[0]) and res[x][y] > res[r][c] + 1:
                res[x][y] = res[r][c] + 1
                self.dfs(mat, x, y, res)
```

## 622. Design Circular Queue
Tag: Queue
```java
class MyCircularQueue {
    private int[] queue;
    private int size;
    private int front;
    private int rear;
    public MyCircularQueue(int k) {
        queue = new int[k+1];
        size=k+1;
        front=0;
        rear=0;
    }
    
    public boolean enQueue(int value) {
        if(isFull()){
            return false;
        }
        queue[rear] = value;
        rear = (rear+1)%size;
        return true;
    }
    
    public boolean deQueue() {
        if(isEmpty()){
            return false;
        }
        front = (front+1)%size;
        return true;
    }
    
    public int Rear() {
        if(isEmpty()){
            return -1;
        }
        return queue[(rear-1+size)%size];
    }
    
    public int Front() {
        if(isEmpty()){
            return -1;
        }
        return queue[front];
    }
    
    public boolean isEmpty() {
        return front==rear;
    }
    
    public boolean isFull() {
        return (rear+1)%size==front;
    }
}
```

## 841. Keys and Rooms
Tag: Queue
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        q = deque()
        n = len(rooms)
        res = [False] * n
        q.append(0)

        while len(q):
            key = q.popleft()
            res[key] = True
            for k in rooms[key]:
                if not res[k]:
                    q.append(k)
        return all(res)
```

# Stack

**LIFO**

the newest element added to the queue will be processed first

**Add**

added at the end of the stack

**Remove**

remove the last element

```python
# 1. Initialize stack
stack = []

# 2. Append element
stack.append(1)
stack.append(2)

# 3. Pop element, return the poped item
value = stack.pop()

# 4. Peek element
top = stack[-1]

# 5. Length and empty
len(stack)

# 6. Search element
len(stack) -1 - stack.index(value)

```


```java
// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        // 1. Initialize a stack.
        Stack<Integer> s = new Stack<>();
        // 2. Push new element.
        s.push(5);
        s.push(13);
        s.push(8);
        s.push(6);
        // 3. Check if stack is empty.
        if (s.empty() == true) {
            System.out.println("Stack is empty!");
            return;
        }
        // 4. Pop an element.
        s.pop();
        // 5. Get the top element.
        System.out.println("The top element is: " + s.peek());
        // 6. Get the size of the stack.
        System.out.println("The size is: " + s.size());
        // 7. Search the element position in stack from head, from 1
        stack.search("Cherry");
    }
}
```



## DSF

```java
/*
 * Return true if there is a path from cur to target.
 * Using system call stack
 */
boolean DFS(Node cur, Node target, Set<Node> visited) {
    return true if cur is target;
    for (next : each neighbor of cur) {
        if (next is not in visited) {
            add next to visited;
            return true if DFS(next, target, visited) == true;
        }
    }
    return false;
}


/*
 * Return true if there is a path from cur to target.
 * DFS using an explicit stack
 */
boolean DFS(int root, int target) {
    Set<Node> visited;
    Stack<Node> stack;
    add root to visited;
    add root to stack;
    while (stack is not empty) {
        Node cur = the top element in stack;
        remove the cur from the stack;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to visited;
                add next to stack;
            }
        }
    }
    return false;
}
```
## 20. Valid Parentheses
Tag: Stack
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def isValid(self, s: str) -> bool:
        stack = []
        d = {
            "(": ")",
            "[": "]",
            "{": "}",
        }
        for char in s:
            if char in d:
                stack.append(char)
            elif len(stack) == 0:
                return False
            elif d.get(stack[-1]) == char:
                stack.pop()
            else:
                return False
        return True if len(stack) == 0 else False
```
## 84. Largest Rectangle in Histogram
Tag: Stack, Array, Monotonic Stack
```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        left, right = [0] * n, [n] * n
        mono_stack = []
        for i in range(n):
            while len(mono_stack) and heights[i] < heights[mono_stack[-1]]:
                right[mono_stack[-1]] = i
                mono_stack.pop()
            left[i] = (mono_stack[-1] +1) if len(mono_stack) else 0
            mono_stack.append(i)
        res = max( ((right[i] - left[i])) * heights[i] for i in range(n) )
        return res
    # TC: O(n)
    # SC: O(n)
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        n = len(heights)
        res = 0
        stack.append((0, -1))
        for i in range(n):
            height = heights[i]
            left_idx = i
            while height < stack[-1][0]:
                top_value, left_idx  = stack.pop()
                res = max(res, top_value * (i-left_idx))
            stack.append((height, left_idx))
        while len(stack) > 0:
            top_value, left_idx  = stack.pop()
            res = max(res, top_value * (n-left_idx))
        return res
        
```
## 133. Clone Graph
Tag: DFS, Node
```python
from typing import Optional
class Solution:
    # TC: O(n*m)  n is node number, m is the most edge in nodes
    # SC: O(1)
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        d = [0]*101
        
        return self.dfs(node, d)
    
    def dfs(self, node:  Optional['Node'], d: list['Node']) -> Optional['Node']:
        if node is None:
            return node
        
        if d[node.val]:
            return d[node.val]

        cp_node = Node(node.val)
        d[cp_node.val] = cp_node
        for neighbor in node.neighbors:
            cp_node.neighbors.append(self.dfs(neighbor, d))
        return cp_node

    # use dict
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        d = {}
        
        return self.dfs(node, d)
    
    def dfs(self, node:  Optional['Node'], d: dict[int, str]) -> Optional['Node']:
        if node is None:
            return node
        
        if d.get(node.val):
            return d.get(node.val)

        cp_node = Node(node.val)
        d[cp_node.val] = cp_node
        for neighbor in node.neighbors:
            cp_node.neighbors.append(self.dfs(neighbor, d))
        return cp_node
```

## 150. Evaluate Reverse Polish Notation
Tag: Stack, Math
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        s = ['+', '-', '*', '/']
        for ele in tokens:
            if ele not in s:
                stack.append(int(ele))
            else:
                var2 = stack.pop()
                var1 = stack.pop()
                if ele == '+':
                    stack.append(var1 + var2)
                elif ele == '-':
                    stack.append(var1 - var2)
                elif ele == '*':
                    stack.append(var1 * var2)
                elif ele == '/':
                    stack.append(int(var1 / var2))
        return stack[-1]
```

## 155. Min Stack
Tag: Stack, Node
```python
class MinStack:
    # TC: O(1)
    # SC: O(1) if output does not count as space consume
    def __init__(self):
        self.head=None

    def push(self, val: int) -> None:
        if self.head == None:
            self.head = Node(val, None, val)
        else:
            self.head = Node(val, self.head, min(val, self.head.min))

    def pop(self) -> None:
        self.head = self.head.next

    def top(self) -> int:
        return self.head.val

    def getMin(self) -> int:
        return self.head.min


class Node:
    def __init__(self, val: int, next: 'Node', min: int):
        self.val = val
        self.next = next
        self.min = min
```

## 200. Number of Islands
Tag: DFS, Matrix, Array
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        islands = 0
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    self.dfs(grid, i, j, dirs)
                    islands+=1
        return islands

    def dfs(self, grid: List[List[str]], i:int, j:int, dirs: List[List[int]]) -> None:
        grid[i][j] = '0'
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):
            return
        for dir in dirs:
            x = dir[0] + i
            y = dir[1] + j
            if x >= 0 and x < len(grid) and y >= 0 and y < len(grid[0]) and grid[x][y] == '1':
                self.dfs(grid, x, y, dirs)
```

## 225. Implement Stack using Queues
Tag: Stack, Queue
```python
class MyStack:

    def __init__(self):
        self.q = deque()    
    # TC: O(n)
    # SC: O(1)
    def push(self, x: int) -> None:
        self.q.append(x)
        for i in range(1, len(self.q), 1):
            self.q.append(self.q.popleft())

    def pop(self) -> int:
        return self.q.popleft()

    def top(self) -> int:
        return self.q[0] if not self.empty() else None 

    def empty(self) -> bool:
        return False if len(self.q) else True
```

## 232. Implement Queue using Stacks
Tag: Queue, Stack
```python
class MyQueue:
    # SC: O(n)
    def __init__(self):
        self.s1 = []
        self.s2 = []
        self.front = None

    # TC: O(1)
    def push(self, x: int) -> None:
        if len(self.s1) == 0:
            self.front = x
        self.s1.append(x)

    # TC: O(n)
    def pop(self) -> int:
        if len(self.s2) == 0:
            while len(self.s1):
                self.s2.append(self.s1.pop())
        return self.s2.pop()    

    # TC: O(1)
    def peek(self) -> int:
        if len(self.s2):
            return self.s2[-1]
        return self.front

    # TC: O(1)
    def empty(self) -> bool:
        return len(self.s1) == 0 and len(self.s2) == 0


class MyQueue:
    # SC: O(n) or O(1) if temp space does not count as complexity
    def __init__(self):
        self.s1 = []
        self.s2 = []

    # TC: O(n)
    def push(self, x: int) -> None:
        while len(self.s1):
            self.s2.append(self.s1.pop())
        self.s2.append(x)
        while len(self.s2):
            self.s1.append(self.s2.pop())

    # TC: O(1)
    def pop(self) -> int:
        return self.s1.pop()        

    # TC: O(1)
    def peek(self) -> int:
        return self.s1[-1]

    # TC: O(1)
    def empty(self) -> bool:
        return len(self.s1) == 0 and len(self.s2) == 0
```

## 394. Decode String
Tag: Stack, String

![image-20250708145453405](./leetcode.assets/image-20250708145453405.png)

```python
class Solution:
    # TC: O(n)  2n -> n
    # SC: O(n)
    def decodeString(self, s: str) -> str:
        stack = []
        for ele in s:
            if ele != ']':
                stack.append(ele)
            else:
                temp = ''
                while stack[-1] != '[':
                    temp = stack.pop() + temp
                stack.pop()
                times = ''
                while len(stack) and len(stack[-1]) == 1 and ord('0') <= ord(stack[-1]) <= ord('9'):
                    times = stack.pop() + times 
                multi_temp = ''
                for i in range(int(times)):
                    multi_temp += temp
                stack.append(multi_temp)
        res = ''
        while len(stack):
            res = stack.pop() + res
        return res
```

```java
class Solution {
    
    StringBuilder sb = new StringBuilder();
    
    public String decodeString(String s) {
        Queue<Character> queue = new LinkedList<>();
        for(char c: s.toCharArray()) queue.offer(c);
        return helper(queue);
    }

    String helper(Queue<Character> queue){
        StringBuilder sb = new StringBuilder();
        int num = 0;
        while(!queue.isEmpty()){
            char c = queue.poll();
            if(Character.isDigit(c)){
                num = num * 10 + c - '0';
            }else if(c == '['){
                String str = helper(queue);
                for(int i = 0; i < num; i++) sb.append(str);
                num = 0;
            }else if(c == ']'){
                break;
            }else{
                sb.append(c);
            }
        }
        return sb.toString();
    }
}
```

## 733. Flood Fill
Tag: Matrix, DFS
```python
class Solution:
    # TC: O(m x n)
    # SC: O(m x n) 1. stack, 2. visited
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        target = image[sr][sc]
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]
        m = len(image)
        n = len(image[0])
        visited = []
        for _ in range(m):
            visited.append([False] * n)
        
        self.dfs(image, sr,sc, target, dirs, color,visited)
        return image

    def dfs(self, image, sr, sc, target, dirs, color,visited):
        visited[sr][sc] = True
        image[sr][sc] = color

        for dir in dirs:
            r = sr + dir[0]
            c = sc + dir[1]
            if r >= 0 and r < len(image) and c >= 0 and c < len(image[0]) and not visited[r][c] and image[r][c] == target:
                self.dfs(image, r,c,target,dirs,color, visited)
```

## 739. Daily Temperatures
Tag: Stack
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        # From front to end
        stack = []
        n = len(temperatures)
        result = [0]*n
        for i in range(n):
            while len(stack) and temperatures[i] > temperatures[stack[-1]]:
                index = stack.pop()
                result[index] = i  - index
            stack.append(i)
        return result

        # # From back to front
        # stack = []
        # n = len(temperatures)
        # result = [0]*n
        # for i in range(n-1, -1, -1):
        #     while len(stack) and temperatures[stack[-1]] <= temperatures[i]:
        #         index = stack.pop()
        #     result[i] = stack[-1] - i if len(stack) else 0 
        #     stack.append(i)

        # return result
```

# Binary Search

Basic, check whether target in nums, O(logn)

```java
int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length - 1;
  while(left <= right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid - 1; }
  }

  // End Condition: left > right
  return -1;
}
```

Advanced, check the largest index that smaller than target, or smallest index that larger than target

``` java
int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length - 1;
  while(left < right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; } // or no this
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid; }
  }

  // Post-processing:
  // End Condition: left == right
  if(nums[left] == target) return left;
  return -1;
}
```



```java
int binarySearch(int[] nums, int target) {
    if (nums == null || nums.length == 0)
        return -1;

    int left = 0, right = nums.length - 1;
    while (left + 1 < right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    // Post-processing:
    // End Condition: left + 1 == right
    if(nums[left] == target) return left;
    if(nums[right] == target) return right;
    return -1;
}
```

## 4. Median of Two Sorted Arrays
Tag: Binary Search, Array
```python
# TC: O(log(m + n))
# SC: O(1)
'''
a0, a1, a2, a3, a4, | a5, a6, a7, a8
b0, b1, b2, b3, b4, | b5, b6, b7, b8, b9

nums1_upper_bound = (0 + m) // 2, find the upper bound of nums1
total_left = m + ((n - m + 1) // 2)
    we want the total left elements equal to or larger 1 than total right elements, so we add 1 here
nums2_mid_lower_bound = total_left - nums1_upper_bound - 1
nums2_upper_bound = total_left - nums1_upper_bound

We want to find the nums2 lower bound value's upper bound, so we use BS upper bound search, where b4 as the target value. That's the nums1[mid] >= nums2[total_left - mid - 1] equal equation mean.

i = l
j = total_left - i
There two are all upper bound index
'''
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1
        m = len(nums1) # short
        n = len(nums2) # long
        l, r = 0, m
        # After split two arrays, total left elements are equal to or more than 1 to the totall right elements 
        total_left = m + ((n - m + 1) // 2)
        while l < r:
            mid = (l + r) // 2
            # The equal maintains the upper bound restriction
            if nums1[mid] >= nums2[total_left - mid - 1]:
                r = mid
            else:
                l = mid + 1
        i = l
        j = total_left - i

        i_small = float('-inf') if i == 0 else nums1[i-1] 
        i_large = float('inf') if i == m else nums1[i] 
        j_small = float('-inf') if j == 0 else nums2[j-1] 
        j_large = float('inf') if j == n else nums2[j] 
        # Find the middle two values' median
        if (m+n) % 2 == 0:
            return (max(i_small, j_small) + min(i_large, j_large)) / 2
        # Find the largest among two smallest values
        else:
            return max(i_small, j_small)
        
        
```

## 33. Search in Rotated Sorted Array
Tag: Binary Search
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # TC: O(logn)
        # SC: O(1)
        # find rotate point
        left = 0
        right = len(nums) -1
        if nums[left] > nums[right]:
            while left < right:
                mid = left + (right - left) // 2
                if nums[mid] >= nums[0]:
                    left = mid + 1
                elif nums[mid] < nums[0]:
                    right = mid
        start = left
        left = 0
        right = len(nums) - 1
        if start != 0:
            if target >= nums[left]:
                right = start - 1
            elif target < nums[left]:
                left = start

        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
```

## 34. Find First and Last Position of Element in Sorted Array
Tag: Binary Search
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        if n == 0:
            return [-1,-1]
        # Upper bound
        left = 0
        right = n
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid
        upper = left
        # Lower bound
        left = 0
        right = n - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] >= target:
                right = mid
            else:
                left = mid + 1
        lower = left
        if nums[lower] != target:
            return [-1,-1]
        return [lower, upper-1]
```

## 69. Sqrt(x)
Tag: Binary Search
```python
class Solution:
    # TC: O(logx)
    # SC: O(1)
    def mySqrt(self, x: int) -> int:
        # upper bound
        left = 0
        right = x+1
        while left < right:
            mid = left + (right - left) // 2
            if mid ** 2 == x:
                return mid
            elif mid ** 2 < x:
                left = mid + 1
            else:
                right = mid
        return left - 1
```

## 153. Find Minimum in Rotated Sorted Array
Tag: Binary Search
```python
    # TC: O(logn)
    # SC: O(1)
    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            elif nums[mid] < nums[right]:
                right = mid
        return nums[left]


    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        if nums[left] < nums[right]:
            return nums[left]
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] >= nums[0]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

## 154. Find Minimum in Rotated Sorted Array II
Tag: Binary Search
```python
class Solution:
    # TC: O(n)
    # SC: O(1)
    def findMin(self, nums: List[int]) -> int:
        n = len(nums)
        left = 0
        right = n - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            elif nums[mid] < nums[right]:
                right = mid
            else:
                right -= 1

        return nums[left]
```
## 162. Find Peak Element
Tag: Binary Search
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def findPeakElement(self, nums: List[int]) -> int:
        left = 0
        n = len(nums)
        right = n - 1
        def get(i):
            if i == -1 or i == n:
                return float('-inf')
            return nums[i]
        while left <= right :
            mid = left + (right - left) // 2
            if get(mid - 1) < get(mid) > get(mid + 1):
                return mid
            if get(mid) < get(mid+1):
                left = mid + 1
            else:
                right = mid - 1
        return left
```

## 278. First Bad Version
Tag: Binary Search
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def firstBadVersion(self, n: int) -> int:
        left = 0
        right = n
        while left < right:
            mid = left + (right - left) // 2
            if isBadVersion(mid):
                right = mid
            else:
                left = mid + 1
        return left
```

## 367. Valid Perfect Square
Tag: Binary Search
```python
class Solution:
    # TC: O(log num)
    # SC: O(1)
    def isPerfectSquare(self, num: int) -> bool:
        left = 0
        right = num
        while left <= right:
            mid = left + (right - left) // 2
            v = mid * mid
            if v == num:
                return True
            elif v < num:
                left = mid + 1
            else:
                right = mid - 1
        return False if left * left != num else True
```

## 374. Guess Number Higher or Lower
Tag: Binary Search
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def guessNumber(self, n: int) -> int:
        left = 1
        right = n
        while left <= right:
            mid = left + (right - left) // 2
            v = guess(mid)
            if v == -1:
                right = mid - 1
            elif v == 1:
                left = mid + 1
            else:
                return mid
        return 0
```

## 410. Split Array Largest Sum
Tag: Binary Search, Array 
```python
class Solution:
    # TC: O(n logD) D is max to sum nums
    # SC: O(1)
    '''
        1. 分割k份后，最小的和一定大于数组中最大的值，确定left
        2. sum为right
        3. 算出mid，为答案最大的和 mid，所以在is_larger中，每份的分数组的和必须 小于等于 mid
        4. 其中，总份儿数小于 mid，说明每份的和加起来太大了，最后不够分了，mid应该缩小，right = mid
        5. 总分数等于mid，则可能是正确答案，需要进一步收缩left right
    '''
    def splitArray(self, nums: List[int], k: int) -> int:
        # The smallest largest sum is the largest value in the array
        l = max(nums)
        r = sum(nums)

        while l < r:
            mid = (l+r) //2
            # The rightmost
            if self.is_larger(nums, mid, k):
                r = mid
            else:
                l = mid+1
        return l

    # Every sums must be smaller than the mid
    def is_larger(self, nums, mid, k):
        sums = 0
        # After compute valid sums, the last part has been left, so add 1 to the cnt
        cnt = 1
        for ele in nums:
            if sums + ele <= mid:
                sums+=ele
            else:
                sums = ele
                cnt += 1
        if cnt <= k:
            return True
        else:
            return False
```

## 658. Find K Closest Elements
Tag: Binary Search, Two Pointers
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        left, right = 0, len(arr) - k
        while left<right:
            mid = left + (right - left) // 2
            if x - arr[mid] <= arr[mid + k] - x:
                right = mid
            else:
                left = mid + 1
        return arr[left: left + k]

    # TC: O(logn + k)
    # SC: O(1)
    # Binary search and two pointer
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        # Lower bound
        left = 0
        right = len(arr) - 1
        while left < right:
            mid = left + (right - left) // 2
            if arr[mid] < x:
                left = mid + 1
            else:
                right = mid
        m = None
        if left > 0 and abs(arr[left - 1] - x) <= abs(arr[left] - x):
            m = left - 1
        else:
            m = left
        l = m
        r = m

        while k > 1:
            k -= 1
            if l == 0:
                r += 1
                continue
            if r == len(arr)-1:
                l -= 1
                continue
            if abs(arr[l - 1] - x) <= abs(arr[r + 1] - x):
                l -= 1
            else:
                r += 1
        return arr[l: r+1]
            
```

## 704. Binary Search
Tag: Binary Search, Array
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def search(self, nums: List[int], target: int) -> int:
        start = 0
        end = len(nums) -1
        while start <= end:
            mid = ( start + end ) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                end = mid -  1
            else:
                start = mid + 1
        return -1

    # Find upper bound to insert the target. The upper bound is the least value greater than target
    # Find lower bound to insert the target. The lower bound is the largest value greater than or equal to the target

    # The bound is where to insert the target to make the array keep sorted.
    # And when insert for example to index 2, it means the target now is inserted to index 2, and rest value from index 2, move right 1 position
    
    # [-1,2,2,2,2,12] target 2
    #             ^
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid
        # Now left == right and is at the upper bound index
        # If upper bound is at 0, it means the target is smaller than the smallest value in the array
        if  left > 0 and nums[left -1] == target:
            return left - 1
        return -1
        
    # The lower bound of insertion
    # [-1,2,2,2,2,12] target 2
    #     ^
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        if left < len(nums) and nums[left] == target:
            return left
        return -1
```

## 719. Find K-th Smallest Pair Distance
Tag: Binary Search, Array, Two Pointers
```python
class Solution:
    # TC: O(nlogn + nlogD) nlogn is nums.sort, nlogD: D is max nums value - min nums value. BS logD, inside it is O(n), so nlogD
    # SC: O(nlogn)

    '''
        1. 先排序
        2. 元素之间的距离，最小为0，最大为首尾两项的差
        3. 我们通过二分查找，计算距离为mid的时候，一共有多少组元素小于等于它，那么mid就是第几个元素
        4. 收缩l r
            4.1 使用条件 cnt <= k
                当cnt大于k的时候，当前mid仍有可能是答案，比如当前距离mid有很多组，这些组加起来刚好超过k了，但距离mid仍是答案，所以使用r = mid保留mid，所以不是r = mid - 1
                    比如 1,2,3,4,5,6,7,100. k=4. 这里距离为1的很多，比如mid为1的时候，cnt统计出来为6，虽然它大于4，但是距离mid仍需要保留。等待进一步二分缩小即可
                当cnt == k时，当前距离mid很有可能并没有在任何数组对中
                    比如 1,100,500. k=2. 第一次的时候mid=250，虽然计算出来的cnt是1（1，100）.但是距离250不是任何数组对的距离。所以需要进一步缩小，而不要提前返回。即cnt==k的时候，仍继续所以 l 和 r
    '''
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        n = len(nums)
        nums.sort()
        l = 0
        r = nums[n-1]
        while l < r:
            mid = (l + r) // 2
            cnt = 0
            i = 0
            for j in range(n):
                while nums[j] - nums[i] > mid:
                    i += 1
                cnt += j - i
            if cnt >= k:
                r = mid
            else:
                l = mid + 1
        return l
```

## 744. Find Smallest Letter Greater Than Target
Tag: Binary Search
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        n = len(letters)
        target_v = ord(target)
        if ord(letters[0]) >target_v or ord(letters[n-1]) <= target_v:
            return letters[0]
        
        # Upper bound
        left = 1
        right = n-1
        while left < right:
            mid = left + (right - left) // 2
            if ord(letters[mid]) <= target_v:
                left = mid + 1
            else:
                right = mid
        return letters[left]
```

## 1051. Height Checker
Tag: Array, Sort
![image-20230614225500049](leetcode.assets/image-20230614225500049.png)

```python
# TC: O(max(sort, n))
# SC: O(n)
class Solution(object):
    def heightChecker(self, heights):
        """
        :type heights: List[int]
        :rtype: int
        """
        original_height = [ele for ele in heights]
        heights.sort()
        res = 0
        for i in range(len(heights)):
            if original_height[i] != heights[i]:
                res += 1
        return res
```

先sort，再比较

```
class Solution {
    public int heightChecker(int[] heights) {
                int[] originHeights = heights.clone();
        Arrays.sort(originHeights);
        int diffNum = 0;
        for (int i = 0; i < heights.length; i++) {
            if(heights[i] != originHeights[i]){
                diffNum++;
            }
        }
        return diffNum;
    }
}
```



# Sorting 排序算法

## 快排 QuickSort

**Partition**

Find the kth most element

1. 获取元素。如果是对本身大小比较，不用多余操作。如果是freq等相关联的判断，则通过hashmap 存储值和它对应的大小（freq等）
2. 选定left，right，和中间的一个随机元素（random.nextInt），开始partition
3. 将pivot index与right交换
4. 从left到right -1 遍历，使用双指针，一个指向下一个小于pivot元素该放置的位置storeIndex，一个遍历i
5. 小于pivot（freq）的移动到storeIndex，++
6. 知道i到right-1
7. right与storeIndex交换
8. 实现了storeIndex 也就是 pivot元素左边（到left）比它小，右边（到right）比它大
9. 此时storeIndex位置为n-k最大的位置

```java

int partition(int left, int right){
	Random random = new Random();
    int pivot_index = random.nextInt(right - left + 1) + left;
    
    // Optional: int value = hashmap.get(pivot_index);
    swap(nums, pivot_index, right);
    int storeIndex = left;
    for(int i = left; i < right; i++){
        if(hashmap.get(nums[i]) < value){
            swap(i, storeIndex);
            storeIndex ++;
        }
    }
    
    swap(right, storeIndex);
    return storeIndex;
}
```

## 912. Sort an Array

## Merge Sort
```python
class Solution:
    # Top down
    # 假如有8个数字，先分成4个4个合并，然后分成2个2个合并，然后分成1个1个合并
    # TC: O(n logn)
    def sortArray(self, nums: List[int]) -> List[int]:
        # Merge sort
        n = len(nums)
        if n <= 1:
            return nums
        mid = n // 2
        merged_left = self.sortArray(nums[0: mid])
        merged_right = self.sortArray(nums[mid: n])
        return self.merge(merged_left, merged_right)

    def merge(self, nums1, nums2):
        m = len(nums1)
        n = len(nums2)
        p = 0
        q = 0
        res = []
        while p<m and q<n:
            if nums1[p] < nums2[q]:
                res.append(nums1[p])
                p += 1
            else:
                res.append(nums2[q])
                q+=1
        while p < m:
            res.append(nums1[p])
            p+=1
        while q < n:
            res.append(nums2[q])
            q+=1
        return res
    # Bottom up
    # 把每个数字看成一份，先1个1个合并，然后2个2个合并，然后4个4个合并
    class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        # Merge sort
        width = 1
        n = len(nums)
        while width < n:
            for i in range(0, n, width * 2):
                mid = i + width
                nums1 = nums[i: i + width]
                nums2 = nums[i+ width: i + width * 2]
                merged = self.merge(nums1, nums2)
                nums[i: i+len(merged)] = merged
            width *= 2
        return nums

    def merge(self, nums1, nums2):
        m = len(nums1)
        n = len(nums2)
        p = 0
        q = 0
        res = []
        while p<m and q<n:
            if nums1[p] < nums2[q]:
                res.append(nums1[p])
                p += 1
            else:
                res.append(nums2[q])
                q+=1
        while p < m:
            res.append(nums1[p])
            p+=1
        while q < n:
            res.append(nums2[q])
            q+=1
        return res

    # Quick sort
    def sortArray(self, nums: List[int]) -> List[int]:
        # Quick sort
        self.qsort(nums, 0, len(nums) - 1)
        
    
    def qsort(self, nums, lo, hi):
        if lo < hi:
            pivot = self.partition(nums, lo, hi)
            self.qsort(nums, lo, pivot - 1)
            self.qsort(nums, pivot + 1, hi)
    
    def partition(self, nums, lo, hi):
        idx = random.randint(lo, hi)
        nums[idx], nums[hi] = nums[hi], nums[idx]
        target = nums[hi]
        i = lo
        for j in range(lo, hi):
            if nums[j] < target:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        nums[i], nums[hi] = nums[hi], nums[i]
        return i
```

### ?couting sort？


# Bit manupulation (python)

```python

# 二进制（0b 开头），值是 5
print(0b101)  # 输出: 5

# Java 中的 0e1011 是科学计数法（0 * 10^1011 = 0.0）
# Python 中类似写法为：
print(0e1011)  # 输出: 0.0

# 八进制（0o 开头），011 在 Java 是八进制 11，即十进制 9
print(0o11)  # 输出: 9

# 十进制
print(11)  # 输出: 11

# 十六进制（0x 开头），0x11C 是十进制 284
print(0x11C)  # 输出: 284

# 格式化为 10 位宽度的十六进制，小写，左侧补 0
print("{:010x}".format(7))  # 输出: 0000000007

# 格式化为 10 位宽度的八进制，左侧补 0
print("{:010o}".format(13))  # 输出: 0000000015

# 普通十六进制格式化
print("{:x}".format(7))  # 输出: 7

# 普通八进制格式化
print("{:o}".format(13))  # 输出: 15

# 将整数转为二进制字符串
print(bin(11)[2:])  # 输出: 1011

# 得到最后一位1
x & (-x)

# 去除最低一位1
x & (x-1)

# 取反
~x

# 负数
-x

# 左移（乘以2）
x << 1

# 右移（除以2）
x >> 1
```



# Bit manipulation

## 进制

![image-20230620122335323](./leetcode.assets/image-20230620122335323.png)

![image-20230620122349416](./leetcode.assets/image-20230620122349416.png)

## 计算机中的整数表示

![image-20230620122154047](./leetcode.assets/image-20230620122154047.png)

![image-20230620122254983](./leetcode.assets/image-20230620122254983.png)![image-20230620122302812](./leetcode.assets/image-20230620122302812.png)

## 位运算的概述和性质

![image-20230620123514732](./leetcode.assets/image-20230620123514732.png)![image-20230620123536970](./leetcode.assets/image-20230620123536970.png)![image-20230620123552227](./leetcode.assets/image-20230620123552227.png)

## Java中的二进制输出

```java

System.out.println(0b101);//二进制:5  （0b开头的）
System.out.println(0e1011);//0.0
System.out.println(011);//八进制:9 (0开头的)
System.out.println(11);//十进制:11
System.out.println(0x11C);//十六进制:284   （0x开头的）
System.out.printf("%010x\n",7);//0000000007   按10位十六进制输出，向右靠齐，左边用0补齐
System.out.printf("%010o\n",13);//0000000015    按10位八进制输出，向右靠齐，左边用0补齐
System.out.printf("%x\n",7);//7   按16进制输出
System.out.printf("%o\n",13);//15   按8进制输出
System.out.println(Integer.toBinaryString(11));//1011 二进制
```

## Java位运算

```java
// 1. 按位与（&）对两个数的每一位执行与运算，只有当对应的位都为 1 时结果才为 1。
int a = 5;  // 0101
int b = 3;  // 0011
int result = a & b;  // 0001 -> 1
// 2. 按位或（|）对两个数的每一位执行或运算，只要有一个对应的位为 1，结果就为 1。
int a = 5;  // 0101
int b = 3;  // 0011
int result = a | b;  // 0111 -> 7
// 3. 按位异或（^）对两个数的每一位执行异或运算，只有当两个位不同（一个为 1，一个为 0）时，结果才为 1。
int a = 5;  // 0101
int b = 3;  // 0011
int result = a ^ b;  // 0110 -> 6
// 4. 按位取反（~）对一个数的每一位取反，将 1 变为 0，0 变为 1。注意： Java 中整数以补码形式存储，所以对正数取反会得到负数。
int a = 5;  // 0101
int result = ~a;  // 1010 (取反) -> -6
// 5. 左移（<<）将一个数的位向左移动指定的位数，低位补 0。相当于乘以 2^𝑛
int a = 5;  // 0000 0101
int result = a << 2;  // 0001 0100 -> 20
// 6. 算术右移（>>）将一个数的位向右移动指定的位数，高位用符号位填充（正数补 0，负数补 1），相当于对 2 的幂次取整除（带符号）。
int a = 5;    // 0000 0101
int result = a >> 1;  // 0000 0010 -> 2

int b = -5;   // 1111 1011 (补码形式)
int result = b >> 1;  // 1111 1101 -> -3\
// 7. 无符号右移（>>>）无符号右移时，不管正负，高位都用 0 填充，不保留符号位。适用于处理无符号数。
int a = -5;   // 1111 1011 (补码形式)
int result = a >>> 1;  // 0111 1101 -> 2147483645
// 8. 复合运算符位运算的复合赋值操作符，例如 &=, |=, ^=, <<=, >>=, >>>= 等，用于对原值进行位操作并赋值。
int a = 5;     // 0101
a |= 3;        // 0111 -> 7
```







## 137. Single Number II

如果出现0次，ones和twos都是0，

如果出现1次，则ones为值，twos为0，

如果出现2次，则twos为值，ones为0，

如果出现3次，则ones为0，twos为0

```java
    public int singleNumber(int[] nums) {
                int ones = 0;
        int twos = 0;

        for (int i = 0; i < nums.length; i++) {
            ones = (ones ^ nums[i]) & ~twos;
            twos = (twos ^ nums[i]) & ~ones;
        }
        return ones;
    }
```

## 160. Intersection of Two Linked Lists
Tag: Linked List, Two Pointers
![image-20230720214811176](leetcode.assets/image-20230720214811176.png)

![image-20230720214831352](leetcode.assets/image-20230720214831352.png)

![image-20230720214928497](leetcode.assets/image-20230720214928497.png)

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
# TC: O(n)
# SC: O(1)
class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        p1 = headA
        p2 = headB

        while p1 is not p2:
            p1 = p1.next if p1 is not None else headB
            p2 = p2.next if p2 is not None else headA
        return p1
        
```

方法一：

一条线走A，走完A走B

一条线走B，走完B走A

这样就达到两个长度拼接起来的效果，也就是一样长（A+B）



```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        ListNode b = headB;

        while(a != b){
            a = a == null ? headB : a.next;
            b = b == null ? headA : b.next;
        }

        return a;


        // ListNode a = headA;
        // ListNode b = headB;
        // int sizeA = 0;
        // int sizeB = 0;
        // while(a != null){
        //     sizeA ++;
        //     a = a.next;
        // }
        // while(b != null){
        //     sizeB ++;
        //     b = b.next;
        // }

        // a = headA;
        // b = headB;
        // int diff = sizeA - sizeB;
        
        // if(diff != 0){
        //     if(diff > 0){
        //         while(diff != 0){
        //             a = a.next;
        //             diff--;
        //         }
        //     }else{
        //         while (diff != 0){
        //             b = b.next;
        //             diff++;
        //         }
        //     }
        // }
        
        // while(a != null){
        //     if(a.equals(b)){
        //         return a;
        //     }
        //     a = a.next;
        //     b = b.next;
        // }
        // return null;
    }
```







## [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)
![截屏2023-06-20 21.47.43](./leetcode.assets/截屏2023-06-20 21.47.43.png)



```java
    public int reverseBits(int n) {
        int reversed = 0, power = 31;
        while (n != 0) {
            reversed += (n & 1) << power;
            n >>>= 1;
            power--;
        }
        return reversed;
    }
```



## [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)

![image-20230620215332289](./leetcode.assets/image-20230620215332289.png)

![image-20230620215412916](./leetcode.assets/image-20230620215412916.png)

```java
    public int hammingWeight(int n) {
        int count = 0;
        for (int i = 0; i < 32; i++) {
            count += (n >> i) & 1;
        }
        return count;
    }
    
    // 位运算
    
        public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            n = n & (n - 1);
            count++;
        }
        return count;
    }

```



## 218. Bitwise AND of Numbers Range



​	![image-20230621175541188](./leetcode.assets/image-20230621175541188.png)



规律：

起始位和终止位往右边移动，移动到两个数字相同的时候（加上中间的数字这个时候都会相同），即是所有数字的共同部分

然后再重新补0还原数字

方法1：

移位，用上述规律移动left和right，直到相同时，往后补0

```
class Solution {
    public int rangeBitwiseAnd(int left, int right) {
        
        int shift = 0;
        while (left != 0){
            if(left == right){
                break;
            }
            left>>=1;
            right>>=1;
            shift++;
        }
        while (shift!=0){
            left = left << 1;
            shift--;
        }
        return left;
    }
    
    写法2：
    public int rangeBitwiseAnd(int m, int n) {
        int shift = 0;
        // 找到公共前缀
        while (m < n) {
            m >>= 1;
            n >>= 1;
            ++shift;
        }
        return m << shift;
    }

}
```



方法2：

### Brian Kernighan 算法

```
        while (m < n) {
        	n &= n-1;
        }
        return n;
```

## 371. Sum of Two Integers

![image-20230620223137032](./leetcode.assets/image-20230620223137032.png)

```java
    public int getSum(int a, int b) {
        
        while (b!=0){
            int temp = a^b; // 当前位
            b = (a&b) << 1; // 进位
            a = temp;
        }
        return a;
    }
```

## 421. Maximum XOR of Two Numbers in an Array
Tag: Trie, Bit Manupulation, Hash Table
```python
class Solution:
    # TC: O(31*n)
    # SC: O(n)
    def findMaximumXOR(self, nums: List[int]) -> int:
        s = set()
        x = 0
        for i in range(30,-1,-1):
            for num in nums:
                s.add(num >> i)
            xNext = x*2+1
            found = False
            for num in nums:
                if (num >> i) ^ xNext in s:
                    found = True
                    break
            if found:
                x = xNext
            else:
                x = xNext - 1
            s.clear()
        return x
```



# 滑动窗口

## [674. Longest Continuous Increasing Subsequ](https://leetcode.com/problems/longest-continuous-increasing-subsequence/)

![image-20230618155022686](./leetcode.assets/image-20230618155022686.png)

滑动窗口

```java
        int ans = 0;
        int i = 0;
        int j = 0;
        while (j < nums.length){
            if(j > 0 && nums[j] >= nums[j-1]){
                i = j;
            }
            ans = Math.max(ans, j - i + 1);
            j++;

        }
    
    // solution2
    
    public int findLengthOfLCIS(int[] nums) {
        int ans = 1;
        int len = 1;
        for (int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i-1]){
                len ++;
            }else{
                ans = Math.max(ans, len);
                len = 1;
            }
        }
        ans = Math.max(ans, len);
        return ans;
    }
```

# Recursion
## 22. Generate Parentheses
Tag: Recursion, Backtracking
```python
class Solution:
    # TC: O(2^n)
    # OC: O(n)
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def generate(s, op, close):
            if close == n:
                res.append(s)
                return
            if op < n:
                generate(s + '(', op + 1, close)
            if close < op:
                generate(s + ')', op, close + 1)
        generate('', 0,0)
        return res

    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        lst = []
        def backtracking(openN, closeN):
            if closeN == n:
                res.append(''.join(lst))
                return
            if openN < n:
                lst.append('(')
                backtracking(openN + 1, closeN)
                lst.pop()
            if closeN < openN:
                lst.append(')')
                backtracking(openN, closeN+1)
                lst.pop()
        backtracking(0,0)
        return res

    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        lst = []
        options = ['(', ')']

        self.left_count = 0
        self.right_count = 0
        def is_valid(parenthese):
            if parenthese == '(':
                return True if self.left_count < n else False
            else:
                return True if self.right_count < self.left_count else False
        def backtracking():
            if len(lst) == n*2:
                res.append(''.join(lst))
                return
            for option in options:
                if is_valid(option):
                    lst.append(option)
                    if option == '(':
                        self.left_count += 1
                    else:
                        self.right_count += 1
                    backtracking()
                    if option == '(':
                        self.left_count -= 1
                    else:
                        self.right_count -= 1
                    lst.pop()
        backtracking()
        return res
```
## 24. Swap Nodes in Pairs
Tag: Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None or head.next == None:
            return head
        
        n_round = head.next.next

        next = head.next
        next.next = head
        head.next = self.swapPairs(n_round)
        return next
```
## 37. Sudoku Solver
Tag: Recursion, Backtracking, Matrix
```python
class Solution:
    # TC: O(9^k) k is empty box number
    # SC: O(k)
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows = [set() for i in range(9)]
        cols = [set() for i in range(9)]
        blocks = [set() for i in range(9)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    value = board[i][j]
                    rows[i].add(value)
                    cols[j].add(value)
                    idx = i // 3 * 3 + j // 3
                    blocks[idx].add(value)

        def backtracking(i, j):
            if i==9:
                return True
            if j==9:
                return backtracking(i+1,0)
            if board[i][j] != '.':
                return backtracking(i, j+1)

            idx = i // 3 * 3 + j // 3
            for num in range(1, 10, 1):
                str_num = str(num)
                if str_num not in rows[i] and str_num not in cols[j] and str_num not in blocks[idx]:
                    rows[i].add(str_num)
                    cols[j].add(str_num)
                    blocks[idx].add(str_num)
                    board[i][j] = str_num

                    res = backtracking(i, j + 1)
                    if res == True:
                        return True
                    board[i][j] = '.'
                    rows[i].remove(str_num)
                    cols[j].remove(str_num)
                    blocks[idx].remove(str_num)
            return False

        backtracking(0, 0)

    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """

        def is_valid(i, j, num):
            for k in range(9):
                if num == board[i][k] or num == board[k][j] or board[i // 3 * 3 + (k // 3)][j // 3 * 3 + (k % 3)] == num:
                    return False
            return True

        def backtracking(i, j):
            if i==9:
                return True
            if j==9:
                return backtracking(i+1,0)
            if board[i][j] != '.':
                return backtracking(i, j+1)

            idx = i // 3 * 3 + j // 3
            for num in range(1, 10, 1):
                str_num = str(num)
                if is_valid(i, j, str_num):
                    board[i][j] = str_num
                    res = backtracking(i, j + 1)
                    if res == True:
                        return True
                    board[i][j] = '.'
            return False

        backtracking(0, 0)
```
## 51. N-Queens
Tag: Recursion, Backtracking, Bit Manipulation
```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        cols = set()
        diag1 = set()
        diag2 = set()
        res = []

        def backtracking(row, lst):
            if row == n:
                res.append(lst.copy())
                return
            for col in range(n):
                if col not in cols and row + col not in diag1 and row - col not in diag2:
                    cols.add(col)
                    diag1.add(row + col)
                    diag2.add(row - col)
                    s = ''
                    for i in range(n):
                        s += 'Q' if i == col else '.'
                    lst.append(s)
                    backtracking(row + 1, lst)
                    cols.remove(col)
                    diag1.remove(row + col)
                    diag2.remove(row - col)
                    lst.pop()
        backtracking(0, [])
        return res
```
## 52. N-Queens II
Tag: Recursion, Backtracking, Bit Manipulation
```python
class Solution:
    # TC: O(n!)
    # SC: O(1)
    def totalNQueens(self, n: int) -> int:
        def solve(row, cols, diag1, diag2):
            if row == n:
                return 1
            count = 0
            availablePositions = ((1<<n) - 1) & ~(cols | diag1 | diag2)
            while availablePositions:
                position =  availablePositions & (-availablePositions)
                availablePositions = availablePositions & (availablePositions-1)
                count += solve(row + 1, cols | position, (diag1 | position) << 1, (diag2 | position) >> 1)
            return count
        return solve(0, 0, 0, 0)

    # TC: O(n!)
    # SC: O(n)
    def totalNQueens(self, n: int) -> int:
        def backtrack_nqueen(row):
            if row == n:
                return 1
            count = 0
            for col in range(n):
                # iterate through columns at the curent row.
                if col not in columns and row - col not in diag1 and row + col not in diag2:
                    # explore this partial candidate solution, and mark the attacking zone
                    columns.add(col)
                    diag1.add(row - col)
                    diag2.add(row + col)
                    count += backtrack_nqueen(row + 1)
                    columns.remove(col)
                    diag1.remove(row - col)
                    diag2.remove(row + col)
            return count
        columns = set()
        diag1 = set()
        diag2 = set()
        return backtrack_nqueen(0)

    # TC: O(n!)
    # SC: O(n)
    def totalNQueens(self, n: int) -> int:
        placed = set()
        
        def is_not_under_attack( row, col):
            for queen in placed:
                r = queen[0]
                c = queen[1]
                if row == r or col == c or r+c == row + col or r-row == c-col:
                    return  False
            return True

        def place_queen( row, col):
            placed.add((row,col,))

        def remove_queen( row, col):
            placed.remove((row,col,))

        def backtrack_nqueen(row, count):
            for col in range(n):
                # iterate through columns at the curent row.
                if is_not_under_attack(row, col):
                    # explore this partial candidate solution, and mark the attacking zone
                    place_queen(row, col)
                    if row + 1 == n:
                        # we reach the bottom, i.e. we find a solution!
                        count += 1
                    else:
                        # we move on to the next row
                        count = backtrack_nqueen(row + 1, count)
                    # backtrack, i.e. remove the queen and remove the attacking zone.
                    remove_queen(row, col)
            return count

        return backtrack_nqueen(0, 0)
```
## 70. Climbing Stairs
Tag: Recursion, Math, Dynamic Programming

```python
class Solution:

    # TC: O(n)
    # SC: O(1)
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        d = [0] * 46
        d[1] = 1
        d[2] = 2
        for i in range(3, n+1, 1):
            d[i] = d[i-1] + d[i-2]
        return d[n]
    
    # TC: O(n)
    # SC: O(n)
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2
        d = {}
        d[1] = 1
        d[2] = 2
        return self.climbStairs_d(n,d)

    def climbStairs_d(self, n: int, d) -> int:
        if d.get(n) is not None:
            return d.get(n)
        res = self.climbStairs_d(n-1, d)+self.climbStairs_d(n-2, d)
        d[n]=res
        return res
```
## 77. Combinations
Tag: Recursion, Backtracking
```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        def backtracking(num, lst):
            if len(lst) == k:
                res.append(lst.copy())
                return
            for i in range(num, n+1):
                lst.append(i)
                backtracking(i+1, lst)
                lst.pop()
        backtracking(1, [])
        return res
```
## 95. Unique Binary Search Trees II
Tag: Tree, Recursion
```python
class Solution:
    # 卡特兰数（Catalan Number）
    # Cn = (2n)! / (n+1)2n!
    # TC: O(Cn)
    # SC: O(Cn)
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:
        memo = {}
        return self.generateTreess(1, n, memo)

    def generateTreess(self, start, end, memo):
        res = []
        if start > end:
            res.append(None)
            return res
        if (start,end) in memo:
            return memo[(start,end)]
        for i in range(start, end+1, 1):
            left = self.generateTreess(start, i-1, memo)
            right = self.generateTreess(i+1, end, memo)
            for l in left:
                for r in right:
                    root = TreeNode(i)
                    root.left = l
                    root.right = r
                    res.append(root)
        memo[(start,end)]=res
        return res
```
## 100. Same Tree
Tag: Recursion, Tree
```python

class Solution:
    # TC: O(n)
    # SC: O(h) h is height of the tree
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        if p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

    # TC: O(n)
    # SC: O(max) max tree node in a layer
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        def check(p, q):
            if p is None and q is None:
                return True
            if p is None or q is None:
                return False
            if p.val != q.val:
                return False
            return True
        queue = deque()
        queue.append((p,q))
        while len(queue):
            for _ in range(len(queue)):
                pair = queue.popleft()
                if check(pair[0], pair[1]):
                    if pair[0] is not None:
                        queue.append((pair[0].left, pair[1].left))
                        queue.append((pair[0].right, pair[1].right))
                else:
                    return False
        return True

```

## 101. Symmetric Tree
Tag: Binary Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if root == None:
            return True
        return self.helper(root.left, root.right)
    def helper(self, left, right):
        if left is None and right is None:
            return True
        if left is None or right is None:
            return False
        if left.val == right.val:
            return self.helper(left.left, right.right) and self.helper(left.right, right.left)
        else:
            return False
```

## 104. Maximum Depth of Binary Tree
Tag: Recursion, Tree
```python
class Solution:
    # TC: O(N) N is total node count
    # SC: O(n) n is the max depth
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```
## 240. Search a 2D Matrix II
Tag: Recursion, Matrix, Divide and Conquer
```python
class Solution:
    # TC: O(m + n)
    # SC: O(1)
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix)
        n = len(matrix[0])
        x = 0
        y = n-1
        while x < m and y >= 0:
            var = matrix[x][y]
            if var == target:
                return True
            elif var < target:
                x += 1
            else:
                y -= 1
        return False
    # Divide and conquer
    # TC: O(m*n)
    # SC: O(m+n)
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix) - 1
        n = len(matrix[0]) - 1
        m0 = 0
        n0 = 0
        return self.search(matrix, target, m0, m, n0, n)
    
    def search(self, matrix, target, m0, m, n0, n):
        if m0>m or n0 > n:
            return False
        
        x = m0
        y = n0
        while x <= m and y <= n and matrix[x][y] < target:
            x += 1
            y += 1
        if x <= m and y <= n and matrix[x][y] == target:
            return True
        rightTop = (m0, x - 1, y, n)
        leftBottom = (x, m, n0, y - 1)
        return self.search(matrix, target, *rightTop) or self.search(matrix,target,*leftBottom)

```
## 509. Fibonacci Number
Tag: Recursion, Math, Dynamic Programming
```python

class Solution:
    # TC: O(n)
    # SC: O(1)
    def fib(self, n: int) -> int:
        d = [0] * 31
        d[1] = 1
        i = 2
        while i <= n:
            d[i] = d[i-1] + d[i-2]
            i+=1
        return d[n]

    # TC: O(n)
    # SC: O(n)
    def fib(self, n: int) -> int:
        if n <= 1:
            return n
        d = {}
        d[0] = 0
        d[1] = 1
        return self.fib_d(n, d)

    def fib_d(self, n, d):
        if d.get(n) is not None:
            return d.get(n)
        res = self.fib_d(n-1,d) + self.fib_d(n-2,d)
        d[n] = res
        return res
```

## 779. K-th Symbol in Grammar
Tag: Recursion, Math
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def kthGrammar(self, n: int, k: int) -> int:
        if n == 1:
            return 0
        last_level = (k + 1) // 2
        reminder = (k+1) % 2
        last = self.kthGrammar(n-1, last_level)
        if last == 0:
            return 0 if reminder == 0 else 1
        else:
            return 1 if reminder ==0 else 0
```
