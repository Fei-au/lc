- [Tag](#tag)
- [Time Complexities](#time-complexities)
  - [Constant Time â€” ğ‘‚(1)O(1)](#constant-time--ğ‘‚1o1)
  - [Logarithmic Time â€” ğ‘‚(logâ¡ğ‘›)](#logarithmic-time--ğ‘‚logğ‘›)
  - [Linear Time â€” ğ‘‚(ğ‘›^2)](#linear-time--ğ‘‚ğ‘›2)
  - [Linearithmic Time â€” ğ‘‚(ğ‘›logğ‘›)](#linearithmic-time--ğ‘‚ğ‘›logğ‘›)
  - [Quadratic Time â€” ğ‘‚(ğ‘›^2)](#quadratic-time--ğ‘‚ğ‘›2)
- [Space Complexities](#space-complexities)
  - [Constant Space â€” ğ‘‚(1)](#constant-space--ğ‘‚1)
- [Computation](#computation)
  - [Python](#python)
  - [Division and Modulus](#division-and-modulus)
  - [50. Pow(x, n)](#50-powx-n)
  - [263. Ugly Number](#263-ugly-number)
- [Random (Python)](#random-python)
- [Random](#random)
  - [nextInt](#nextint)
- [List (Python)](#list-python)
  - [Slice (Python)](#slice-python)
  - [__iter__() Python](#iter-python)
- [Array](#array)
  - [Arraysæ–¹æ³•](#arraysæ–¹æ³•)
  - [List ArrayList](#list-arraylist)
  - [26. Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
  - [27. Remove Element](#27-remove-element)
  - [35. Search Insert Position](#35-search-insert-position)
  - [48. Rotate Image](#48-rotate-image)
  - [54. Spiral Matrix](#54-spiral-matrix)
  - [56. Merge Intervals](#56-merge-intervals)
  - [66. Plus One](#66-plus-one)
  - [73. Set Matrix Zeroes](#73-set-matrix-zeroes)
  - [75. Sort Colors](#75-sort-colors)
  - [80. Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array-ii)
  - [88. Merge Sorted Array](#88-merge-sorted-array)
  - [118. Pascal's Triangle](#118-pascals-triangle)
  - [119. Pascal's Triangle II](#119-pascals-triangle-ii)
  - [189. Rotate Array](#189-rotate-array)
  - [209. Minimum Size Subarray Sum](#209-minimum-size-subarray-sum)
  - [287. Find the Duplicate Number](#287-find-the-duplicate-number)
  - [283. Move Zeroes](#283-move-zeroes)
  - [414. Third Maximum Number](#414-third-maximum-number)
  - [448. Find All Numbers Disappeared in an Array](#448-find-all-numbers-disappeared-in-an-array)
  - [485. Max Consecutive Ones](#485-max-consecutive-ones)
  - [487. Max Consecutive Ones II](#487-max-consecutive-ones-ii)
  - [498. Diagonal Traverse](#498-diagonal-traverse)
  - [498. Diagonal Traverse](#498-diagonal-traverse-1)
  - [724. Find Pivot Index](#724-find-pivot-index)
  - [747. Largest Number At Least Twice of Others](#747-largest-number-at-least-twice-of-others)
  - [905. Sort Array By Parity](#905-sort-array-by-parity)
  - [941. Valid Mountain Array](#941-valid-mountain-array)
  - [977. Squares of a Sorted Array](#977-squares-of-a-sorted-array)
  - [1089. Duplicate Zeros](#1089-duplicate-zeros)
  - [1295. Find Numbers with Even Number of Digits](#1295-find-numbers-with-even-number-of-digits)
  - [1299. Replace Elements with Greatest Element on Right Side](#1299-replace-elements-with-greatest-element-on-right-side)
  - [1346. Check If N and Its Double Exist](#1346-check-if-n-and-its-double-exist)
- [String (Python)](#string-python)
- [String](#string)
  - [Compare and substring](#compare-and-substring)
  - [toCharArray](#tochararray)
  - [StringBuilder](#stringbuilder)
  - [String, Integer, int](#string-integer-int)
  - [char, int](#char-int)
  - [Sort String](#sort-string)
  - [5. Longest Palindromic Substring](#5-longest-palindromic-substring)
  - [14. Longest Common Prefix](#14-longest-common-prefix)
  - [28. Find the Index of the First Occurrence in a String](#28-find-the-index-of-the-first-occurrence-in-a-string)
  - [67. Add Binary](#67-add-binary)
  - [151. Reverse Words in a String](#151-reverse-words-in-a-string)
  - [167. Two Sum II - Input Array Is Sorted](#167-two-sum-ii---input-array-is-sorted)
  - [344. Reverse String](#344-reverse-string)
  - [557. Reverse Words in a String III](#557-reverse-words-in-a-string-iii)
  - [561. Array Partition](#561-array-partition)
- [Linked List](#linked-list)
    - [Add](#add)
    - [Delete](#delete)
  - [Double linked list](#double-linked-list)
  - [2. Add Two Numbers](#2-add-two-numbers)
  - [19. Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
  - [21. Merge Two Sorted Lists](#21-merge-two-sorted-lists)
  - [61. Rotate List](#61-rotate-list)
  - [138. Copy List with Random Pointer](#138-copy-list-with-random-pointer)
  - [141. Linked List Cycle](#141-linked-list-cycle)
  - [142. Linked List Cycle II](#142-linked-list-cycle-ii)
  - [160. Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)
  - [203. Remove Linked List Elements](#203-remove-linked-list-elements)
  - [206. Reverse Linked List](#206-reverse-linked-list)
  - [234. Palindrome Linked List](#234-palindrome-linked-list)
  - [328. Odd Even Linked List](#328-odd-even-linked-list)
  - [430. Flatten a Multilevel Doubly Linked List](#430-flatten-a-multilevel-doubly-linked-list)
  - [707. Design Linked List](#707-design-linked-list)
- [Set (Python)](#set-python)
- [Hash Table (Python dict)](#hash-table-python-dict)
  - [defaultdict](#defaultdict)
  - [Counter](#counter)
- [HashSet](#hashset)
- [HashMap](#hashmap)
  - [2. Tow Sum](#2-tow-sum)
  - [3. Longest Substring Without Repeating Characters](#3-longest-substring-without-repeating-characters)
  - [36. Valid Sudoku](#36-valid-sudoku)
  - [49. Group Anagrams](#49-group-anagrams)
  - [136. Single Number](#136-single-number)
  - [202. Happy Number](#202-happy-number)
  - [205. Isomorphic Strings](#205-isomorphic-strings)
  - [217. Contains Duplicate](#217-contains-duplicate)
  - [219. Contains Duplicate II](#219-contains-duplicate-ii)
  - [220. Contains Duplicate III](#220-contains-duplicate-iii)
  - [349. Intersection of Two Arrays](#349-intersection-of-two-arrays)
  - [350. Intersection of Two Arrays II](#350-intersection-of-two-arrays-ii)
  - [380. Insert Delete GetRandom O(1)](#380-insert-delete-getrandom-o1)
  - [387. First Unique Character in a String](#387-first-unique-character-in-a-string)
  - [454. 4Sum II](#454-4sum-ii)
  - [599. Minimum Index Sum of Two Lists](#599-minimum-index-sum-of-two-lists)
  - [771. Jewels and Stones](#771-jewels-and-stones)
- [Tree](#tree)
  - [^^Heap](#heap)
    - [Heap Queue (Python)](#heap-queue-python)
    - [PriorityQueue](#priorityqueue)
  - [23. Merge k Sorted Lists](#23-merge-k-sorted-lists)
  - [239. Sliding Window Maximum](#239-sliding-window-maximum)
  - [264. Ugly Number II](#264-ugly-number-ii)
  - [347. Top K Frequent Elements](#347-top-k-frequent-elements)
  - [652. Find Duplicate Subtrees](#652-find-duplicate-subtrees)
  - [^^Binary Tree](#binary-tree)
  - [94. Binary Tree Inorder Traversal](#94-binary-tree-inorder-traversal)
  - [102. Binary Tree Level Order Traversal](#102-binary-tree-level-order-traversal)
  - [106. Construct Binary Tree from Inorder and Postorder Traversal](#106-construct-binary-tree-from-inorder-and-postorder-traversal)
  - [110. Balanced Binary Tree](#110-balanced-binary-tree)
  - [112. Path Sum](#112-path-sum)
  - [116. Populating Next Right Pointers in Each Node](#116-populating-next-right-pointers-in-each-node)
  - [144. Binary Tree Preorder Traversal](#144-binary-tree-preorder-traversal)
  - [145. Binary Tree Postorder Traversal](#145-binary-tree-postorder-traversal)
  - [236. Lowest Common Ancestor of a Binary Tree](#236-lowest-common-ancestor-of-a-binary-tree)
  - [297. Serialize and Deserialize Binary Tree](#297-serialize-and-deserialize-binary-tree)
  - [^^Trie](#trie)
  - [208. Implement Trie (Prefix Tree)](#208-implement-trie-prefix-tree)
  - [211. Design Add and Search Words Data Structure](#211-design-add-and-search-words-data-structure)
  - [336. Palindrome Pairs](#336-palindrome-pairs)
  - [421. Maximum XOR of Two Numbers in an Array](#421-maximum-xor-of-two-numbers-in-an-array)
  - [212. Word Search II](#212-word-search-ii)
  - [648. Replace Words](#648-replace-words)
  - [677. Map Sum Pairs](#677-map-sum-pairs)
  - [^^N-ary Tree](#n-ary-tree)
  - [429. N-ary Tree Level Order Traversal](#429-n-ary-tree-level-order-traversal)
  - [559. Maximum Depth of N-ary Tree](#559-maximum-depth-of-n-ary-tree)
  - [589. N-ary Tree Preorder Traversal](#589-n-ary-tree-preorder-traversal)
  - [590. N-ary Tree Postorder Traversal](#590-n-ary-tree-postorder-traversal)
  - [^^Binary Search Tree (BST)](#binary-search-tree-bst)
  - [98. Validate Binary Search Tree](#98-validate-binary-search-tree)
  - [108. Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
  - [173. Binary Search Tree Iterator](#173-binary-search-tree-iterator)
  - [235. Lowest Common Ancestor of a Binary Search Tree](#235-lowest-common-ancestor-of-a-binary-search-tree)
  - [450. Delete Node in a BST](#450-delete-node-in-a-bst)
  - [700. Search in a Binary Search Tree](#700-search-in-a-binary-search-tree)
  - [701. Insert into a Binary Search Tree](#701-insert-into-a-binary-search-tree)
  - [703. Kth Largest Element in a Stream](#703-kth-largest-element-in-a-stream)
- [TreeSet](#treeset)
- [Queue](#queue)
  - [BSF](#bsf)
  - [Deque or LinkedList](#deque-or-linkedlist)
  - [200. Number of Islands](#200-number-of-islands)
  - [279. Perfect Squares](#279-perfect-squares)
  - [542. 01 Matrix](#542-01-matrix)
  - [622. Design Circular Queue](#622-design-circular-queue)
  - [841. Keys and Rooms](#841-keys-and-rooms)
- [Stack](#stack)
  - [DSF](#dsf)
  - [20. Valid Parentheses](#20-valid-parentheses)
  - [84. Largest Rectangle in Histogram](#84-largest-rectangle-in-histogram)
  - [133. Clone Graph](#133-clone-graph)
  - [150. Evaluate Reverse Polish Notation](#150-evaluate-reverse-polish-notation)
  - [155. Min Stack](#155-min-stack)
  - [200. Number of Islands](#200-number-of-islands-1)
  - [225. Implement Stack using Queues](#225-implement-stack-using-queues)
  - [232. Implement Queue using Stacks](#232-implement-queue-using-stacks)
  - [394. Decode String](#394-decode-string)
  - [733. Flood Fill](#733-flood-fill)
  - [739. Daily Temperatures](#739-daily-temperatures)
- [Binary Search](#binary-search)
  - [4. Median of Two Sorted Arrays](#4-median-of-two-sorted-arrays)
  - [33. Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array)
  - [34. Find First and Last Position of Element in Sorted Array](#34-find-first-and-last-position-of-element-in-sorted-array)
  - [69. Sqrt(x)](#69-sqrtx)
  - [153. Find Minimum in Rotated Sorted Array](#153-find-minimum-in-rotated-sorted-array)
  - [154. Find Minimum in Rotated Sorted Array II](#154-find-minimum-in-rotated-sorted-array-ii)
  - [162. Find Peak Element](#162-find-peak-element)
  - [278. First Bad Version](#278-first-bad-version)
  - [367. Valid Perfect Square](#367-valid-perfect-square)
  - [374. Guess Number Higher or Lower](#374-guess-number-higher-or-lower)
  - [410. Split Array Largest Sum](#410-split-array-largest-sum)
  - [658. Find K Closest Elements](#658-find-k-closest-elements)
  - [704. Binary Search](#704-binary-search)
  - [719. Find K-th Smallest Pair Distance](#719-find-k-th-smallest-pair-distance)
  - [744. Find Smallest Letter Greater Than Target](#744-find-smallest-letter-greater-than-target)
  - [1051. Height Checker](#1051-height-checker)
- [Sorting æ’åºç®—æ³•](#sorting-æ’åºç®—æ³•)
  - [å¿«æ’ QuickSort](#å¿«æ’-quicksort)
  - [912. Sort an Array](#912-sort-an-array)
  - [Merge Sort](#merge-sort)
    - [?couting sortï¼Ÿ](#couting-sort)
- [Bit manupulation (python)](#bit-manupulation-python)
- [Bit manipulation](#bit-manipulation)
  - [è¿›åˆ¶](#è¿›åˆ¶)
  - [è®¡ç®—æœºä¸­çš„æ•´æ•°è¡¨ç¤º](#è®¡ç®—æœºä¸­çš„æ•´æ•°è¡¨ç¤º)
  - [ä½è¿ç®—çš„æ¦‚è¿°å’Œæ€§è´¨](#ä½è¿ç®—çš„æ¦‚è¿°å’Œæ€§è´¨)
  - [Javaä¸­çš„äºŒè¿›åˆ¶è¾“å‡º](#javaä¸­çš„äºŒè¿›åˆ¶è¾“å‡º)
  - [Javaä½è¿ç®—](#javaä½è¿ç®—)
  - [137. Single Number II](#137-single-number-ii)
  - [160. Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists-1)
  - [190. Reverse Bits](#190-reverse-bits)
  - [191. Number of 1 Bits](#191-number-of-1-bits)
  - [218. Bitwise AND of Numbers Range](#218-bitwise-and-of-numbers-range)
    - [Brian Kernighan ç®—æ³•](#brian-kernighan-ç®—æ³•)
  - [371. Sum of Two Integers](#371-sum-of-two-integers)
  - [421. Maximum XOR of Two Numbers in an Array](#421-maximum-xor-of-two-numbers-in-an-array-1)
- [æ»‘åŠ¨çª—å£](#æ»‘åŠ¨çª—å£)
  - [674. Longest Continuous Increasing Subsequ](#674-longest-continuous-increasing-subsequ)
- [Recursion](#recursion)
  - [22. Generate Parentheses](#22-generate-parentheses)
  - [24. Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
  - [37. Sudoku Solver](#37-sudoku-solver)
  - [51. N-Queens](#51-n-queens)
  - [52. N-Queens II](#52-n-queens-ii)
  - [70. Climbing Stairs](#70-climbing-stairs)
  - [77. Combinations](#77-combinations)
  - [95. Unique Binary Search Trees II](#95-unique-binary-search-trees-ii)
  - [100. Same Tree](#100-same-tree)
  - [101. Symmetric Tree](#101-symmetric-tree)
  - [104. Maximum Depth of Binary Tree](#104-maximum-depth-of-binary-tree)
  - [240. Search a 2D Matrix II](#240-search-a-2d-matrix-ii)
  - [509. Fibonacci Number](#509-fibonacci-number)
  - [779. K-th Symbol in Grammar](#779-k-th-symbol-in-grammar)


# Tag
- Array
  - From right to left
  
- Two Pointers
  - One pointer point to iterate index, another pointer point to valid index
  - From right to left
  - From two ends
  - Find the middle, from middle to two ends
  - Iterate twice, first round collect info, second round process it
  - Slow pointer and fast pointer
    - fast pointer move twice as slow pointer
    - fast pointer move n steps (n from questions) in advance
  - For rotate problem, reverse and reverse part could achieve rotate effect
  - Use two pointers to reverse a string / list, by 
    - exchange two pointer if left < right 
    - use start and len-1-start and loop [start,(len-start)//2]
    - use left and right, and loop [left,left+(right-left)//2], len is right-left+1
  - 
- Sliding Window
  Normally need two pointers
  - Iternate left pointer in the range
    - Move left pointer to the valid start place
    - Assign right pointer to left pointer position, and move to valid end place (or the next position of valid end place)
    - Get a valid window and process
    - Assign left pointer to right pointer position
  - Use the outer loop to iternate the right pointer
    - Method 1.
      - While right < n:
      - Move right pointer to add valid element
      - Move left pointer to eliminate invalid element (This could use the outer while right < n loop)
    - Method 2. 
      - Check if the range valid in every outer loop
      - if not valid, then keep iterate the right pointer
      - if valid, inside the outer loop, loop left pointer 
  
- Cyclic Sort
  - Regard value at the index as the next index

- Floydâ€™s Cycle Detection
  - Any thing if there is a cycle, we could use it to check. A fast pointer, a slow pointer
  - 
- Linked List
  - Find the common patter from the very first elements, and apply them to each elements to see if it applied, adjust to fit all boundry senario. Find a common state of each step, and loop them.
  - Add dummy head to avoid first element boundry problem
  - Find interaction point, Connect two linked list by loop one and then go another one.
  - N th from the end, Two pointers, one go n step first, and then another from start, the first one from where it is, this find the nth from the end 

- Matrix
  - Set from and start then loop, the row start, column start, row end, column end could be change to satisfy the condition
  - Use (row + column) to indicate diagnoses
  - Use dirs [[0,1], [0,-1], [1,0], [-1,0]] to indicate four directions

- Math
  - Two Sum or sum questions, change the question to make reminder to 0, save each middiate value in a set, and check if (target - cur) in the set

- Dynamic Programming
  - 118 119 redo by using dynamic programming thoughts

- Hash Table
  - Check duplicate
  - Use space to optimize time

- Binary Tree
  - å‰ä¸­ååºï¼šæŒ‡æ ¹åœ¨å“ªä¸ªä½ç½®éå†
    - å‰åºï¼ˆPreorder Traversalï¼‰ï¼šæ ¹ â†’ å·¦ â†’ å³
    - ä¸­åºï¼ˆInorder Traversalï¼‰ï¼šå·¦ â†’ æ ¹ â†’ å³
    - ååºï¼ˆPostorder Traversalï¼‰ï¼šå·¦ â†’ å³ â†’ æ ¹
  - å”¯ä¸€ç¡®å®šä¸€æ£µæ ‘ï¼Œå³é€šè¿‡åºåˆ—åŒ–åçš„ç»“æœï¼Œæ˜¯å¦å¯ä»¥è¿˜åŸè¯¥æ ‘
    - ä¸­åº+å‰åº
      - å‰åºç¬¬ä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹
      - åœ¨ä¸­åºä¸­æ‰¾åˆ°æ ¹çš„ä½ç½® â†’ å·¦å³å­æ ‘å¤§å°å°±ç¡®å®šäº†
      - ç„¶åé€’å½’åˆ’åˆ†å³å¯
    - ä¸­åº+ååº
      - ååºæœ€åä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹
      - åœ¨ä¸­åºä¸­æ‰¾æ ¹çš„ä½ç½®ï¼ŒåŒæ ·èƒ½åˆ’åˆ†å·¦å³å­æ ‘
      - å†é€’å½’å¤„ç†å³å¯
    - å½“ç©ºèŠ‚ç‚¹åœ¨åºåˆ—åŒ–ä¸­ç”¨`null`ç­‰è¡¨ç¤ºçš„æ—¶å€™ï¼Œåˆ™åªå‰åºï¼Œæˆ–ååºåºåˆ—åŒ–å°±å¯ä»¥å”¯ä¸€ç¡®å®šä¸€æ£µæ ‘ã€‚é€šå¸¸ç”¨**å‰åº**
  
- Node
  - Define Node, integrate information in a node to save inforamtion at each node. Like min of current
  
- Stack
  - DFS
  - 

- Queue
  - BFS
    - in BFS, use queue to save each layer's value
    - loop the layer by using get the size before loop
    - check if valid in the loop, store next layer's value in the queue
- Heap
  - pythoné»˜è®¤æœ€å°å †ï¼ŒæŠŠæ•°å­—ä¹˜ -1 å­˜è¿›å»ï¼Œå°±æ˜¯æœ€å¤§å †
  - å¯ä»¥å­˜tupleè¿›å»ï¼Œä¿å­˜å¤šä¸ªä¿¡æ¯ï¼Œä¹Ÿå¯ä»¥å½“æ•°å­—ç›¸åŒæ—¶æ¯”è¾ƒå¤šç»„æ•°æ®ã€‚æ¯”å¦‚å­˜è¿›å»ï¼ˆæ•°å­—+indexï¼‰ï¼Œæ„æˆäº†ä¸€ä¸ªæ’åºçš„æ»‘åŠ¨çª—å£
  - å¯ä»¥åœ¨tupleçš„ä¿¡æ¯å‰é¢ä½¿ç”¨ä¸€ä¸ªcountï¼Œæ¥ä¿è¯å¤šå­˜è¿›å»çš„ä¿¡æ¯å³ä¾¿ä¸æ˜¯comparableçš„ï¼Œä¹Ÿå¯ä»¥åœ¨tupleé‡Œé¢
  
- Binary Search
  > Find upper bound to insert the target. The upper bound is the least value greater than target
  > Find lower bound to insert the target. The lower bound is the largest value greater than or equal to the target

  > The bound is where to insert the target to make the array keep sorted.
  > And when insert for example to index 2, it means the target now is inserted to index 2, and rest value from index 2, move right 1 position
  
  > Upper bound [-1,2,2,2,2,*12*] target 2, and finally check left > 0 and left - 1 == target
  
  > Lower bound [-1,*2*,2,2,2,12] target 2, and finally check left < size and left == target

  - Left should always be mid + 1, only this the range could shrink
  - right could be set to mid, and the position will be eliminate
  
- Recursion
  - Use visited matrix to record processed place
  - Set visited place as special value at the begaining of one round recursion, set it back after this round to restore the state. This is used when you want to use totally new visited matrix in every start point
  - We can check the condition before call the recursion, like within `for dir in dirs`, we do if 0 < x < m and somecondition: recursion
  - We can also check the condition at the start, and in `for dir in dirs`, we just check basic valid boundary and then start recursion, leave the consition check at the start. This is for the senario start the start point needs to be checked and possiblely be a solution
  

- Top down
  - Usually use recursion
  - One step one step to solve problem, final step get the solution


- Bottom up
  - Usually no recursion, use loop
  - Dynamic programming mindset
  - Solve basic problem first, find the connection to the larger problem, then solve that one, till the result

- Backtracking
  - Check valid at the beginning of the function
  - Iterate next valid steps, place valid position, recursively call, remove valid position

- Divide and conquer
  1. Divide, Divide the problem into a set of subproblems
  2. Conquer, Solve each subproblem recursively
  3. 
  4. Combine, Combine the results of each subproblem


# Time Complexities

## Constant Time â€” ğ‘‚(1)O(1)

Description: Execution time remains constant regardless of input size.
Example: Accessing a specific element in an array.

```python
def get_first_element(arr):
    return arr[0]

```
## Logarithmic Time â€” ğ‘‚(logâ¡ğ‘›)

Description: Execution time grows logarithmically with input size.
Example: Binary search in a sorted array.
**Notice: if having odd, even array consideration, use the minimum [0,1] and [0] and [0,1,2]**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1


# Use recursion to return bool
def binary_search(arr, target):
    if not arr:
        return False
    mid = len(arr) // 2
    if arr[mid] < target:
        return binary_search(arr[mid+1:], target)
    elif arr[mid] > target:
        return binary_search(arr[:mid], target)
    else:
        return True

# use recursion to return index of target
def start(arr, target):
    return binary_search_recursion_index(arr, target, 0, len(arr) - 1)
def binary_search_recursion_index(arr, target, left, right):
    if left > right:
        return -1
    mid = left + (right - left) // 2
    if arr[mid] < target:
        return binary_search_recursion_index(arr, target, left + 1, right)
    elif arr[mid] > target:
        return binary_search_recursion_index(arr, target, left, right - 1)
    else:
        return mid
```
## Linear Time â€” ğ‘‚(ğ‘›^2)

Description: Execution time grows linearly with input size.
Example: Linear search or traversing an array.
```python
def linear_search(arr, target):
    for index, value in enumerate(arr):
        if value == target:
            return index
    return -1
```
## Linearithmic Time â€” ğ‘‚(ğ‘›logğ‘›)
Description: Execution time grows proportionally to 
ğ‘›log
â¡
Example: Efficient sorting algorithms like Merge Sort and Quick Sort (average case).
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
## Quadratic Time â€” ğ‘‚(ğ‘›^2)

Description: Execution time grows proportionally to the square of the input size.
Example: Simple sorting algorithms like Bubble Sort and Selection Sort.
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
```
Exponential Time â€” ğ‘‚(2^ğ‘›)

Description: Execution time grows exponentially with input size, often impractical for large inputs.
Example: Naive recursive calculation of Fibonacci numbers.
```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```



# Space Complexities
## Constant Space â€” ğ‘‚(1)

Description: Requires a fixed amount of additional space regardless of input size.
Example: In-place algorithms like reversing an array without using extra storage.
```python
def reverse_array(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
    return arr
```
Linear Space â€” ğ‘‚(ğ‘›)O(n)

Description: Requires space proportional to the input size.
Example: Merge Sort, which uses additional arrays for merging.
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
Logarithmic Space â€” ğ‘‚(logğ‘›)

Description: Requires space proportional to the logarithm of the input size, often seen in recursive algorithms due to stack space.
Example: Quick Sort's recursive implementation.
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
















![image-20230331142953809](./leetcode.assets/image-20230331142953809.png)







# Computation

## Python

```python
# Exponential
5**2
pow(5,2)

# Divide
## Double divide
5/2 = 2.5
4/2 = 2.0
## Floor divide
5 // 2 = 2
4 // 2 = 2

# Square root
result = math.sqrt(16)
>>> 4.0

result = 16**0.5
>>> 4.0

# Float to int
x = 5.2
int(x)
round(x)
```

## Division and Modulus



Java

Integer division

```java
5 / 3 = 1
5 / 2 = 2
```

Reminder / modulus operations

```java
5 % 3 = 2
5 % 2 = 1
```

Python

Integer division

```python
5 // 3 = 1
5 // 2 = 2
```

Reminder / modulus operations

```python
5 % 3 = 2
5 % 2 = 1
```

## 50. Pow(x, n)
Tag: Math
```python
class Solution:
    # TC: O(logn)
    # SC: O(logn)
    def myPow(self, x: float, n: int) -> float:
        d = {}
        d[0] = 1
        if n >= 0:
            return self.m_pow(x,n, d)
        else:
            return 1/self.m_pow(x,-n, d)

    def m_pow(self, x, n, d):
        if d.get(n) is not None:
            return d.get(n)
        r = 1 if n % 2 == 0 else x
        d[n] = r * self.m_pow(x, n//2, d) * self.m_pow(x, n//2, d)
        return d[n]

    # TC: O(logn)
    # SC: O(logn)
    def myPow(self, x: float, n: int) -> float:
        d = {}
        if n < 0:
            return 1/self.get_v(x, -n, d)
        else:
            return self.get_v(x, n, d)

    def get_v(self, x, n, d):
        if n == 0:
            d[n] = 1
            return 1
        if n == 1:
            d[n] = x
            return x
        if d.get(n):
            return d.get(n)
        big = self.get_v(x, n // 2, d)
        residual = self.get_v(x, n % 2, d)
        res = big * big * residual
        d[n] = res
        return res
```

## 263. Ugly Number
Tag: Math
```python
class Solution:
    # TC: O(n)
    # SC: O(1)
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 2 == 0 or n % 3 == 0 or n % 5 == 0:
            while n % 2 == 0:
                n //= 2
            while n % 3 == 0:
                n //= 3
            while n % 5 == 0:
                n //= 5
        return True if n == 1 else False
```

# Random (Python)
```python
import random

# 1. get rand int
random.randint(a,b) # a, b inclusive

# 2. get random element from non empty structure (list, tuple, string, etc.)
random.choice(my_list)

# 3. get value from [0, 1), return float
v = random.random()
```

# Random

## nextInt

```java
Random random = new Random();
random.nextInt(10); // 0 - 9 integer
// get 10-20
random.nextInt(20 - 10 + 1) + 10;
```


# List (Python)
The python list does not have fix len
```python
>>> print(type([]))
>>> <class 'list'>
# 1. Initialize a list of length 5 with default values (0)
nums = [0] * 5  # [0, 0, 0, 0, 0]
>>> len(nums)
>>> 5
# The list can append more element which will increase the list len
nums.append(1)
>>> len(nums)
>>> 6
# 1.1 Initialize a list with specific values
nums = [1, 3, 5, 6, 7]
>>> len(nums)
>>> 5

# 2. Set value
nums[0] = 100
>>> nums[0]
>>> 100

# 3. add value
nums.append(5)
>>> nums[len(nums) - 1]
>>> 5
# 3.1 add at index 2
# nums.insert(index, value)
nums.insert(2, 8)

# 4. Len of list
>>> len(nums)
>>> 6

# 5. remove element
# 5.1 Remove the first occurance of value in list nums, if value is not in the list, raise ValueError
# O(n). Find O(n), shift O(n)
nums.remove(value) 

# 5.2 Remove the element in index, return the pop's element, raise IndexError if index of out out range. 
# O(n-i) -> O(n). Find, and shift rest element left by one
value = nums.pop(index) 

# 5.3 Remove element in index range, include start not include end, not raise any error
# O(n-i) -> O(n)
del nums[start:end]

# 5.4 Remove in place
def remove_ele(value, nums):
    nums_len = len(nums)
    j = 0
    for i in nums_len:
        if nums[i] == value:
            continue
        else:
            nums[j] = nums[i]
            j+=1
    new_len = j
    return nums, new_len

def remove_ele(index, nums):
    nums_len = len(nums)
    for i in range(index + 1, nums_len)
        nums[i - 1] = nums[i]
    # Optionally, remove the last one
    nums_len -= 1
    nums = nums[:nums_len]

    return nums, nums_len

# 6. Sort
# nums.sort, sort in place, return None 
# nums.sort(key=func, reverse=True|False) asc
# key: A function to specify the sorting criteria(s)
# reverse: default is false
nums.sort() # asc
nums.sort(reverse=True) # des
def get_len(ele):
    return len(ele)
nums = ["abcd", "ac", "abc", "D"]
>>> nums.sort(key=get_len)
>>> nums
>>> ["D", "ac", "abc", "abcd"]

nums.reverse() # reverse itself, no return
reversed_nums = nums[::-1] # slice reverse
reversed_nums = list(reversed(arr)) # è¿”å›è¿­ä»£å™¨, é…åˆlistä½¿ç”¨

left, right = 0, len(arr) - 1
while left < right:
    arr[left], arr[right] = arr[right], arr[left]
    left += 1
    right -= 1

nums.reverse() # reverse itself, no return
reversed_nums = nums[::-1] # slice reverse
reversed_nums = list(reversed(arr)) # è¿”å›è¿­ä»£å™¨, é…åˆlistä½¿ç”¨

left, right = 0, len(arr) - 1
while left < right:
    arr[left], arr[right] = arr[right], arr[left]
    left += 1
    right -= 1

# 7. Copy range
# from index 1 to 4 (1 inclusive, 4 exclusive)
part_array = nums[1:4]

# 7.1 Copy
v1 = list(nums)
v2 = nums.copy()

# 8. Fill array with a specific value
arr = [-1] * 10

# 9. print multi-dimentional arrays
matrix = [
    [1, 2, 3],
    [4, 5, 6]
]
print(matrix[row][col]) # 2

# 10. Iterate
for ele in nums:
    print(ele)

for i in range(len(nums)):
    print(nums[i])

# 11. Clear all
nums.clear()

# 12. Comparable
nums1 = [1]
nums2 = [1]
>>> nums1 == nums2
>>> True

>>> nums1 is nums2
>>> False

# 13. Concat
nums1 = [1]
nums2 = [1]
nums_total = nums1 + nums2
nums_total = nums1.extend(nums2)
```

## Slice (Python)
```python
arr[start:stop:step]

# åˆ‡ç‰‡
print(arr[::1])   # [10, 20, 30, 40, 50] æ­£å¸¸é¡ºåº
print(arr[::2])   # [10, 30, 50] éš”ä¸€ä¸ªå–ä¸€ä¸ª
print(arr[::-1])  # [50, 40, 30, 20, 10] å®Œæ•´åè½¬
```

## __iter__() Python
ä»¥ä¸‹éƒ½å®ç°äº†__iter__æ–¹æ³•ï¼Œå¯ä»¥ä½¿ç”¨ for, in, iter(), next()
```python
list, tuple, str, set, dict, range, bytes, bytearray, file, zip, map, filter, enumerate, reversed, deque, frozenset
```

# Array

**åˆ›å»ºArray**


```java
int[] nums = new int[5]; // {0,0,0,0,0} åˆå§‹åŒ–éƒ½æ˜¯0
>>> nums.length
>>> 5
int[] nums = {1,3,5,6,7}; // å¸¦åˆå§‹åŒ–
>>> nums.length
>>  5
```



**æ·»åŠ å€¼ insert value**

```java
nums[0] = 5;
nums[2] = 3;
```



**åˆ é™¤**

ä¸æ˜¯çœŸæ­£çš„æŠŠarrayé•¿åº¦å˜çŸ­ï¼Œè€Œæ˜¯åˆ›å»ºå˜é‡lengthï¼Œæ¥è¡¨ç¤ºarrayçš„æ–°é•¿åº¦

```java
// åˆ é™¤ç¬¬iä½
let length = int_array.length;
for (int i = 1; i < length; i++) {
    // Shift each element one position to the left
    int_array[i - 1] = int_array[i];
}

length--;
```



## Arraysæ–¹æ³•

```java
int[] array = new int[10];
// 1. Sort
Arrays.sort(arr); // å‡åº
Arrays.sort(arr, compare);
// custom comparator
List<String> list = Arrays.asList("Banana", "Apple", "Orange", "Mango");
// ä½¿ç”¨åŒ¿åç±»åˆ›å»ºè‡ªå®šä¹‰ Comparator
Collections.sort(list, new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length(); // æŒ‰å­—ç¬¦ä¸²é•¿åº¦æ’åº
    }
});

// Use lambda
 list.sort((s1, s2) -> s1.length() - s2.length());

// 2. Copy range
int[] partArray = Arrays.copyOfRange(array, from. to); // from inclusive, to exclusive
// 3. Fill array with a specific value;
Arrays.fill(array, -1);
// 4. æ‰“å°å¤šç»´æ•°ç»„
Arrays.deepToString(mulArr);
arr[row][col]
```



## List ArrayList

```java
 // 1. initialize
List<Integer> v0 = new ArrayList<>();
List<Integer> v1;                           // v1 == null
// 2. cast an array to a vector
Integer[] a = {0, 1, 2, 3, 4};
v1 = new ArrayList<>(Arrays.asList(a));
v1 = new ArrayList<>(Arrays.asList(1,2,3,4,7,8));
// 3. make a copy
List<Integer> v2 = v1;                      // another reference to v1
List<Integer> v3 = new ArrayList<>(v1);     // make an actual copy of v1
// copy a certain range to new ArrayList
List<Integer> v4 = Arrays.copyOfRange(left, right); // include left, exclude right
// 4. get length
System.out.println("The size of v1 is: " + v1.size());
// 5. access element
System.out.println("The first element in v1 is: " + v1.get(0));
// 6. iterate the vector
// size
System.out.print("[Version 1] The contents of v1 are:");
for (int i = 0; i < v1.size(); ++i) {
    System.out.print(" " + v1.get(i));
}
System.out.println();
System.out.print("[Version 2] The contents of v1 are:");
for (int item : v1) {
    System.out.print(" " + item);
}
System.out.println();
// 7. modify element
v2.set(0, 5);       // modify v2 will actually modify v1
System.out.println("The first element in v1 is: " + v1.get(0));

// 8. add element
v2.add(8);
// add element at index
v2.add(2, 8); // add 8 at index 2
// 9. clear all
v2.clear();
// 10. to array
int[] array = Arrays.toArray(v1);
```





```java
åœ¨æœ«å°¾æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼švoid add(E e)
åœ¨æŒ‡å®šç´¢å¼•æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼švoid add(int index, E e)
åˆ é™¤æŒ‡å®šç´¢å¼•çš„å…ƒç´ ï¼šE remove(int index)
åˆ é™¤æŸä¸ªå…ƒç´ ï¼šboolean remove(Object e)
è·å–æŒ‡å®šç´¢å¼•çš„å…ƒç´ ï¼šE get(int index)
è·å–é“¾è¡¨å¤§å°ï¼ˆåŒ…å«å…ƒç´ çš„ä¸ªæ•°ï¼‰ï¼šint size()
```



`v1 = new ArrayList<>(Arrays.asList(a));`

```java
public ArrayList(Collection<? extends E> c)
// ç»§æ‰¿Collectionçš„ç±»æœ‰
/*
List
	ArrayList
    LinkedList
    Vector
Set
	HashSet
    LinkedHashSet
    TreeSet
Queue
	PriorityQueue
    LinkedListï¼ˆåŒæ—¶å®ç°äº† Queue å’Œ Dequeï¼‰
    ArrayDeque
Deque
	ArrayDeque
	LinkedList
*/
    
Arrays.asList();

public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}

/*
<T>: è¿™æ˜¯ä¸€ä¸ª æ³›å‹å£°æ˜ï¼Œè¡¨ç¤ºè¿™ä¸ªæ–¹æ³•æ˜¯æ³›å‹æ–¹æ³•ã€‚<T> å®šä¹‰äº†ä¸€ä¸ªç±»å‹å‚æ•° Tï¼Œå®ƒåœ¨è¿™ä¸ªæ–¹æ³•çš„ä¸Šä¸‹æ–‡ä¸­å¯ä»¥ç”¨æ¥è¡¨ç¤ºä»»æ„ç±»å‹ã€‚

List<T>: è¿™æ˜¯è¿™ä¸ªæ–¹æ³•çš„è¿”å›å€¼ç±»å‹ï¼Œè¡¨ç¤ºå®ƒè¿”å›ä¸€ä¸ª Listï¼Œå…¶ä¸­çš„å…ƒç´ ç±»å‹æ˜¯ Tã€‚

T... a: è¿™æ˜¯å¯å˜å‚æ•°ï¼ˆvarargsï¼‰ï¼Œè¡¨ç¤ºæ–¹æ³•å¯ä»¥æ¥æ”¶ä»»æ„æ•°é‡çš„ç±»å‹ä¸º T çš„å‚æ•°ã€‚å®é™…ä¸Šï¼Œå®ƒæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ–¹æ³•å†…éƒ¨ä¼šå°†ä¼ å…¥çš„å‚æ•°æ‰“åŒ…æˆä¸€ä¸ªæ•°ç»„ã€‚
Arrays.asList(1, 2, 3);      // T æ˜¯ Integerï¼Œå‚æ•°æ˜¯ {1, 2, 3}
Arrays.asList("a", "b");
*/
```





## 26. Remove Duplicates from Sorted Array
Tag: Array, Sliding Window, Two Pointers
![image-20230613161652475](./leetcode.assets/image-20230613161652475.png)

```python
class Solution6(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        valid = 1
        for i in range(1, len(nums)):
            if nums[i - 1] != nums[i]:
                nums[valid] = nums[i]
                valid += 1
        return valid
```
**æ»‘åŠ¨çª—å£**

ä»ç¬¬äºŒä½å¼€å§‹éå†ï¼Œç”¨kè®°å½•æœ‰å¤šå°‘ä¸ªé‡å¤çš„æ•°å­—ï¼ŒåŒæ—¶ç”¨æ¥æ ‡è®°è¯¥èµ‹å€¼çš„åœ°æ–¹

â€‹	å¦‚æœç¬¬äºŒä½ä¸ç¬¬ä¸€ä½ä¸ä¸€æ ·ï¼Œåˆ™ç»™ç¬¬ä¸€ä½èµ‹å€¼

â€‹	å¦‚æœä¸€æ ·ï¼Œåˆ™è·³è¿‡æœ¬è½®èµ‹å€¼ï¼Œk+1

```
class Solution {
    public int removeDuplicates(int[] nums) {
        int k = 0;
        for (int i = 1; i < nums.length; i++) {
            if(nums[i-1] != nums[i]){
                nums[i-k] = nums[i];
                // or k++ here, and return k+1
            }else{
                k++;
            }
        }

        return nums.length - k;
    }
}
```



## 27. Remove Element
Tag: Array, Two Pointers 

![image-20230613160127119](./leetcode.assets/image-20230613160127119.png)

```python
# TC: O(n)
# SC: O(1)
class Solution5(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        n = len(nums)
        if n == 0:
            return 0
        valid = 0
        for i in range(n):
            if nums[i] != val:
                nums[valid] = nums[i]
                valid += 1
        
        return valid

        # Or:
        n = len(nums)
        if n == 0:
            return 0
        i = 0
        j = n - 1
        while i != j:
            if nums[i] != val:
                i += 1
            else:
                k = nums[i]
                nums[i] = nums[j]
                nums[j] = k
                j -= 1

        return i+1 if nums[i] != val else i
```

éå†ï¼Œå¢åŠ ä¸€ä¸ªkæ¥è¡¨ç¤ºæœ‰æ•ˆæ•°å­—çš„index

â€‹	å¦‚æœä¸ç­‰äºvalï¼Œåˆ™æŠŠå½“å‰å€¼èµ‹å€¼ç»™kä½ç½®

â€‹	å¦‚æœç­‰äºvalï¼Œåˆ™è·³è¿‡æœ¬è½®èµ‹å€¼

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int k = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] != val){
                nums[k] = nums[i];
                k++;
            }
        }
        return k;
    }
}
```

## 35. Search Insert Position

![image-20250709001237696](./leetcode.assets/image-20250709001237696.png)

èŒƒå›´æ˜¯ [0,...,len-1]çš„è¯ï¼Œè®°ä½æ­¤æ—¶targetæ˜¯å¯ä»¥ç­‰äºå·¦å³çš„

æ‰€ä»¥å½“target<midçš„æ—¶å€™ï¼Œåˆ™targetä¸åœ¨midä¸­ï¼Œæ‰€ä»¥ä¸‹ä¸€æ¬¡rightå°±æ˜¯mid-1

**è®°ä½è‡ªå·±çš„è¾¹ç•Œè¡¨ç¤ºä»€ä¹ˆï¼**

```
    public int searchInsert(int[] nums, int target) {
        
        
        int left = 0;
        int right = nums.length - 1;
        while (left <= right){
            int mid = (right + left) / 2;
            if(target < nums[mid]){
                right = mid-1;
            }else if(target>nums[mid]){
                left = mid+1;
            }else {
                return mid;
            }
        }
        return left;
    }
```



## 48. Rotate Image

![image-20250709001255051](./leetcode.assets/image-20250709001255051.png)

```java
// ä¸€ä¸‹æ—‹è½¬åªé€‚ç”¨nxnçŸ©é˜µ    
// clockwise, å…ˆä¸Šä¸‹å¯¹ç§°ï¼Œå†ijå¯¹è°ƒ
// anticlockwise, å…ˆijå¯¹è°ƒï¼Œå†ä¸Šä¸‹å¯¹ç§°
```

```java
   public void rotate(int[][] matrix){

        // clockwise, å…ˆä¸Šä¸‹å¯¹ç§°ï¼Œå†ijå¯¹è°ƒ
        // anticlockwise, å…ˆijå¯¹è°ƒï¼Œå†ä¸Šä¸‹å¯¹ç§°
        int n = matrix.length;
        for (int i = 0; i < n / 2; i++) {
            int[] temp = matrix[i];
            matrix[i] = matrix[n - 1 - i];
            matrix[n - 1 - i] = temp;
        }

        for (int i = 0; i < matrix.length; i++) {
            for (int j = i; j < matrix.length; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        
        // ç®—å‡ºçš„å…¬å¼ï¼Œä¸å¤ªå»ºè®®ï¼Œä¸å¦‚ä¸‹é¢çš„è§„å¾‹å¥½ç”¨
//        int n = matrix.length;
//        int i=0, j = 0;
//        while (i < n-1){
//            j = i;
//            while(j<n-1-i){
//                int temp = matrix[i][j];
//                matrix[i][j] = matrix[n-1-j][i];
//                matrix[n-1-j][i] = matrix[n-1-i][n-1-j];
//                matrix[n-1-i][n-1-j] = matrix[j][n-1-i];
//                matrix[j][n-1-i] = temp;
//                j++;
//            }
//            i++;
//        }
    }
```

## 54. Spiral Matrix
Tag: Array, Matrix
![image-20230625180740585](./leetcode.assets/image-20230625180740585.png)
```python
class Solution16:
    # TC: (m*n)
    # SC: (1)
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        m = len(matrix) -1
        n = len(matrix[0]) -1
        res = []
        i_start = 0
        j_start = 0
        while True:
            i = i_start
            for j in range(j_start, n + 1, 1):
                res.append(matrix[i][j])
            i_start += 1
            j = n
            for i in range(i_start, m + 1, 1):
                res.append(matrix[i][j])
            n -= 1
            i = m
            if m < i_start or n < j_start:
                break
            for j in range(n, j_start - 1, -1):
                res.append(matrix[i][j])
            m -= 1
            j = j_start
            for i in range(m, i_start - 1, -1):
                res.append(matrix[i][j])
            j_start += 1
            if m < i_start or n < j_start:
                break
        return res
```

æ–¹æ³•1ï¼š

ä¸€åœˆä¸€åœˆç»•

æ–¹æ³•2ï¼š

å¤–é¢åœˆ+å¾€é‡Œä¸€å±‚ï¼Œé€’å½’

```
public List<Integer> spiralOrder(int[][] matrix) {

        // ä¸€åœˆä¸€åœˆç»•
        int top = 0;
        int left = 0;
        int down = matrix.length - 1;
        int right = matrix[0].length - 1;
        List<Integer> l = new ArrayList<>();
        while (top <= down && left<=right){
            for (int i = left; i <= right; i++) {
                l.add(matrix[top][i]);
            }
            top++;
            for (int i = top; i <= down ; i++) {
                l.add(matrix[i][right]);
            }
            right--;

            for (int i = right; i >= left && top <= down; i--) {
                l.add(matrix[down][i]);
            }
            down--;
            for (int i = down; i>= top && left <= right; i--) {
                l.add(matrix[i][left]);
            }
            left++;
        }
        return l;

        // int r = matrix.length;
        // int c = matrix[0].length;

        // int[] tp = {0,0};
        // int[] br =  {r-1, c-1};
        // return order(matrix,tp, br);
    }

    public List<Integer> order(int[][] matrix, int[] topLeft, int[] bottomRight){
        int c = bottomRight[1] - topLeft[1];
        int r = bottomRight[0] - topLeft[0];
        if(c<0 || r<0){
            return null;
        }
        List<Integer> l = new ArrayList<>();
        for (int i = topLeft[1]; i <= bottomRight[1]; i++) {
            l.add(matrix[topLeft[0]][i]);
        }
        for (int i = topLeft[0]+1; i <= bottomRight[0]; i++) {
            l.add(matrix[i][bottomRight[1]]);
        }
        for (int i = bottomRight[1] -1; i >= topLeft[1] && r>0; i--) {
            l.add(matrix[bottomRight[0]][i]);
        }
        for (int i = bottomRight[0] -1; i >= topLeft[0]+1 && c>0; i--) {
            l.add(matrix[i][topLeft[1]]);
        }
        int[] tl = {topLeft[0]+1, topLeft[1]+1};
        int[] br = {bottomRight[0]-1, bottomRight[1]-1};
        List<Integer> nl = order(matrix, tl, br);
        if(nl !=null){
            l.addAll(nl);
        }
        return l;
    }
```



## 56. Merge Intervals

![image-20230622153539388](./leetcode.assets/image-20230622153539388.png)

```java
[[1,4],[0,4]]

[[1,4],[2,3]]

[[2,3],[4,5],[6,7],[8,9],[1,10]]
```

ä»å·¦å¾€å³ï¼Œä¸‹ä¸€ä¸ªçš„0ä½æ¯”ä¸Šä¸€ä½çš„1ä½ä½çš„æ—¶å€™ï¼Œå¯ä»¥çº³å…¥è¿›æ¥ã€‚æ‰€æœ‰å¯ä»¥çº³å…¥è¿›æ¥çš„ï¼Œ1å€¼å–æœ€å¤§

ï¼ˆæ‰€ä»¥å‰æå°±æ˜¯ï¼Œé¦–ä½è¦æ’åºï¼Œè¿™æ ·å¾—åˆ°çš„0ä½æ˜¯æœ€å°çš„ï¼‰

```java
    public int[][] merge(int[][] intervals) {
        List<int[]> al = new ArrayList<>();
        int[] next = new int[2];
        Arrays.sort(intervals, (int[] num1, int[] nums2) -> num1[0] - nums2[0]);
        next = intervals[0];
        for (int i = 1; i < intervals.length; i++) {
            if(intervals[i][0] > next[1]){
                al.add(next.clone());
                next = intervals[i];
            }else{
                next[1] = Math.max(next[1], intervals[i][1]);
            }
        }
        al.add(next);

        return al.toArray(new int[al.size()][]);
    }
```


## 66. Plus One
Tag: Array

![image-20250709001310163](./leetcode.assets/image-20250709001310163.png)

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        n = len(digits)
        add_on = 1
        for i in range(n-1, -1, -1):
            total = digits[i] + add_on
            add_on = total // 10
            rest = total % 10
            digits[i] = rest
        if add_on != 0:
            digits.insert(0, add_on)
        return digits
```



## 73. Set Matrix Zeroes

![image-20250709001332163](./leetcode.assets/image-20250709001332163.png)

æ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªè®°å½•è¯¥è¡Œçš„çŠ¶æ€ï¼ˆæœ‰0åˆ™ç¬¬ä¸€ä½ç½®ä¸º0ï¼‰

ç¬¬ä¸€åˆ—çš„ç¬¬ä¸€ä¸ªè®°å½•è¯¥åˆ—çš„çŠ¶æ€ï¼ˆç”¨colå˜é‡è®°å½•ç¬¬ä¸€åˆ—çš„çŠ¶æ€ï¼Œ00å·²ç»è®°å½•äº†ç¬¬ä¸€è¡Œçš„çŠ¶æ€ï¼‰

```java
   int col = -1;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if(matrix[i][j] == 0){
                    if(j == 0){
                        col = 0;
                    }else{
                        matrix[0][j] = 0;
                    }
                    matrix[i][0] = 0;
                }
            }
        }

        for (int i = matrix.length - 1; i >= 0; i--) {
            for (int j = matrix[0].length -1; j >= 1; j--) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
            if (col == 0) {
                matrix[i][0] = 0;
            }
        }
```



## [75. Sort Colors](https://leetcode.cn/problems/sort-colors/)

![image-20230618174123859](./leetcode.assets/image-20230618174123859.png)

è§£å†³æ€è·¯ï¼Œpartition

![image-20230618174107159](./leetcode.assets/image-20230618174107159.png)

**æ»‘åŠ¨çª—å£**

partition2

[0...zero] = 0

(zero...i] = 1

(i...tow] = æœªçŸ¥

(two...len-1] = 2

è¿˜å¯ä»¥åˆ«çš„åˆ†æ³•ï¼Œå¦‚[i...tow] = æœªçŸ¥ï¼Œè§£ç­”å–å†³äºæ€ä¹ˆpartition

```
        int len = nums.length;
        if (len < 2) {
            return;
        }
        int zero = -1;
        int two = len - 1;
        int i = -1;
        while (i < two) {
            if (nums[i+1] == 0) {
                zero++;
                swap(nums, i+1, zero);
                i++;
            } else if (nums[i+1] == 1) {
                i++;
            } else {
                swap(nums, i+1, two);
                two--;
            }
        }
```



## 80. Remove Duplicates from Sorted Array II

![image-20230618162140197](./leetcode.assets/image-20230618162140197.png)



**æ»‘åŠ¨çª—å£**

```
```

**æ»‘åŠ¨2**

```
    public int removeDuplicates(int[] nums) {
        int k = 0;
        boolean hasShowTwice = false;

        for (int i = 1; i < nums.length; i++) {
            if(nums[k] != nums[i]){
                k++;
                nums[k] = nums[i];
                hasShowTwice = false;
            }else if(!hasShowTwice){
                k++;
                nums[k] = nums[i];
                hasShowTwice = true;
            }
        }

        return k + 1;
    }
```



## 88. Merge Sorted Array
Tag: Array, Two Pointers

![image-20230612175447132](./leetcode.assets/image-20230612175447132.png)

```python
# TC: O(m+n)
# SC: O(1)
class Solution4(object):
    # ä»å³å¾€å·¦

    # å¦‚æœä»å·¦å¾€å³çš„è¯ï¼Œå³ä¾¿åŠ ä¸Šä¸¤ä¸ªæ•°ç»„ä¸­æ•°å­—äº¤æ¢ï¼Œä¹Ÿæ¯æ¬¡éƒ½sort nums2ï¼Œæ¥ä¿è¯nums2æ˜¯ç”¨æœ€å°æ•°å’Œnums1ä¸­çš„æ•°å­—åœ¨åšæ¯”è¾ƒï¼Œå¤æ‚åº¦é«˜
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: None Do not return anything, modify nums1 in-place instead.
        """
        i = m - 1
        j = n - 1
        if n == 0:
            return
        for cur in range(m + n - 1, -1, -1):
            # i -> cur
            if i == -1 or j == -1:
                break
            if nums1[i] >= nums2[j]:
                nums1[cur] = nums1[i]
                i-=1
            else:
                nums1[cur] = nums2[j]
                j-=1
        while j >= 0:
            nums1[j] = nums2[j]
            j-=1
```

**solution 1**

```
 void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
     int i = m - 1, j = n - 1, k = m + n - 1;
     while(i >= 0 and j >= 0) {
         if(nums1[i] < nums2[j]) {
             nums1[k--] = nums2[j--];
         } else {
             nums1[k--] = nums1[i--];
         }
     }
     while(j >= 0) {
         nums1[k--] = nums2[j--];
     }
 }
```



**solution 2**

éå†m+nï¼Œä»å³å¾€å·¦æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„çš„æœ‰æ•ˆä½

â€‹	å¦‚æœæœ‰ä¸€è¾¹å·²ç»å…¨éƒ¨éå†å®Œï¼Œåˆ™åªèµ‹å€¼å¦å¤–ä¸€è¾¹

â€‹	å¦‚æœå·¦è¾¹çš„æ¯”å³è¾¹çš„å¤§

â€‹		èµ‹å€¼å·¦è¾¹çš„åˆ°å½“å‰éå†ä½ç½®

â€‹		å·¦è¾¹æœ‰æ•ˆä½--

â€‹	å¦‚æœå³è¾¹çš„æ¯”å·¦è¾¹çš„å¤§

â€‹		èµ‹å€¼å³è¾¹çš„åˆ°å½“å‰éå†ä½ç½®

â€‹		å³è¾¹æœ‰æ•ˆä½--

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
		int k = m + n;
        for (int i = k - 1; i >= 0; i--) {
            if (m == 0) {
                nums1[i] = nums2[n - 1];
                n--;
                continue;
            }
            if (n == 0) {
                nums1[i] = nums1[m - 1];
                m--;
                continue;
            }
            if (nums1[m - 1] >= nums2[n - 1]) {
                nums1[i] = nums1[m - 1];
                m--;
            } else {
                nums1[i] = nums2[n - 1];
                n--;
            }
        }
    }
}
```



## 118. Pascal's Triangle
Tag: Array, Dynamic Programming

![image-20250709001351802](./leetcode.assets/image-20250709001351802.png)

```python
class Solution:
    # TC: O(n^2)
    # SC: O(1)
    def generate(self, numRows: int) -> List[List[int]]:
        res = [
            [1]
        ]
        if numRows == 1:
            return res
        for i in range(1, numRows, 1):
            last_row = res[i - 1]
            cur_len = i + 1
            cur = [1]
            for j in range(1, len(last_row), 1):
                cur.append(last_row[j] + last_row[j-1])
            cur.append(1)
            res.append(cur)
        return res
```
æ–¹æ³•ï¼š

121 ->

1211 ->

1 (1+2) (2+1) 1



```java
    public List<List<Integer>> generate(int numRows) {

       	List<List<Integer>> l = new ArrayList<>(numRows);
        List<Integer> l0 = new ArrayList<>();
        for (int i = 0; i < numRows; i++) {
            l0.add(1);
            for (int j = l0.size()-2; j >= 1; j--) {
                l0.set(j, l0.get(j)+l0.get(j-1));
            }
            l.add(new ArrayList<>(l0));
        }
        return l;


        //         List<List<Integer>> l = new ArrayList<>(numRows);
        // List<Integer> l0 = new ArrayList<>();
        // l0.add(1);
        // l.add(l0);
        // for (int i = 1; i < numRows; i++) {
        //     List<Integer> tempL = new ArrayList<>(i+1);
        //     tempL.add(1);
        //     List<Integer> lastL = l.get(i-1);
        //     for (int j = 1; j < lastL.size(); j++) {
        //         tempL.add(lastL.get(j-1) + lastL.get(j));
        //     }
        //     tempL.add(1);
        //     l.add(tempL);
        // }
        // return l;
    }
```

## 119. Pascal's Triangle II
Tag: Array, Dynamic Programming
```python
class Solution:
    # TC: O(n^2)
    # SC: O(1)
    def getRow(self, rowIndex: int) -> List[int]:
        res = [1]
        for i in range(0, rowIndex, 1):
            res.append(1)
            n = len(res)
            for j in range(n-2, 0, -1):
                res[j] += res[j-1]
        return res
```

## 189. Rotate Array
Tag: Array, Rotate, Two Pointers
![image-20230630234029078](./leetcode.assets/image-20230630234029078.png)
```python
class Solution:
    # TC: O(n)
    # SC: O(1)
    # Use start and end is better, reduce calculations
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = k % n
        self.rotate_range(nums, 0, n-1)
        self.rotate_range(nums, 0, k - 1)
        self.rotate_range(nums, k, n-1)

    def rotate_range(self, nums: List[int], start: int, end: int) -> None:
        while start < end:
            temp = nums[start]
            nums[start] = nums[end]
            nums[end] = temp
            start += 1
            end -= 1

    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = k % n
        for i in range(n//2):
            temp = nums[i]
            nums[i] = nums[n - 1- i]
            nums[n - 1- i] = temp
        for i in range(k//2):
            temp = nums[i]
            nums[i] = nums[k - 1- i]
            nums[k - 1- i] = temp
        for i in range(k, (n-k)//2 + k, 1):
            temp = nums[i]
            nums[i] = nums[n + k - 1 - i]
            nums[n + k - 1 - i] = temp
```

æ–¹æ³•ï¼š

å…ˆå…¨éƒ¨åè½¬

åè½¬ 0 åˆ° k - 1

åè½¬ k åˆ° æœ€å

```java
    public void rotate(int[] nums, int k) {
        k = k % nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k-1);
        reverse(nums, k, nums.length - 1);

    }

    public void reverse(int[] nums, int start, int end){
        while (start < end){
            int temp = nums[start];
            nums[start++] = nums[end];
            nums[end--] = temp;
        }
    }
```



## 209. Minimum Size Subarray Sum
tag: Array, Two Pointers, Sliding Windows

![image-20250709001419039](./leetcode.assets/image-20250709001419039.png)

```python
class Solution:
    # TC: O(n) right pointer move n times and left pointer move at most n times
    # SC: O(1)
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0 # 0 - n-1
        right = 0 # 1 - n
        n = len(nums)
        sm = 0
        res = float('inf')
        while right < n:
            sm += nums[right]
            right += 1 # is larger than 1 bit
            while sm >= target:
                res = min(res, right - left)
                sm -= nums[left]
                left += 1
        return 0 if res == float('inf') else res

    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0 # 0 - n-1
        right = 1 # 1 - n
        n = len(nums)
        sm = 0
        res = n
        while left < right and right <= n:
            while sm < target and right <= n:
                sm += nums[right-1]
                right += 1
            if sm < target:
                return res if res != n else 0
            while sm >= target and left < right:
                sm -= nums[left]
                left += 1
            res = min(res, right - left)
        return res
```

æ–¹æ³•1ï¼š

ä¸€ä¸ªä¸€ä¸ªåŠ ï¼Œç„¶ååˆ¤æ–­

æ–¹æ³•2ï¼š

å³æŒ‡é’ˆç›´æ¥åŠ åˆ°å¤§äºç­‰äºtargetçš„åœ°æ–¹ï¼Œ

å·¦æŒ‡é’ˆç›´æ¥å‡åˆ°å°äºtargetçš„åœ°æ–¹

```
    public int minSubArrayLen(int target, int[] nums) {
        int min = Integer.MAX_VALUE;
        int sum = 0;
        int j = 0;
        int i = 0;
        while (j < nums.length){
            sum += nums[j++];
            while (sum >= target){
                sum -= nums[i++];
                min = Math.min(min, j-i+1);
            }
        }
        return min == Integer.MAX_VALUE ? 0: min;

//  int left = 0, right = 0;
//         int min = Integer.MAX_VALUE;
//         int sum = 0;
//         while (left < nums.length && right<nums.length){
//             while (right < nums.length && sum < target){
//                 sum += nums[right];
//                 right++;
//             }
//             if(left == 0 && right == nums.length && sum < target){
//                 return 0;
//             }
//             while (left<nums.length && sum >= target){
//                 sum -= nums[left];
//                 left++;
//             }

//             min = Math.min(min, right-left+1);
//         }
//         return min;
    }
```

## 287. Find the Duplicate Number
Tag: Array, Floydâ€™s Cycle Detection
```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # no change nums and const extra space
        slow = 0
        fast = 0

        slow = nums[slow]
        fast = nums[nums[fast]]

        while nums[slow] != nums[fast]:
            slow = nums[slow]
            fast = nums[nums[fast]]

        slow = 0
        while nums[slow] != nums[fast]:
            slow = nums[slow]
            fast = nums[fast]
        return nums[slow]
```

## 283. Move Zeroes
Tag: Array
![image-20230614214439581](leetcode.assets/image-20230614214439581.png)


```python
# TC: O(n)
# SC: O(1)
class Solution(object):
    def moveZeroes(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        cur = 0
        n = len(nums)
        for i in range(n):
            if nums[i] != 0:
                temp =nums[cur]
                nums[cur] = nums[i]
                nums[i] = temp
                cur+=1

        # cur = 0
        # n = len(nums)
        # for i in range(n):
        #     if nums[i] != 0:
        #         nums[cur] = nums[i]
        #         cur += 1

        # for j in range(cur, n, 1):
        #     nums[j] = 0
```


å’Œ26é¢˜ä¸€æ ·çš„è§£æ³•

```java
    public void moveZeroes(int[] nums) {
        int position = 0;

        for (int i = 0; i < nums.length; i++) {
            if(nums[i] != 0){
                nums[position] = nums[i];
                position ++;
            }
        }

        for (int i = position; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
```

æˆ–è€…ï¼š

ä»å·¦åˆ°å³ï¼Œé‡åˆ°ä¸æ˜¯0çš„ï¼Œåˆ™ä¸æœ€å·¦è¾¹çš„0äº¤æ¢ï¼Œä¸€ç›´åˆ°ç»“å°¾

```java
        int snowBallSize = 0;
        for (int i=0;i<nums.length;i++){
            if (nums[i]==0){
                snowBallSize++;
            }
            else if (snowBallSize > 0) {
                int t = nums[i];
                nums[i]=0;
                nums[i-snowBallSize]=t;
            }
        }
```





## 414. Third Maximum Number
Tag: Array

![image-20250709001437210](./leetcode.assets/image-20250709001437210.png)

```python
# TC: O(n)
# SC: O(1)
class Solution(object):
    def thirdMax(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        m1 = None
        m2 =None
        m3 =None
        for ele in nums:
            if ele == m1 or ele == m2 or ele == m3:
                continue
            if m1 is None or ele > m1:
                m3 = m2
                m2 = m1
                m1 = ele
            elif m2 is None or ele > m2:
                m3 = m2
                m2 = ele
            elif m3 is None or ele> m3:
                m3 = ele
        return m1 if m3 is None else m3
```




æ–¹æ³•1ï¼š

å…ˆsortï¼Œç„¶åç”¨HashSetæ¥è£…æ‰€æœ‰çš„å…ƒç´ 

å¦‚æœsetå¤§äºç­‰äº3ï¼Œåˆ™å–å€’æ•°ç¬¬ä¸‰ä¸ªå€¼

å¦åˆ™ï¼Œå–æœ€å¤§çš„å€¼


a


æ–¹æ³•2ï¼š

ç”¨ä¸‰ä¸ªå˜é‡æ¥æ ‡è®°ä¸‰ä¸ªæœ€å¤§çš„å€¼

åœ¨éå†çš„æ—¶å€™

â€‹	è‹¥æŸä¸€ä¸ªæœ€å¤§å€¼ä¸ºç©ºæˆ–è€…å¤§äºæŸä¸€ä¸ªæœ€å¤§å€¼ï¼Œåˆ™å˜æ›´å‰ä¸‰å¤§æ•°å­—



```
    public int thirdMax(int[] nums) {
        //         Arrays.sort(nums);
        // HashSet<Integer> hs = new HashSet<Integer>();
        // for (int i = nums.length - 1; i > -1 ; i--) {
        //     hs.add(nums[i]);
        //     if(hs.size() == 3){
        //         return nums[i];
        //     }
        // }
        // return nums[nums.length -1];

        Integer first = null;
         Integer second = null;
         Integer third = null;
         for (Integer num : nums) {
             if(num.equals(first) || num.equals(second) || num.equals(third)){
                    continue;
             }
             if(first == null || num > first){
                 third = second;
                 second = first;
                 first = num;
             }else if(second == null || num > second){
                 third = second;
                 second = num;
             } else if (third == null ||num > third) {
                 third = num;
             }
         }


         return third == null ? first : third;

    }
```





## 448. Find All Numbers Disappeared in an Array
Tag: Array, Cyclic Sort
![image-20230616193351698](leetcode.assets/image-20230616193351698.png)


```python
# TC: O(n)
# SC: O(n)
class Solution(object):
    def findDisappearedNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        n = len(nums)
        output = [0] * (n + 1)
        for ele in nums:
            output[ele] = 1
        res = []
        for i in range(1, len(output), 1):
            if output[i] == 0:
                res.append(i)
        return res

# Iterate each positions value as its an index
# TC: O(2n) -> O(n)
# SC: O(1)
class Solution(object):
    def findDisappearedNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        n = len(nums)
        for i in range(n):
            cur = i
            nv = nums[cur]
            while nv != cur + 1:
                temp = nums[nv - 1]
                nums[nv - 1] = nv
                cur = nv - 1
                nv = temp
        res = []
        for i in range(n):
            if nums[i] != i + 1:
                res.append(i + 1)
        return res
```



æ–¹æ³•0ï¼š

éå†

â€‹	æŠŠç¬¬iä½ä¸å…¶è¯¥åœ¨çš„ä½ç½®äº¤æ¢ ----> ä¸€ç›´æ¢åˆ°ç¬¬iä½æ­£ç¡®ï¼Œæˆ–è€…ç¬¬iä½ä¸å…¶è¯¥åœ¨çš„ä½ç½®æ•°å­—ä¸€æ ·æ‰åœæ­¢  `!(nums[i] == i+1 || nums[i] == nums[nums[i] - 1])`

éå†æ‰¾å‡ºç¬¬iä½ä¸æ˜¯i+1çš„æ•°å­—

```java
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i] != i+1 && nums[i] != nums[nums[i] - 1]){
                int temp = nums[nums[i] - 1]; // è°ƒæ¢è®°å¾—å…ˆè°ƒæ¢ä¸å½±å“nums[i]å€¼çš„é‚£ä¸ªæ•°å­—ï¼Œå¦åˆ™è°ƒæ¢å¤±è´¥
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }
        ArrayList<Integer> al = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] != i+1){
                al.add(i+1);
            }
        }
        return al;
    }
```



æ–¹æ³•1ï¼š

æŠŠnums[i] çš„å€¼çœ‹æˆindexï¼ŒæŠŠå¯¹åº”ä½æ•°çš„æ•°å­—å˜æˆè´Ÿæ•°æ¥è¡¨ç¤ºè¯¥ä½æœ‰æ•°

```java
	public List<Integer> findDisappearedNumbers(int[] nums) {
			for (int i = 0; i < nums.length; i++) {
            int index;
            if (nums[i] < 0) {
                index = nums[i] * -1 -1;
            }else{
                index = nums[i]-1;
            }
            
            nums[index] = nums[index] < 0 ? nums[index] : nums[index] * -1;
        }

        ArrayList<Integer> al = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] > 0){
                al.add(i+1);
            }
        }
        return al;
    }
```



æ–¹æ³•2ï¼š

ç”¨ä¸€ä¸ªé•¿åº¦ç›¸å½“çš„æ–°çš„æ•°ç»„ï¼Œç”¨å®ƒçš„indexæœ‰å€¼æ¥è¡¨ç¤ºåŸæ¥æ•°ç»„çš„æŸä¸ªä½ç½®æœ‰æ•°

ç„¶åæŸ¥æ‰¾ä»1-nï¼Œæ²¡æœ‰è¢«æ ‡è®°çš„indexä¸ºæ²¡æœ‰å‡ºç°çš„æ•°å­—

```java
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int[] resultArr = new int[nums.length + 1];
        for (int num:
             nums) {
            resultArr[num] = 1;
        }
        ArrayList<Integer> resultList = new ArrayList<>();

        for (int i = 1; i < nums.length + 1; i++) {
            if(resultArr[i] != 1){
                resultList.add(i);
            }
        }
        return resultList;
    }
```





## [485. Max Consecutive Ones](https://leetcode.com/problems/max-consecutive-ones/)
tag: Array, Two Pointers, Sliding Window

![image-20250709001457325](./leetcode.assets/image-20250709001457325.png)

```python
# TC: O(n)
# SC: O(1)
class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        max_value = 0
        cur_value = 0
        for ele in nums:
            if ele == 1:
                cur_value += 1
                max_value = max(max_value, cur_value)
            else:
                cur_value = 0
        return max_value

# TC: O(n)
# SC: O(1)
class Solution1(object):
    def findMaxConsecutiveOnes(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        left = 0
        right = 0
        max_cons = 0
        nums_len = len(nums)
        while left < nums_len:
            left = right
            while left < nums_len and nums[left] == 0:
                left += 1
            right = left
            while right < nums_len and nums[right] == 1:
                right += 1
            max_cons = max(max_cons, right - left)
        return max_cons
```


```java
    public int findMaxConsecutiveOnes(int[] nums) {
    // åŒæŒ‡é’ˆ
        int start = 0;
        int right = 0;
        int max = 0;
        while (start<nums.length && right<nums.length){
            start = right;
            while (start<nums.length && nums[start] == 0){start++;}
            right = start;
            while (right<nums.length && nums[right] == 1){right++;}
            max = Math.max(right-start, max);
        }
        return max;
   // ä¸€èˆ¬è§£æ³•
        int max = 0;
        int count = 0;
        for(int i: nums){
            count = i == 1 ? count + 1 : 0;
            max = count > max ? count : max;
        }
        return max;
    }
```



## [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/)





![image-20230618105323042](./leetcode.assets/image-20230618105323042.png)



```java
        int[] pre = new int[nums.length];
        int[] suff = new int[nums.length];
		// pre
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] == 1){
                if(i == 0){
                    pre[i] = 1;
                }else{
                    pre[i] = pre[i-1] + 1;
                }
            }else{
                pre[i] = 0;
            }
        }
		// suff
        for (int i = nums.length - 1; i >= 0; i--) {
            if(nums[i] == 1){
                if(i == nums.length - 1){
                    suff[i] = 1;
                }else{
                    suff[i] = suff[i+1] + 1;
                }
            }else{
                suff[i] = 0;
            }
        }
		// all 1: [1,1,1,1]
        if(pre[nums.length - 1] == nums.length){
            return nums.length;
        }
		// pre+i0+suff
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] == 0){
                int len = 0;
                // ä¸‹é¢è¿™ç§å†™æ³•è€ƒè™‘åˆ°äº† 0 å’Œ n-1çš„æƒ…å†µ
                if(i > 0) {
                    len+=pre[i-1];
                }
                if(i < nums.length -1){
                    len+=suff[i+1];
                }
                ans = Math.max(len + 1, ans);
            }
        }
        return ans;
```

## 498. Diagonal Traverse
## 498. Diagonal Traverse
Tag: Array, Matrix
![image-2025062649801](./leetcode.assets/image-2025062649801.png)

```python
**class Solution:
    # TC: O(m*n)
    # SC: O(1)
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        m = len(mat)
        n = len(mat[0])
        i = 0
        j = 0
        res = []
        while True:
            res.append(mat[i][j])
            if i == m - 1 and j == n - 1:
                break
            if (i + j) % 2 == 0:
                if i == 0 or j == n - 1:
                    if j < n - 1:
                        j += 1
                    else:
                        i += 1
                else:
                    i -= 1
                    j += 1
            else:
                if i == m - 1 or j == 0:
                    if i < m - 1:
                        i += 1
                    else:
                        j += 1
                else:
                    i += 1
                    j -= 1
        return res
        return res
```

## 724. Find Pivot Index
Tag: Array
![image-20230622105748130](./leetcode.assets/image-20230622105748130.png)

![image-20230622105816122](./leetcode.assets/image-20230622105816122.png)

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        # TC: O(n)
        # SC: O(1)
        r_sum = 0
        for ele in nums:
            r_sum += ele
        l_sum = 0
        n = len(nums)
        for i in range(n):
            r_sum -= nums[i]
            if i > 0:
                l_sum += nums[i-1]
            if l_sum == r_sum:
                return i
        return -1
```

```java
  public int pivotIndex(int[] nums) {
  
  // è¿™ä¸ªæ²¡æœ‰è€ƒè™‘è´Ÿæ•°ï¼Œä»¥ä¸ºä¸¤è¾¹éƒ½æ˜¯æ­£æ•°ï¼Œå®¡é¢˜ï¼
//        int sum1 = 0;
//        int sum2 = 0;
//        int left = 0;
//        int right = nums.length - 1;
//
//        while (left<right){
//            if(sum1 >= sum2){
//                sum2 += nums[right--];
//            }else {
//                sum1 += nums[left++];
//            }
//        }
//
//        if(sum1 == sum2){
//            return left;
//        }
//        return -1;

        int sum = 0;
        for (int num :
                nums) {
            sum += num;
        }
        int left = 0;
        for (int i = 0; i < nums.length; i++) {
            if(i != 0){
                left += nums[i-1];
            }
            sum -= nums[i];
            if(left == sum){
                return i;
            }
        }

        return -1;
    }
```

## 747. Largest Number At Least Twice of Others
Tag: Array

![image-20250709001525817](./leetcode.assets/image-20250709001525817.png)

```python
class Solution:
    # TC: O(n)
    # SP: O(1)
    def dominantIndex(self, nums: List[int]) -> int:
        l = None
        l2 = None
        idx = -1
        n = len(nums)
        for i in range(n):
            ele = nums[i]
            if l is None:
                l = ele
                idx = i
            else:
                if ele > l:
                    l2 = l
                    l = ele
                    idx = i
                elif l2 is None:
                    l2 = ele
                elif ele > l2:
                    l2 = ele
        return idx if l >= l2*2 else -1
```

## 905. Sort Array By Parity
Tag: Array, Two Pointers

![image-20250709001542586](./leetcode.assets/image-20250709001542586.png)

```python
# TC: O(n)
# SC: O(1)
class Solution(object):
    def sortArrayByParity(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        cur = 0
        n = len(nums)
        for i in range(n):
            if nums[i] %2 == 0:
                temp = nums[i]
                nums[i] = nums[cur]
                nums[cur] = temp
                cur += 1
        return nums
```
éå†ï¼Œç”¨positionæ ‡è®°ä¸‹ä¸€ä¸ªå¶æ•°æ”¾çš„ä½ç½®

â€‹	å¦‚æœé‡åˆ°å¶æ•°ï¼Œä¸positionäº¤æ¢ï¼Œposition++



```
        int position = 0;
        for (int i = 0; i < nums.length; i++) {
            if(nums[i] % 2 == 0){
                int temp = nums[position];
                nums[position] = nums[i];
                nums[i] = temp;
                position++;
            }
        }
        return nums;
```



åˆ›å»ºæ–°æ•°ç»„ï¼Œéå†ï¼Œä½¿ç”¨ä¸€å¤´ä¸€å°¾ä¸¤ä¸ªindexè¡¨ç¤ºå¶æ•°ä¸éå¶æ•°çš„ä½ç½®

â€‹	å¦‚æœé‡åˆ°å¶æ•°ï¼Œæ”¾å¼€å¤´

â€‹	å¦‚æœä¸æ˜¯å¶æ•°ï¼Œæ”¾ç»“å°¾

```
		int[] result = new int[nums.length];
        int position = 0;
        int none = nums.length - 1;
        for (int num : nums) {
            if (num % 2 == 0) {
                result[position++] = num;
            }else{
                result[none--] = num;
            }
        }

        return result;
```



## 941. Valid Mountain Array
Tag: Array, Two Pointers

![image-20250709001606788](./leetcode.assets/image-20250709001606788.png)

```python
# TC: O(n)
# SC: O(1)
class Solution8(object):
    def validMountainArray(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        up = 0
        n = len(arr)
        down = n - 1
        while up < n - 1:
            if arr[up] < arr[up+1]:
                up += 1
            else:
                break

        while down > 0:
            if arr[down] < arr[down-1]:
                down-=1
            else:
                break
        return True if up == down and up > 0 and down < n - 1 else False
```

ä»å¤´å¼€å§‹æŸ¥ï¼Œå‡åºåˆ°å°½å¤´çš„index1

ä»å°¾å¼€å§‹æŸ¥ï¼Œé™åºåˆ°å°½å¤´çš„index2

æ¯”è¾ƒä¸¤ä¸ªindexï¼Œä¸”ä¸æ˜¯ä¸¤å¤´æ—¶ï¼Œåˆ™æ—¶mountain array

solution

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        int n = arr.length;
        int i = 0;
        int j = n-1;
        while (i+1 < n && arr[i] < arr[i+1]){
            i++;
        }
        while(j-1 >= 0 && arr[j] < arr[j-1]){
            j--;
        }
        return i > 0 && j < n-1 && i == j;
    }
}
```

solution 1

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        
        int maxIndex = 0;
        boolean up = false;
        boolean down = false;
        for (int i = 0; i < arr.length; i++) {
            if(arr[maxIndex] < arr[i]){
                maxIndex = i;
            }
        }
        for(int i = 1; i <= maxIndex; i++){
            if(arr[i] <= arr[i-1]){
                return false;
            }
            up = true;
        }

        for(int i = maxIndex+1; i < arr.length; i++){
            if(arr[i] >= arr[i-1]){
                return false;
            }
            down = true;
        }
        return up && down;
    }
}
```

solution 2

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        if(arr.length < 3){
            return false;
        }
        boolean door = true;
        boolean up = false;
        boolean down = false;
        for (int i = 1 ; i < arr.length; i++) {
            if(arr[i] == arr[i-1]){
                return false;
            }
            if(door){
                if(arr[i] > arr[i-1]){
                    up = true;
                }else{
                    door = false;
                    down = true;
                }
            }else{
                if(arr[i] > arr[i-1]){
                    return false;
                }
            }
        }
        return up && down;
    }
}
```



## [977. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/)
Tag: Array, Two Pointers
![image-20230617170845425](./leetcode.assets/image-20230617170845425.png)

```python
# from ends to middle
# TC: O(n)
# SC: O(n)
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        left = 0
        right = len(nums) - 1
        res = [0] * len(nums)
        i = right
        while left <= right:
            if nums[left] ** 2 < nums[right] ** 2:
                res[i] = nums[right] ** 2
                right -= 1
            else:
                res[i] = nums[left] ** 2
                left += 1
            i -= 1
        return res

# from middle to two ends
# TC: O(n)
# SC: O(n)
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        nums_len = len(nums)
        left = 0
        right = 0
        res = [0] * nums_len
        i = 0
        for index in range(nums_len):
            if nums[index] < 0:
                left = index
                continue
            else:
                break
        right = left + 1
        while left >= 0 and right < nums_len:
            if nums[left]**2 < nums[right]**2:
                res[i] = nums[left]**2
                left -= 1
            else:
                res[i] = nums[right]**2
                right += 1
            i+=1
        while left >= 0:
            res[i] = nums[left] ** 2
            left -= 1
            i += 1
        while right < nums_len:
            res[i] = nums[right] ** 2
            right += 1
            i += 1
        return res


```


ç”¨ä¸¤ä¸ªæŒ‡é’ˆæ ‡è®°å¤´å’Œå°¾ï¼Œæ¯”è¾ƒä»–ä»¬çš„ç»å¯¹å€¼å¤§å°ï¼Œä»resultæ•°ç»„çš„ç»“å°¾å¼€å§‹èµ‹å€¼



```
    public int[] sortedSquares(int[] nums) {
        int i = 0;
        int j = nums.length - 1;

        int[] result = new int[nums.length];
        for (int k = nums.length - 1; k >= 0; k--) {
            if(Math.abs(nums[i]) > Math.abs(nums[j])){
                result[k] = nums[i] * nums[i];
                i++;
            }else{
                result[k] = nums[j] * nums[j];
                j--;
            }
        }
        return  result;
    }
```





## [1089. Duplicate Zeros](https://leetcode.com/problems/duplicate-zeros/)
Tag: Array, Two Pointers
![image-20230612171217969](./leetcode.assets/image-20230612171217969.png)

```python
# TC: O(n)
# SC: O(1)
class Solution3(object):
    def duplicateZeros(self, arr):
        """
        :type arr: List[int]
        :rtype: None Do not return anything, modify arr in-place instead.
        """
        i = 0
        zeros = 0
        last_zero = False
        n = len(arr)
        while i + zeros < n:
            if arr[i] == 0:
                if i + zeros == n - 1:
                    last_zero = True
                else:
                    zeros += 1
            i += 1
        j = n - 1
        while j >= 0:
            if j == n - 1 and last_zero:
                arr[j] = 0
                j -= 1
                continue
            if arr[j - zeros] == 0:
                arr[j] = 0
                arr[j - 1] = 0
                zeros -= 1
                j -= 2
            else:
                arr[j] = arr[j - zeros]
                j -= 1

```



1. ç®—å‡ºä¸€å…±å¾€å³è¾¹ç§»åŠ¨äº†å‡ ä½ï¼Œç”¨ä¸¤ä¸ªå˜é‡æ¥è®°å½•

   1. ç¬¬ä¸€ä¸ªå˜é‡è®°å½•å¾€å³è¾¹ç§»åŠ¨äº†å‡ ä½
   2. ç¬¬äºŒä¸ªå˜é‡è®°å½•ç‰¹æ®Šæƒ…å†µï¼Œå³å½“ä¸­é—´æŸä¸€ä½0è¢«ç§»åŠ¨åˆ°æœ€åä¸€ä½æ—¶ï¼Œä¸ç”¨å¤åˆ¶0ï¼ˆå› ä¸ºå·²ç»è¾¾åˆ°æ•°ç»„çš„æœ€åï¼‰

   è¿‡ç¨‹ï¼š

   éå†çš„é•¿åº¦ä»0åˆ° æ€»é•¿åº¦ - ç§»åŠ¨çš„ä½æ•°

   â€‹	å¦‚æœé‡åˆ°0

   â€‹		å¦‚æœæ­¤æ—¶æ˜¯ æ€»é•¿åº¦ - ç§»åŠ¨çš„ä½æ•° ----> åˆ™ä¸Šè¿°ç¬¬äºŒä¸ªå˜é‡ä¸ºtrueï¼Œå³æœ€åä¸€ä½ä¸ºä¸ç”¨å¤åˆ¶çš„0

   â€‹		å¦‚æœä¸æ˜¯ æ€»é•¿åº¦ - ç§»åŠ¨ä½æ•° ----> åˆ™ç¬¬ä¸€ä¸ªå˜é‡++

2. ä»æ•°ç»„æœ€å³è¾¹å¼€å§‹èµ‹å€¼ï¼Œä»å³åˆ°å·¦éå†

   â€‹	å¦‚æœæ˜¯æœ€åä¸€ä½ï¼Œä¸”å˜é‡2ä¸ºtrue ----> åˆ™åªèµ‹å€¼æœ€åä¸€ä½ä¸º0ï¼Œè¿›å…¥ä¸‹ä¸€è½®å¾ªç¯

   â€‹	ï¼ˆå…¶å®æ­¤æ—¶é‡Œé¢æœ‰å¦ä¸€ä¸ªå¾ªç¯ï¼Œæ˜¯ä»é•¿åº¦ - ä½ç§»ï¼Œåˆ°0çš„å¾ªç¯ï¼‰

   â€‹	å¦‚æœé•¿åº¦ - ä½ç§»æ˜¯0

   â€‹		èµ‹å€¼å½“å‰ä½æ•°å’Œä¸Šä¸€ä½ä¸º0

   â€‹		å¤–å¾ªç¯å‡å°‘ä¸€è½®

   â€‹		ä½ç§»å‡å°‘1

   â€‹	å¦‚æœä¸æ˜¯0

   â€‹		å½“å‰æ•°ç»„ä¸º = é•¿åº¦ - ä½æ•°çš„æ•°ç»„å€¼

   ```java
   class Solution {
       public void duplicateZeros(int[] arr) {
           if(arr.length == 1){
               System.out.println(arr[0]);
               return;
           }
   
           int leftShift = 0;
           boolean isZeroEndButNotDouble = false;
           for(int i = 0; i < arr.length - leftShift; i++){
               if(arr[i] == 0){
                   if(i == arr.length - leftShift - 1){
                       isZeroEndButNotDouble = true;
                       break;
                   }
                   leftShift++;
               }
           }
   
           for(int j = arr.length - 1; j >= 0; j--){
               if(j == arr.length - 1 && isZeroEndButNotDouble){
                   arr[j] = 0;
                   continue;
               }
               if(arr[j - leftShift] == 0){
                   arr[j] = 0;
                   leftShift--;
                   j--;
                   arr[j] = 0;
               }else{
                   arr[j] = arr[j - leftShift];
               }
           }
   
       }
   }
   ```

   

## [1295. Find Numbers with Even Number of Digits](https://leetcode.com/problems/find-numbers-with-even-number-of-digits/)

Tag: Array

![image-20250709001623086](./leetcode.assets/image-20250709001623086.png)


```python
# TC: O(n)
# SC: O(1)
class Solution(object):
    def findNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        count = 0
        for ele in nums:
            if len(str(ele)) % 2 == 0:
                count += 1
        return count
```


## 1299. Replace Elements with Greatest Element on Right Side
Tag: Array
![image-20230614152908705](leetcode.assets/image-20230614152908705.png)

```python
# TC: O(n)
# SC: O(1)
class Solution9(object):
    def replaceElements(self, arr):
        """
        :type arr: List[int]
        :rtype: List[int]
        """
        # 1. Two for loop, find the biggest
        # 2. From right to left
        max_value = -1
        n = len(arr)
        for i in range(n-1, -1, -1):
            if arr[i] > max_value:
                # switch
                temp = max_value
                max_value = arr[i]
                arr[i] = temp
            else:
                arr[i] = max_value
        return arr
```

ä»å³å¾€å·¦éå†ï¼Œç”¨maxè®°å½•å³è¾¹æœ€å¤§å€¼

â€‹	å¦‚æœå½“å‰å€¼æ¯”æœ€å¤§å€¼å¤§ï¼Œä¸¤ä¸ªå€¼æ›¿æ¢

```
    public int[] replaceElements(int[] arr) {

        int max = -1;
        for (int i = arr.length - 1; i >= 0 ; i--) {
            if(arr[i] > max){
                int tempMax = arr[i];
                arr[i] = max;
                max = tempMax;
            }else{
                arr[i] = max;
            }
        }
        return arr;
    }
```





## 1346. Check If N and Its Double Exist
Tag: Array

![image-20230613163829541](./leetcode.assets/image-20230613163829541.png)

```python
# TC: O(n)
# SC: O(n)
class Solution7(object):
    def checkIfExist(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        s = set()
        for ele in arr:
            if ele * 2 in s or (ele % 2 == 0 and ele // 2 in s):
                return True
            else:
                s.add(ele)
        return False
```


**solution 1**

åˆ©ç”¨hashset

å¦‚æœé‡Œé¢æœ‰å½“å‰æ•°å­—çš„ä¸€åŠæˆ–è€…ä¸¤å€ï¼Œåˆ™ä¸ºtrueï¼Œå¦åˆ™æ·»åŠ è¿›å»

```

```





**solution 2**

ezé¢˜ç›®ï¼Œä¸€ä¸ªä¸€ä¸ªæ‰¾å°±è¡Œ

O(n^2)

éå†

â€‹	å¦‚æœå½“å‰å€¼çš„2å€åœ¨æ•´ä¸ªåˆ—è¡¨ä¸­ï¼ˆå†éå†ï¼‰æœ‰çš„è¯ï¼Œåˆ™è¿”å›true

éƒ½æ²¡æœ‰ï¼Œè¿”å›false

```java
class Solution {
    public boolean checkIfExist(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            if(checkn(arr, i)){
                return true;
            }
        }
        return false;
    }

    public static boolean checkn(int[] arr, int index){
        for (int i = 0; i < arr.length; i++) {
            if(i == index){
                continue;
            }
            if(arr[i] == arr[index]*2){
                return true;
            }
        }
        return false;
    }
}
```



# String (Python)

```python
# 1. compare
'aaa' == 'aaa' # True
# 2. Concatenate
s1 = "hello"
s1 += " world"
# 3. Find character
idx = s1.find('o') # first occurrence
idx = s1.rfind('o') # last occurrence
# 4. Substring
s1[6:11] # from inclusive, end exclusive
# 5. toCharArray
char_list = list(s1)
char_list[4]
# Convert back to string
"".join(char_list)
# 6. StringBuilder, use string and list


# 7. Convert int to str
n = 1
s = str(1)
>>> s
>>> "1"
s = int(s)
>>> 1
# 8. Convert char to int
>>> ord('a')
>>> 97
>>> ord('a') - ord('0')
>>> 0
a = '0'
ord(a) - ord('0') # 0
ord(a) - ord('0') # 0
# 9. Sort string
# sorted and reversed return an iterator
"".join(sorted(s))
"".join(reversed(s))
# 10. format string
'''
{[å˜é‡]:[å¡«å……][å¯¹é½][å®½åº¦][,][.ç²¾åº¦][ç±»å‹]}
å¡«å……ï¼š
é»˜è®¤ä¸å¡«å……
- 0ï¼šå¡«å……0

å¯¹é½ï¼š
é»˜è®¤æœ‰å¯¹é½
- <: å·¦å¯¹é½
- ^: å±…ä¸­
- >: æœ‰å¯¹é½

å®½åº¦ï¼š
é»˜è®¤åŸå§‹å®½åº¦
- æ•°å­—ï¼šæ€»å®½åº¦ï¼ŒåŒ…æ‹¬å°æ•°ç‚¹ï¼Œä¸åŒ…æ‹¬åƒåˆ†ä½åˆ†éš”

åˆ†éš”ç¬¦ï¼š
- .: å°æ•°ç‚¹åˆ†éš”
- ,: åƒåˆ†ä½åˆ†éš”

ç²¾åº¦ï¼š
- æ•°å­—ï¼šå°æ•°ç‚¹åä¿ç•™çš„ä½æ•°

ç±»å‹ï¼š
- fï¼šå›ºå®šç‚¹ï¼ˆå°æ•°ï¼‰
- e / Eï¼šç§‘å­¦è®¡æ•°æ³•
- g / Gï¼šè‡ªåŠ¨é€‰æ‹©ç§‘å­¦è®¡æ•°æˆ–æµ®ç‚¹
- dï¼šæ•´æ•°
- o/x/bï¼šå…«è¿›åˆ¶/åå…­è¿›åˆ¶/äºŒè¿›åˆ¶
'''
x = 3.14159
print("{:.2f}".format(x))   # è¾“å‡º: 3.14
print(f"{x:.2f}")           # f-string å†™æ³•ï¼š3.14

print(f"{x:08.2f}") # 00003.14 æœ€åè¾“å‡ºçš„æ€»å®½åº¦ï¼Œæœ€å°‘æ˜¯8ï¼ŒåŒ…æ‹¬å°æ•°ç‚¹ã€‚å¦‚æœæ•´æ•°è¿‡å¤šï¼Œåˆ™ä¼šè¶…å‡º8ä½
print(f"{'hi':*>6}")  # è¾“å‡º: '****hi'ã€‚å­—ç¬¦ä¸²çš„formatä¸­ï¼Œå¯ä»¥ç”¨ä»»æ„å•ä¸ªå­—ç¬¦ä½œä¸ºè¡¥å……

print(f"{5:031b}") # 0æ˜¯è¡¥å……ï¼Œ31æ˜¯å®½åº¦ï¼Œbæ˜¯ç±»å‹
```

# String

## Compare and substring

```java
// compare using equals
System.out.println("s1 and s2: " + s1.equals(s2));
// compare using compareTo
System.out.println("s1 and s2: " + (s1.compareTo(s2) == 0));

String s1 = "Hello World";
// 1. concatenate
s1 += "!";
System.out.println(s1);
// 2. find
System.out.println("The position of first 'o' is: " + s1.indexOf('o'));
System.out.println("The position of last 'o' is: " + s1.lastIndexOf('o'));
// 3. get substring
System.out.println(s1.substring(6, 11));
//For instance, if the length of the string is N, the time complexity of both finding operation and substring operation is O(N).
```

## toCharArray

```java
// If you want your string to be mutable, there are some substitutions:
String s = "Hello World";
char[] str = s.toCharArray();
str[5] = ',';
System.out.println(str);

// revert char[] back to string
new String(str); // better
// or
String.valueOf(str);
```

## StringBuilder

```java
//  If you have to concatenate strings often, it will be better to use some other data structures like StringBuilder. The below code runs in O(n) complexity.
int n = 10000;
StringBuilder str = new StringBuilder();
StringBuilder str = new StringBuilder("ABCD");
// using stringbuilder, time complexity is O(n), if using str +=, time complexity is O(n^2)
for (int i = 0; i < n; i++) {
    str.append("hello");
}
String s = str.toString();

// append
str.append("hello");

// index char by index
char c = str.charAt(0);

// delete substring
str.delete(0,2);

// indexOf, lastIndexOf
// length
int l = str.length();

// toString
str.toString();
```

## String, Integer, int

```java
// String to int
String str = "123";
int num = Integer.parseInt(str);
// String to Integer;
Integer num = Integer.valueOf(str);
// int to String;
String s = String.valueOf(num);
String s = Integer.toString(num);
String s = num + "";
```

## char, int

```java
// char æ˜¯åŸºäº Unicode çš„å­—ç¬¦ç¼–ç ï¼Œè€Œå­—ç¬¦åœ¨åº•å±‚å®é™…ä¸Šè¢«è¡¨ç¤ºä¸ºæ•´æ•°ï¼ˆchar çš„æ•°å€¼èŒƒå›´æ˜¯ 0 åˆ° 65535ï¼‰ï¼Œintåˆ™è¡¨ç¤º -2^31 åˆ° 2^31-1ï¼Œåœ¨ç®—æ•°è¿ç®—å’Œæ¯”è¾ƒæ—¶ï¼Œcharä¼šè‡ªåŠ¨è½¬æ¢ä¸ºintï¼Œè¿™æ˜¯å®‰å…¨çš„ã€‚
char a = '0';
int num = a - '0';
'h' == 104; // true

```

## Sort String

```java
    String sortString(String s){
        char[] cs = s.toCharArray();
        Arrays.sort(cs);
        return new String(cs);
    }
```









## 5. Longest Palindromic Substring

![image-20230623220147856](./leetcode.assets/image-20230623220147856.png)

```java
class Solution {
  public String longestPalindrome(String s) {
  
        // Optimized two pointer, ä¼˜åŒ–åœ°æ–¹ï¼šå½“ä¸‹ä¸€ä¸ªå€¼ä¸å½“å‰å€¼ç›¸åŒæ—¶ï¼Œå¿…å®šæ˜¯åœ¨è¯¥å›æ–‡ä¸­
        int start = 0;
        int len = 1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            int j = i;
            while(j+1 < s.length() && s.charAt(j+1) == c){ // æ‰¾åˆ°åé¢ä¸å½“å‰å€¼ä¸ç›¸åŒå½“indexï¼Œç„¶åå†ä»ä¸¤å¤´å¼€å§‹æœç´¢
                j++;
            }
            if(j-i+1 > len){
                start = i;
                len = j-i+1;
            }
            if(i-1 >= 0 && j+1 < s.length()){
                int extend = search2(s, i-1, j+1);
                if(j-i +1 + (2*extend) > len){
                    start = i-extend;
                    len = j-i+1+ (2*extend);
                }
            }
            i = j;
        }
        return s.substring(start,start+len);
  	
        // dp dynamic programming
//        boolean[][] state = new boolean[s.length()][s.length()];
//        for (int i = 0; i < state.length; i++) {
//                state[i][i] = true;
//        }
//        int start = 1, len = 1;
//        for (int i = state[0].length - 1; i >= 0; i--) {
//            for (int j = i+1; j <= state[0].length - 1; j++) {
//                if(s.charAt(i) == s.charAt(j) && (state[i+1][j-1] || j-i == 1)){
//                    state[i][j] = true;
//                    if(j-i+1 > len){
//                        start = i;
//                        len = j - i + 1;
//                    }
//                }else{
//                    state[i][j] = false;
//                }
//            }
//        }
//
//        return s.substring(start, start + len);

        
        // ä»iå¼€å§‹å‘ä¸¤è¾¹æ‰©æ•£ï¼ˆåŠ ä¸Šiå’Œi+1ç›¸åŒçš„æƒ…å†µï¼‰ï¼ŒåŒæŒ‡é’ˆ
        // String str = s.substring(0,1);
        // for (int i = 0; i < s.length(); i++) {
        //     char c = s.charAt(i);
        //     if(i-1 >= 0 && i+1 < s.length()){
        //         String temp = search(s, i-1, i+1);
        //         if(temp.length() > str.length()){
        //             str = temp;
        //         }
        //     }
        //     if(i+1 < s.length() && s.charAt(i+1) == c){
        //         if(str.length() < 2){
        //             str = s.substring(i, i+2);
        //         }
        //         String temp = search(s, i-1, i+2);
        //         if(temp.length() > str.length()){
        //             str = temp;
        //         }
        //     }
        // }
        // return str;
    }
    
    public String search(String s, int l, int r){ // ä»lï¼Œrå¼€å§‹å‘ä¸¤è¾¹æœç´¢ï¼Œè¿”å›æœç´¢åˆ°çš„æœ€é•¿çš„å­—ç¬¦ä¸²
        while (l>=0 && r<s.length()){
            if(s.charAt(l) == s.charAt(r)){
                l--;
                r++;
            }else{
                return s.substring(l+1, r);
            }
        }
        return s.substring(l+1, r);
    }
    
    public int search2(String s, int l, int r){ // ä»lï¼Œrå¼€å§‹å‘ä¸¤è¾¹æœç´¢ï¼Œè¿”å›å•è¾¹å¢åŠ äº†å¤šå°‘
        int i = 0;
        while (l>=0 && r<s.length()){
            if(s.charAt(l) == s.charAt(r)){
                l--;
                r++;
                i++;
            }else{
                return i;
            }
        }
        return i;
    }
}
```





## 14. Longest Common Prefix
Tag: String, Trie
![image-20230623111648066](./leetcode.assets/image-20230623111648066.png)
```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        # String
        # TC: O(m*n)
        # SC: O(1)
        common  = strs[0]
        n = len(strs)
        for i in range(1,n,1):
            m_l = min(len(common), len(strs[i]))
            for j in range(m_l, -1, -1):
                if common[:j] == strs[i][:j]:
                    common = common[:j]
                    break
            if len(common) == 0:
                return ""
        return common
```
```java
String result = strs[0];
for (String str :strs) {
    if(result.length() > str.length()){
        result = result.substring(0,str.length());
    }
    for (int j = 0; j < Math.min(str.length(), result.length()); j++) {
        if(result.charAt(j) != str.charAt(j)){
            result = str.substring(0,j);
            if(j == 0){
                return "";
            }
        }
    }
}
return result;
```

## 28. Find the Index of the First Occurrence in a String
Tag: String
![image-20230625235532477](./leetcode.assets/image-20230625235532477.png)
```python
class Solution:
    # TC: O(m*n) slice caused O(stop-start)
    # SC: O(1)  ignoring temporary slices since theyâ€™re garbage collected
    def strStr(self, haystack: str, needle: str) -> int:
        res  = 0
        n = len(haystack)
        l = len(needle)
        for i in range(n):
            if i+l <= n and haystack[i: i+l] == needle:
                return i
        return -1
    def strStr(self, haystack: str, needle: str) -> int:
        # TC: O(m*n)
        # SC: O(1)
        res  = 0
        n = len(haystack)
        l = len(needle)
        for i in range(n):
            if haystack[i] == needle[0]:
                all_match = True
                for j in range(1, l, 1):
                    if i+j < n and haystack[i + j] == needle[j]:
                        pass
                    else:
                        all_match = False
                        break
                if all_match:
                    return i
        return -1
        
```
æ³¨æ„substring

içš„èŒƒå›´åœ¨  i=0; i<haystack.len çš„æ—¶å€™ï¼Œ substringå– i,i+1ï¼Œå–ä¸€ä¸ªå­—ç¬¦

æ‰€ä»¥å½“substringå–lenä¸ªå­—ç¬¦ï¼Œå³ iåˆ°i+lençš„æ—¶å€™ï¼Œhaystack.len - (len-1)

```java
    public int strStr(String haystack, String needle) {
        int len = needle.length();

        for (int i = 0; i < haystack.length() - (len-1); i++) {
            if(haystack.substring(i, i+1+len-1).equals(needle)){
                return i;
            }
        }
        return -1;
    }
```



## 67. Add Binary

![image-20230625234204745](./leetcode.assets/image-20230625234204745.png)

æ³¨æ„è¾“å…¥çš„å–å€¼èŒƒå›´ï¼Œå¤§äº32ä½çš„Integer 4 byteï¼Œå¤§äº64ä½çš„long 8byteã€‚åªåšå•çº¯äºŒè¿›åˆ¶åŠ æ³•

æ–¹æ³•ï¼š

carryè®°å½•è¿›ä½ï¼Œsum%2, sum/2å–å€¼

```
	public String addBinary(String a, String b) {
        int al = a.length() - 1;
        int bl = b.length() - 1;
        StringBuilder sb = new StringBuilder();
        int sum;
        int carry = 0;
        while (al >= 0 || bl >= 0 ){
            sum = carry;
            if (al >= 0){
                sum+=a.charAt(al--) - '0';
            }

            if (bl >= 0){
                sum+=b.charAt(bl--) - '0';
            }
            sb.append(sum % 2);
            carry = sum / 2;
        }
        if(carry != 0){
            sb.append(carry);
        }
        
        return  sb.reverse().toString();
    }
```



## 151. Reverse Words in a String
Tag: String, Two Pointers, Sliding Window
![image-20230623220232747](./leetcode.assets/image-20230623220232747.png)

![image-20230623220252930](./leetcode.assets/image-20230623220252930.png)
```python
class Solution:
    # TC: O(n)
    # SC: O(1) or O(n)
    def reverseWords(self, s: str) -> str:
        # sliding windows
        # use list save each words
        n = len(s)
        left = n-1
        right = n-1
        res = []
        while left >= 0:
            right = left
            while s[right] == ' ' and right >= 0:
                right -= 1
            left = right
            while s[left] != ' ' and left >= 0:
                left -= 1
            if left != right:
                res.append(s[left+1: right + 1])
        return " ".join(res)

```
æ–¹æ³•1:

- åè½¬string
- åè½¬æ¯ä¸ªå•è¯
- æ¸…é™¤å¤šä½™çš„ç©ºæ ¼

æ–¹æ³•2:

- ç­›å‡ºæ¯ä¸ªå•è¯å¹¶ä¿å­˜ï¼ˆstackï¼‰
- åå‘ç©¿èµ·æ¥

æ–¹æ³•3:

- javaå†…ç½®æ–¹æ³•
- å…ˆtrimä¸¤è¾¹çš„ç©ºæ ¼
- å†é€šè¿‡ ç©ºæ ¼+ æ­£åˆ™åˆ†å¼€å•è¯
- å†é€šè¿‡Collections.reverseåè½¬å•è¯é¡ºåº
- å†é€šè¿‡String.join è¿æ¥æ‰€æœ‰å•è¯

```

 class Solution {

    public String reverseWords(String s) {
        // reverse all string
        // reverse each word
        // clean spaces
        char[] chars = s.toCharArray();
        reverse(chars, 0 , s.length()-1);
        reverseWord(chars);
        return cleanSpaces(chars);

        // java build-in method
//        String[] words = s.trim().split(" +");
//        Collections.reverse(Arrays.asList(words));
//        return String.join(" ",words);

        // save each word, concat reversely
//        Stack<int[]> stack = new Stack<>();
//        int[] starAndLen = {-1,-1};
//        boolean isWord = false;
//        for (int i = 0; i < s.length(); i++) {
//            if(s.charAt(i) == ' '){
//                if(!isWord){
//                    continue;
//                }
//                starAndLen[1] = i-1;
//                stack.push(starAndLen.clone());
//                isWord = !isWord;
//            }else{
//                if(!isWord){
//                    starAndLen[0] = i;
//                    isWord = true;
//                }
//            }
//        }
//        if(isWord){
//            starAndLen[1] = s.length()-1;
//            stack.push(starAndLen.clone());
//        }
//        StringBuilder sb = new StringBuilder();
//        while (!stack.empty()){
//            int[] temp = stack.pop();
//            sb.append(s, temp[0], temp[1]+1);
//            sb.append(" ");
//        }
//        return sb.substring(0,sb.length()-1);
    }

    public void reverse(char[] chars, int i , int j){
        while (i<j){
            char temp = chars[i];
            chars[i++] = chars[j];
            chars[j--] = temp;
        }
    }

    public void reverseWord(char[] chars){
        int i = 0, j=0;
        int n = chars.length;
        while (i<n){
            while (i<j || i<n && chars[i] == ' ')i++; // å³è¾¹æ˜¯skip spaceï¼ˆåˆ°è¾¾non-spaceåœ°æ–¹ï¼‰, å·¦è¾¹æ˜¯åˆ°ä¸‹ä¸€ä¸ªspaceåˆ°åœ°æ–¹
            while (j<i || j<n && chars[j]!= ' ')j++; // å³è¾¹æ˜¯skip non-spaceï¼Œå·¦è¾¹æ˜¯åˆ°ä¸‹ä¸€ä¸ªnon-spaceçš„åœ°æ–¹
            reverse(chars, i, j-1);

            // can also write as below
//            while (i<n && chars[i] == ' ')i++;
//            j=i+1;
//            while (j<n && chars[j] != ' ')j++;
//            reverse(chars, i, j-1);
//            i=j;
        }

        // whole as this
//        int start;
//        for (int i = 0; i < chars.length; i++) {
//            if(chars[i] != ' '){
//                start = i;
//                while (i < chars.length && chars[i] != ' '){
//                    i++;
//                }
//                reverse(chars, start, i-1);
//            }
//        }
    }

    public String cleanSpaces (char[] chars){
        int i = 0, j = 0, n = chars.length;
        while (j<n){
            while (j<n && chars[j] == ' ')j++; // i skip space
            while (j<n && chars[j] != ' ')chars[i++] = chars[j++]; // keep non space
            while (j<n && chars[j] == ' ')j++; // i skip space
            if(j<n)chars[i++] = ' '; // ä¸Šä¸€æ­¥skip spaceï¼Œä¸”è¿˜æ²¡æœ‰åˆ°nï¼Œè¯´æ˜è¿˜æœ‰å•è¯ï¼Œæ‰€ä»¥å¯ä»¥åŠ ç©ºæ ¼
        }
        return new String(chars, 0, i);
    }

    public String cleanSpaces2 (char[] chars){
        StringBuilder sb = new StringBuilder();
        sb.append(chars[0]);
        for (int i = 1; i < chars.length; i++) {
            if (chars[i-1] == ' ' && chars[i] == ' ') {
                continue;
            }
            sb.append(chars[i]);
        }
        return sb.toString().trim();
    }
}

```

## 167. Two Sum II - Input Array Is Sorted
Tag: Array, Two Pointers
![image-20230626130345826](./leetcode.assets/image-20230626130345826.png)
```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        # TC: O(n)
        # SC: O(1)
        n = len(numbers)
        start = 0
        end = n - 1
        while start != end:
            t = numbers[start] + numbers[end]
            if t == target:
                return [start + 1, end + 1]
            elif t < target:
                start += 1
            else:
                end -= 1
        return [0,0]
```

æš´åŠ›è§£æ³•ä¼šè¶…æ—¶

ç”¨åŒæŒ‡é’ˆï¼Œå› ä¸ºä¸€å®šä¼šæœ‰è§£ï¼Œä»ä¸¤è¾¹å¼€å§‹æ‰¾

```java
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        while (true){
            if(numbers[left] + numbers[right] > target){
                right --;
            }else if(numbers[left] + numbers[right] < target){
                left++;
            }else {
                return new int[]{left+1, right+1};
            }
        }     
    }
```



## 344. Reverse String
Tag: Array, String
![image-20230626120252825](./leetcode.assets/image-20230626120252825.png)
```python
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        l = 0
        r = len(s) - 1
        while l < r:
            s[l],s[r] = s[r],s[l]
            l += 1
            r -= 1

        # TC: O(n)
        # SC: O(1)
        n = len(s)
        for i in range(n//2):
            temp = s[i]
            s[i] = s[n-1-i]
            s[n-1-i] = temp
```
```java
    public void reverseString(char[] s) {
                for (int i = 0; i < s.length/2; i++) {
            char temp = s[i];
            s[i] = s[s.length - 1- i];
            s[s.length - 1- i] = temp;
        }
    }
```

## 557. Reverse Words in a String III
Tag: String, Two Pointers, Sliding Window

![image-20250709001650950](./leetcode.assets/image-20250709001650950.png)

```python
class Solution:
    # TC: O(n + n) O(n)
    # SC: O(n)
    # When reverse single word, we could also use two pointers and exchagne them in half word length to reduce half time complexity
    def reverseWords(self, s: str) -> str:
        res = []
        left = 0
        right = 0
        n = len(s)
        while right < n:
            left = right
            while left < n and s[left] == ' ':
                left += 1
            right = left
            while  right < n and s[right] != ' ':
                right += 1
            res.append(s[left:right][::-1])
        return ' '.join(res)

    def reverse_str(self, s: str, left: int, right: int)->str:
        res = ''
        for i in range(right, left - 1, -1):
            res += s[i]
        return res
```

## 561. Array Partition

![image-20230626120714206](./leetcode.assets/image-20230626120714206.png)

```java
    public int arrayPairSum(int[] nums) {
                Arrays.sort(nums);
        int sum = 0;
        for (int i = 0; i < nums.length; i+=2) {
            sum += nums[i];
        }
        return sum;
    }
```


# Linked List



```java
// Definition for singly-linked list.
public class SinglyListNode {
    int val;
    SinglyListNode next;
    SinglyListNode(int x) { val = x; }
}
```

### Add

![image-20241016124418815](./leetcode.assets/image-20241016124418815.png)

### Delete

![image-20241016124446709](./leetcode.assets/image-20241016124446709.png)

Constructor

```
LinkedList()

LinkedList(Collection<? extends E> c)
```

## Double linked list

```java
// Definition for doubly-linked list.
class DoublyListNode {
    int val;
    DoublyListNode next, prev;
    DoublyListNode(int x) {val = x;}
}
```



Build-in LinkedList

```java
LinkedList<Integer> deque = new LinkedList<>();
// 1. add first
deque.addFirst(10); // [10]
// 2. add to last
deque.addLast(20);  // [10, 20]
// 3. remove first
deque.removeFirst();
// 4. remove last
deque.removeLast();
```







## [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)
Tag: Linked List,
![image-20230812012940487](leetcode.assets/image-20230812012940487.png)
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# TC: O(max(m, n))
# SC: O(max(m, n)) but answer is not count as space complexity, so O(1)
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: Optional[ListNode]
        :type l2: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        dummy_h = ListNode(0)
        h = dummy_h
        add_on = 0
        while l1 is not None or l2 is not None or add_on != 0:
            a1 = 0 if l1 is None else l1.val
            a2 = 0 if l2 is None else l2.val
            total = a1 + a2 + add_on
            add_on = total // 10
            h.next = ListNode(total % 10)
            h = h.next
            if l1 is not None:
                l1 = l1.next
            if l2 is not None:
                l2 = l2.next
            
        return dummy_h.next
```


```java
 public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // return addTwoNumbers2(l1,l2,0);

        // Method2:
          ListNode head = new ListNode(0);
        ListNode prev = head;
        int add = 0;
        while (l1!=null || l2 != null || add != 0){
            ListNode cur = l1 != null ? l1:(l2 != null? l2 : new ListNode(0));
            int v = (l1!=null ? l1.val: 0) + (l2 != null ? l2.val : 0) + add;
            add = v / 10;
            v %= 10;
            cur.val = v;
            head.next = cur;
            head = head.next;

            l1 = l1 == null ? l1:l1.next;
            l2 = l2 == null ? l2:l2.next;
        }
        return prev.next;
        
        //  ListNode head = new ListNode();
        // ListNode originHead = head;
        // int v = 0;
        // int add = 0;
        // while (l1!=null || l2 != null || add != 0){
        //     v = (l1!=null ? l1.val: 0) + (l2 != null ? l2.val : 0) + add;
        //     add = v / 10;
        //     v %= 10;
        //     head.val = v;
        //     if((l1 == null || l1.next == null) &&(l2 == null || l2.next == null) && add == 0){
        //         break;
        //     }
        //     head.next = new ListNode();
        //     l1 = l1 == null ? l1:l1.next;
        //     l2 = l2 == null ? l2:l2.next;
        //     head = head.next;
        // }
        // return originHead;
    }
    public ListNode addTwoNumbers2(ListNode l1, ListNode l2, int add) {
        if(l1 == null && l2 == null){
            if(add == 1){
                return new ListNode(1);
            }else{
                return null;
            }
        }
        int v = (l1!=null ? l1.val: 0) + (l2 != null ? l2.val : 0) + add;
        if(v >= 10){
            v = v-10;
            add = 1;
        }else{
            add = 0;
        }

        if(l1 == null && l2!=null){
            l2.val = v;
            l2.next = addTwoNumbers2(l1, l2.next, add);
            return l2;
        }
        if(l2 == null && l1!=null){
            l1.val = v;
            l1.next = addTwoNumbers2(l1.next, l2, add);
            return l1;
        }

        l1.val = v;
        l1.next = addTwoNumbers2(l1.next,l2.next,add);
        return l1;
    }
}
```



## [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
Tag: Linked List, Two Pointers

![image-20230730123537955](./leetcode.assets/image-20230730123537955.png)

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# TC: O(n)
# SC: O(1)
class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: Optional[ListNode]
        :type n: int
        :rtype: Optional[ListNode]
        """
        dumy_h = ListNode(0)
        dumy_h.next = head
        p1 = dumy_h
        p2 = dumy_h

        while n > 0:
            p1 = p1.next
            n-=1
        while p1.next is not None:
            p1 = p1.next
            p2 = p2.next
        p2.next = p2.next.next
        return dumy_h.next
        
        # ä¸‹é¢æ–¹æ³•è·‘äº†ä¸¤é
        # TC: O(2n)
        # SC: O(1)
        # dumy_h = ListNode(0)
        # dumy_h.next = head
        # p = dumy_h
        # i = 0
        # while p is not None:
        #     p = p.next
        #     i += 1
        # steps = i - n
        # p = dumy_h
        # while steps - 1 > 0:
        #     p= p.next
        #     steps -= 1
        # p.next = p.next.next
        # return dumy_h.next
        
        # ä¸‹é¢æ²¡æœ‰ä½¿ç”¨dummy headï¼Œå¤šäº†è®¸å¤šåˆ¤æ–­å’Œæ¼äº†è¾¹ç•Œæ¡ä»¶ï¼Œå¯ä»¥æ·»åŠ dummy head
        # p = head
        # i = 0
        # while p is not None:
        #     p = p.next
        #     i += 1
        # if i == 1 and n == 1:
        #     return None
        # if n == i:
        #     return head.next
        # steps = i - n
        # p = head
        # while steps -1 > 0:
        #     p = p.next
        #     steps -= 1
        # p.next = p.next.next if p.next is not None else None
        # return head
```

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
                // method1: two pointers, let the fast pointer step n steps first, and when it reaches the end
        // the slow pointer is at the n-1 from end.
        ListNode p1 = new ListNode();
        ListNode p2;
        ListNode p3;
        p2=p1;
        p3=p1;
        p1.next = head;
        int t = n+1;
        while (t-->0){
            p2=p2.next;
        }
        while (p2!=null){
            p2 = p2.next;
            p1=p1.next;
        }
        p1.next = p1.next.next;
        return p3.next;
        //         if(head.next == null){
        //     return null;
        // }
        // ListNode p1 = head;
        // ListNode p2 = head;
        // while (n-->0){
        //     p2=p2.next;
        // }
        //         if(p2==null){
        //     head = head.next;
        //     return head;
        // }
        // while (p2.next!=null){
        //     p1=p1.next;
        //     p2=p2.next;
        // }
        // p1.next = p1.next.next;
        // return head;
        // int size = 1;
        // ListNode hs = head;
        // while (hs.next!=null){
        //     hs=hs.next;
        //     size++;
        // }
        // hs=head;
        // if(n == size){
        //     return head.next;
        // }
        // int pass = size - n-1;

        // while(pass-- != 0){
        //     hs=hs.next;
        // }
        // hs.next=hs.next.next;

        // return head;
    }
}
```

## 21. Merge Two Sorted Lists
Tag: Linked List, Recursion
![image-20230811230822528](leetcode.assets/image-20230811230822528.png)
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def mergeTwoLists(self, list1, list2):
        """
        :type list1: Optional[ListNode]
        :type list2: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        # TC: O(m+n)
        # SC: O(1)
        dummy_h = ListNode(0)
        h = dummy_h
        while list1 is not None and list2 is not None:
            if list1.val < list2.val:
                h.next = list1
                list1 = list1.next
            else:
                h.next = list2
                list2 = list2.next
            h=h.next
        if list1 is None:
            h.next = list2
        else:
            h.next = list1
        
        return dummy_h.next

        # Recursion
        # TC: O(m+n)
        # SC: O(m+n)
        if list1 is None:
            return list2
        
        if list2 is None:
            return list1

        
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```
```java
public class ez21MergeTwoSortedLists {

    public static void main(String[] args) {
        ListNode l1 = new ListNode(1);
        ListNode l2 = new ListNode(2);
        ListNode l3 = new ListNode(4);
        l1.next = l2;
        l2.next= l3;


        ListNode n1 = new ListNode(1);
        ListNode n2 = new ListNode(3);
        ListNode n3 = new ListNode(4);
        n1.next = n2;
        n2.next = n3;

        ez21MergeTwoSortedLists test = new ez21MergeTwoSortedLists();
        ListNode result = test.mergeTwoLists(l1, n1);
        System.out.println();
    }

    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        if(list1 == null){
            return list2;
        }
        if(list2 == null){
            return list1;
        }
        if(list1.val < list2.val){
            list1.next = mergeTwoLists(list1.next,list2);
            return list1;
        }else{
            list2.next=mergeTwoLists(list1,list2.next);
            return list2;
        }

        // Method1: merge one list into another
//        // list1 as origin,
//        // merge list2 into list1
//        if(list1 == null){
//            return list2;
//        }
//        if(list2 == null){
//            return list1;
//        }
//
//        if(list1.val < list2.val){
//            return merge(list1, list2);
//        }else{
//            return merge(list2, list1);
//        }

        // Method2: merge two lists into a new listnode
        //    if(list1 == null){
        //        return list2;
        //    }
        //    if(list2 == null){
        //        return list1;
        //    }
        //     ListNode head = new ListNode();
        //     ListNode originHead = head;
        //     while(list1 != null && list2 != null){
        //         if(list1.val <= list2.val){
        //             head.val = list1.val;
        //             list1 = list1.next;
        //         }else{

        //             head.val = list2.val;
        //             list2 = list2.next;
        //         }
        //         head.next = new ListNode();
        //         head = head.next;
        //     }
        //     if(list1 == null){
        //         head.val = list2.val;
        //         head.next = list2.next;
        //     }else{
        //         head.val = list1.val;
        //         head.next = list1.next;
        //     }
        //     return originHead;

    }

    public ListNode merge(ListNode list1, ListNode m){
        ListNode origin = list1;
        ListNode next =  origin.next;
        while (m != null){
            if(next == null){
                origin.next = m;
                break;
            }
            if(m.val >= origin.val && m.val <= next.val){
                origin.next = new ListNode(m.val, next);
                m = m.next;
            }
            origin = origin.next;
            next = origin.next;
        }
        return list1;
    }

}

```

## 61. Rotate List
Tag: Linked List, Two Pointers

![image-20250624193546358](./leetcode.assets/image-20250624193546358.png)

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def rotateRight(self, head, k):
        """
        :type head: Optional[ListNode]
        :type k: int
        :rtype: Optional[ListNode]
        """
        # TC: O(n)
        # SC: O(1)
        if head is None:
            return head
        l = 0
        h = head
        while h is not None:
            h = h.next
            l += 1
        res = k % l
        if res == 0:
            return head
        fast = head
        while res > 0:
            fast = fast.next
            res -= 1
        slow = head
        while fast.next is not None:
            fast = fast.next
            slow = slow.next
        n_h = slow.next
        slow.next = None
        fast.next = head
        return n_h
```




## 138. Copy List with Random Pointer
Tag: Linked List, Hash Table

![image-20250624184003479](./leetcode.assets/image-20250624184003479.png)

![image-20250624184008240](./leetcode.assets/image-20250624184008240.png)



å…ˆå¤åˆ¶ï¼Œè¿æ¥ï¼Œå†æ‹†åˆ†

![image-20250624193230942](./leetcode.assets/image-20250624193230942.png)




```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x, next=None, random=None):
        self.val = int(x)
        self.next = next
        self.random = random
"""
class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        # å…ˆè¿æ¥å¤åˆ¶ï¼Œå†æ‹†åˆ†
        # TC: O(n)
        # SC: O(1)
        if head is None:
            return head
        h = head
        while head is not None:
            next = head.next
            head.next = Node(head.val)
            head.next.next = next
            head = next
        head = h
        while head is not None:
            if head.random is not None:
                head.next.random = head.random.next
            head = head.next.next
        head = h
        res = head.next
        while head is not None:
            next = head.next.next
            if next is not None:
                head.next.next = next.next
            head.next = next
            head = next
        return res


        # Hashtable
        # TC: O(n)
        # SC: O(n)
        d = {}
        dummy_n = Node(0)
        n = dummy_n
        h = head
        while head is not None:
            temp = Node(head.val)
            n.next = temp
            d[head] = temp
            n = n.next
            head = head.next
        n = dummy_n.next
        while h is not None:
            if h.random is not None:
                n.random = d.get(h.random)
            h = h.next
            n = n.next
        return dummy_n.next


```


## 141. Linked List Cycle
Tag: Two Pointers, Floydâ€™s Cycle Detection
![image-20230705201832794](./leetcode.assets/image-20230705201832794.png)

![image-20230705201914153](./leetcode.assets/image-20230705201914153.png)
```python
# TC: O(n)
# SC: O(1)
class Solution11(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        fast = head
        slow = head

        while fast is not None and fast.next is not None and fast.next.next is not None:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```

Solution:

1. Using two pointers
2. One go one step each time, another go two steps each time.
3. If there is a circle, the longer step will catch up the shorter step pointer.

```java
    public boolean hasCycle(ListNode head) {
        ListNode n1 = head;
        ListNode n2 = head;

        while(n2 != null && n2.next != null && n2.next.next != null ){
            n2 = n2.next.next;
            n1 = n1.next;
            if(n1 == n2){
                return true;
            }
        }
        return false;
    }
```

## 142. Linked List Cycle II
Tag: Two Pointers, Floydâ€™s Cycle Detection
![image-20230709134411097](./leetcode.assets/image-20230709134411097.png)

![image-20230709134423752](./leetcode.assets/image-20230709134423752.png)

![image-20230709134440423](./leetcode.assets/image-20230709134440423.png)

![image-20230709134440423](./leetcode.assets/image-2025062101.png)
```python
'''
x len to circle start
k the first round steps
r circle len

2k - k = nr
because: 
nr = x + a
so:
x = nr - a
so:
x = n-1 (r) + rest
A new pointer start from start and the slower pointer also start move from where it is. They will meet at the start of the circle
'''
# TC: O(n)
# SC: O(1)
class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        fast = head
        slow = head

        while fast is not None and fast.next is not None:
            fast = fast.next.next
            slow = slow.next
            if fast is slow:
                break
        if fast is None or fast.next is None:
            return None
        
        ano_start = head
        while True:
            if ano_start is slow:
                break
            ano_start = ano_start.next
            slow = slow.next
        return slow

```

using two pointers, one of them one step at a time. another pointer each take two steps. Suppose the first meet at step ***k***,the length of the Cycle is ***r***. so..**2k-k=nr,k=nr**
Now, the distance between the start node of list and the start node of cycle is ***s***. the distance between the start of list and the first meeting node is ***k***(the pointer which wake one step at a time waked k steps).the distance between the start node of cycle and the first meeting node is ***m***, so...**s=k-m,
s=nr-m=(n-1)r+(r-m),here we takes n = 1**..so, using one pointer start from the start node of list, another pointer start from the first meeting node, all of them wake one step at a time, the first time they meeting each other is the start of the cycle.

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null){
            return null;
        }
        ListNode p1 = head;
        ListNode p2 = head;
        while(p2.next != null && p2.next.next != null){
            p1 = p1.next;
            p2 = p2.next.next;
            if(p1.equals(p2) ){
                break;
            }
        }
        
        if(p2.next == null || p2.next.next == null){
            return null;
        }

        ListNode p3 = head;
        while(p1 != p3){
            p1 = p1.next;
            p3 = p3.next;
        }
        return p1;
    }
}
```



## 160. Intersection of Two Linked Lists

![image-20230709134125181](./leetcode.assets/image-20230709134125181.png)

![image-20230709134142175](./leetcode.assets/image-20230709134142175.png)

Solution 1:

Add one ListNode to another, so to get two same size of ListNodes.

```
        ListNode a = headA;
        ListNode b = headB;

        while(a != b){
            a = a == null ? headB : a.next;
            b = b == null ? headA : b.next;
        }

        return a;
```



My solution:

1. Find each size of two ListNode as **sizeA** **sizeB**.
2. Cut the extra part that one ListNode is longer than another, which is **diff of sizeA and sizeB**, Making two ListNodes as same size.
3. Two ListNodes start go next one step every time, finding if there is a common node.

```java
     		
// solution 2 get The Diff
				ListNode a = headA;
        ListNode b = headB;
        int sizeA = 0;
        int sizeB = 0;
        while(a != null){
            sizeA ++;
            a = a.next;
        }
        while(b != null){
            sizeB ++;
            b = b.next;
        }

        a = headA;
        b = headB;
        int diff = sizeA - sizeB;
        
        if(diff != 0){
            if(diff > 0){
                while(diff != 0){
                    a = a.next;
                    diff--;
                }
            }else{
                while (diff != 0){
                    b = b.next;
                    diff++;
                }
            }
        }
        
        while(a != null){
            if(a.equals(b)){
                return a;
            }
            a = a.next;
            b = b.next;
        }
        return null;
    }
```

## [203. Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/)
Tag: Linked List, Recursion
![image-20230730123223316](./leetcode.assets/image-20230730123223316.png)
```python

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution(object):
    def removeElements(self, head, val):
        """
        :type head: Optional[ListNode]
        :type val: int
        :rtype: Optional[ListNode]1
        """
        dummy_h = ListNode(0)
        dummy_h.next = head
        h = dummy_h
        while h.next is not None:
            if h.next.val == val:
                h.next = h.next.next
            else:
                h = h.next
        return dummy_h.next

        # TC: O(n)
        # SC: O(n)
        # Recursion, å±€éƒ¨å˜é‡ï¼Œè¿”å›åœ°å€ï¼Œå‚æ•°ç­‰ä¼šå‹å…¥call stack
        # if head is None:
        #     return head
        # head.next = self.removeElements( head.next,val)
        # if head.val == val:
        #     return head.next
        # return head

```

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
           // recursive
        if(head == null){
            return null;
        }
        head.next = removeElements(head.next,val);
        if(head.val == val){
            return head.next;
        }else{
            return head;
        }
        // ListNode n = new ListNode();
        // ListNode n2 = new ListNode();
        // n2 = n;
        // n.next = head;
        // while (n.next!=null){
        //     if (n.next.val == val) {
        //         n.next = n.next.next;
        //     }else {
        //         n=n.next;
        //     }
        // }
        // return n2.next;
    }
}
```



## [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)
Tag: Linked List
![image-20230730123703471](./leetcode.assets/image-20230730123703471.png)
```python
# TC: O(n)
# SC: O(1)
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def reverseList(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
    
        prev = None
        while head is not None:
            next = head.next
            head.next = prev
            prev = head
            head = next

        return prev
```
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
public ListNode reverseList(ListNode head) {

        // ListNode prev = null;
        // ListNode next;

        // while (head != null){
        //     next = head.next;            
        //     head.next = prev;
        //     prev = head;
        //     head = next;
        // }
        // return prev;

                return reverseList(head, null);


        // if(head == null){
        //     return null;
        // }
        // ListNode newHead = head;
        // while(newHead.next != null){
        //     newHead = newHead.next;
        // }
        // reverse(head);
        // return newHead;x
    }

    // return the tail of the List
    public ListNode reverse(ListNode head){
        if(head.next == null){
            return head;
        }
        ListNode reversedTail = reverse(head.next);
        head.next = null;
        reversedTail.next = head;
        return head;
    }

        public ListNode reverseList(ListNode head, ListNode prev){
        if(head == null){
            return prev;
        }
        ListNode next = head.next;
        head.next = prev;
        prev = head;
        head = next;
        return reverseList(head, prev);
    }
}
```

## [234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)
Tag: Linked List, Two Pointers
![image-20230730141848828](./leetcode.assets/image-20230730141848828.png)
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def isPalindrome(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: bool
        """
        # TC: O(n)
        # SC: O(1)
        slow = head
        fast = head
        while fast.next is not None and fast.next.next is not None:
            slow = slow.next
            fast = fast.next.next
        h2 = slow.next

        if fast.next is None:
            # total len is odd, slow is at middle
            h1 = self.reverse(head, slow)
        else:
            # total len is even, slow is at first half end
            h1 = self.reverse(head, slow.next)
        
        while h1 is not None:
            if h1.val != h2.val:
                return False
            h1 = h1.next
            h2 = h2.next
        return True
        
    def reverse(self, head, h2):
        prev = None
        while head is not h2:
            next = head.next
            head.next = prev
            prev = head
            head = next
        return prev
```
```
public boolean isPalindrome(ListNode head) {
              ListNode p1 = head;
        ListNode p2 = head;

        while (p2!=null&& p2.next !=null){
            p1 = p1.next;
            p2 = p2.next.next;
        }
        p1 = reverseLinkedList(p1,null);
        while (p1 != null){
            if(p1.val == head.val){
                p1= p1.next;
                head = head.next;
            }else{
                return false;
            }
        }
        return true;
    }

    public ListNode reverseLinkedList(ListNode head, ListNode prev){
        if(head == null){
            return prev;
        }
        ListNode next = head.next;
        head.next = prev;
        prev = head;
        head = next;
        return reverseLinkedList(head, prev);
    }
```



## [328. Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list/)
Tag: Linked List
![image-20230730121254899](./leetcode.assets/image-20230730121254899.png)
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def oddEvenList(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        # TC: O(n)
        # SC: O(1)
        if head is None or head.next is None:
            return head
        
        odd = head
        even = head.next
        res = head
        dummy_even = head.next

        while even is not None and even.next is not None:
            odd.next = even.next
            even.next = even.next.next
            odd = odd.next
            even = even.next
        odd.next = dummy_even
        return res
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
                if(head == null){
            return null;
        }
        ListNode p1 = head;
        ListNode p3;
        ListNode p2 = head.next;
        p3 = p2;


        while (p2 != null && p2.next != null){
            p1.next = p1.next.next;
            p2.next = p2.next.next;
                        p1 = p1.next;
            p2=p2.next;
        }
        p1.next = p3;
        return head;
    }
}
```


## 430. Flatten a Multilevel Doubly Linked List
Tag: Linked List
![image-20250624181521323](./leetcode.assets/image-20250624181521323.png)

![image-20250624181528959](./leetcode.assets/image-20250624181528959.png)


```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
"""
# TC: O(n)
# SC: O(1)
class Solution(object):
    def flatten(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        dummy_h = head
        while head is not None:
            if head.child is None:
                head = head.next
            else:
                next = head.next
                child = head.child
                while child.next is not None:
                    child = child.next
                head.next = head.child
                head.child.prev = head
                head.child = None
                if next is not None:
                    child.next = next
                    next.prev = child
                head = head.next
        return dummy_h
```





## 707. Design Linked List

![image-20230705201602427](./leetcode.assets/image-20230705201602427.png)

![image-20230705201649208](./leetcode.assets/image-20230705201649208.png)

```java
class MyLinkedList {
    Node head;
    int size;
    public MyLinkedList() {
        size = 0;
    }
    
    public int get(int index) {
        if(index >= size){
            return -1;
        }
        Node tempNode = head;
        for(int i = 0; i < index; i++){
            tempNode = tempNode.next;
        }
        return tempNode.val;
    }
    
    public void addAtHead(int val) {
        Node tempHead = new Node(val, head);
        this.head = tempHead;
        size++;
    }
    
    public void addAtTail(int val) {
        Node tail = new Node(val);
        if(head == null){
            head = tail;
        }else{
            Node tempNode = head;
            while(tempNode.next != null){
                tempNode = tempNode.next;
            }
            tempNode.next = tail;
        }
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        if(index == 0){
            addAtHead(val);
        }else if(index == size){
            addAtTail(val);
        }else if(index >= size){
            return;
        }else{
            Node addNode = new Node(val);
            Node prev = head;
            for(int i = 0; i < index - 1; i++){
                prev = prev.next;
            }
            addNode.next = prev.next;
            prev.next = addNode;
            size++;
        }
    }
    
    public void deleteAtIndex(int index) {
        if(index >= size || index < 0){
            return;
        }
        if(index == 0){
            if(head.next == null){
                head = null;
            }else{
                head = head.next;
            }
            size--;
        }else{
            Node prev = head;
            for(int i = 0; i < index - 1; i++){
                prev = prev.next;
            }
            prev.next = prev.next.next;
            size--;
        }
    }

}

class Node{
    int val;
    Node next;

    public Node(){}

    public Node(int val, Node next){
        this.next = next;
        this.val = val;
    }

    public Node(int val){
        this.val = val;
    }


}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```


# Set (Python)

```python
# in, add, remove åœ¨setä¸­ï¼Œå¹³å‡ TC ä¸º O(1),æœ€åä¸ºO(n), SC ä¸º O(n)
# 1. åˆå§‹åŒ– set
hash_set = set()

# 2. æ·»åŠ æ–°å…ƒç´ , add æ— è¿”å›
hash_set.add(3)
hash_set.add(2)
hash_set.add(1)

# 3. ç§»é™¤å…ƒç´ ï¼ˆå¦‚æœå…ƒç´ ä¸å­˜åœ¨ä¼šæŠ¥é”™ï¼Œå»ºè®®ä½¿ç”¨ discardï¼‰
hash_set.remove(2)  # 2æ²¡åœ¨setä¸­æ—¶æŠ¥é”™
hash_set.discard(2) # å®‰å…¨ä¸æŠ¥é”™

# 4. åˆ¤æ–­å…ƒç´ æ˜¯å¦å­˜åœ¨
if 2 not in hash_set:
    print("Key 2 is not in the hash set.")
if 2 in hash_set:
    pass

# 5. è·å–å¤§å°
print(f"The size of hash set is: {len(hash_set)}")

# 6. éå† set
for i in hash_set:
    print(i, end=" ")
print("are in the hash set.")

# 7. æ¸…ç©º set
hash_set.clear()

# 8. åˆ¤æ–­æ˜¯å¦ä¸ºç©º
if not hash_set:
    print("hash set is empty now!")

# 9. è¿‡æ»¤åˆ—è¡¨ï¼Œåªä¿ç•™å‡ºç°åœ¨å¦ä¸€ä¸ªé›†åˆä¸­çš„å…ƒç´ ï¼ˆretainAllï¼‰
cars = ["Volvo", "BMW"]
valid = {"Volvo"}

# retainAll: Python ä¸­ç”¨ set è¿‡æ»¤
cars = [car for car in cars if car in valid]

print(cars)  # ['Volvo']

# 10. filter outæ‰å¦ä¸€ä¸ªsetä¸­çš„å…ƒç´ 
cars = ["Volvo", "BMW"]
valid = {"Volvo"}
res = cars.difference(valid)
# res: "BMW"

# 11. &, -, ^
# intersection
# union
# difference
# symmetric diff
# Only valid on sets
```
| æ“ä½œç¬¦ | æ–¹æ³•å           | å«ä¹‰                   | ç¤ºä¾‹                             |           |                              |
| --- | ------------- | -------------------- | ------------------------------ | --------- | ---------------------------- |
| `&` | `set1 & set2` | äº¤é›†ï¼ˆintersectionï¼‰     | `{1,2} & {2,3}` â†’ `{2}`        |           |                              |
|  `` ` `` | ``set1 ` set2`` | å¹¶é›†ï¼ˆunionï¼‰ | `{1,2} \| {2,3}` â†’ `{1,2,3}` |
| `-` | `set1 - set2` | å·®é›†ï¼ˆdifferenceï¼‰       | `{1,2,3} - {2,3}` â†’ `{1}`      |           |                              |
| `^` | `set1 ^ set2` | å¯¹ç§°å·®é›†ï¼ˆsymmetric diffï¼‰ | `{1,2,3} ^ {2,3,4}` â†’ `{1, 4}` |           |                              |



# Hash Table (Python dict)
```python
# in, add, remove åœ¨dictä¸­ï¼Œå¹³å‡ TC ä¸º O(1),æœ€åä¸ºO(n), SC ä¸º O(n)
# 1. initialize a dict
d = {}

# 2. insert a new (key, value) pair only if key not present, return original value if key exists, return default value if not exist
value = d.setdefault(0, 0)
>>> 0
value = d.setdefault(0, 3)
>>> 0

# 3. insert or update key, return old value if exist, or None
result = d.get(1)  # get if exist, or return None
result = d.get(1, 5)  # get if exist, or return default
d[1] = 1
d[1] = 2

# replace: if old value matches, update to new value
if hashmap.get(1) == 2:
    hashmap[1] = 3
    result = True
else:
    result = False

# replace without old value
result = hashmap.get(1)
if 1 in hashmap:
    hashmap[1] = 2

# getOrDefault
v = hashmap.get(1, 0)
hashmap[1] = v + 1

# 4. get the value of a specific key
print("The value of key 1 is:", hashmap.get(1))

# 5. delete a key
hashmap.pop(2, None)  # no error if key doesn't exist

# 6. check if key exists
if 2 not in hashmap:
    print("Key 2 is not in the hash map.")

# check if a value is in the hash map
if 2 not in hashmap.values():
    print("Value 2 is not in the hash map.")

# 7. get the size of hash map
print("The size of hash map is:", len(hashmap))

# 8. iterate the hash map
for k, v in hashmap.items():
    print(f"({k},{v})", end=" ")

print("\nKeys:", list(hashmap.keys()))
print("Values:", list(hashmap.values()))
print("are in the hash map.")

# 9. clear the hash map
hashmap.clear()

# 10. check if the hash map is empty
if not hashmap:
    print("hash map is empty now!")

```

## defaultdict

```python
# defaultdict
from collections import defaultdict
# 1. Initialize
d = defaultdict(int)

```

## Counter
```python
# 1. Initialize
counter = Counter('2113412345') # fill an iterable object
>>> Counter({'2': 2, '1': 2, '3': 2, '4': 2, '5': 1}) # Return a dict like object, which has methods keys, values, items, get

# 2. Get most k common elements
# Return a list of tuples
counter.most_common(3)
>>> [('2', 2), ('1', 2), ('3', 2)]
```


# HashSet

```java
   public static void main(String[] args) {
        // 1. initialize the hash set
        Set<Integer> hashSet = new HashSet<>();     
        // 2. add a new key, return true if the value is not in the set or false otherwise.
        boolean exist = hashSet.add(3);
        hashSet.add(2);
        hashSet.add(1);
        // 3. remove the key
        hashSet.remove(2);        
        // 4. check if the key is in the hash set
        if (!hashSet.contains(2)) {
            System.out.println("Key 2 is not in the hash set.");
        }
        // 5. get the size of the hash set
        System.out.println("The size of has set is: " + hashSet.size());     
        // 6. iterate the hash set
        for (Integer i : hashSet) {
            System.out.print(i + " ");
        }
        System.out.println("are in the hash set.");
        // 7. clear the hash set
        hashSet.clear();
        // 8. check if the hash set is empty
        if (hashSet.isEmpty()) {
            System.out.println("hash set is empty now!");
        }
       // 9. Remove items from a list which do not belong to a specified collection
        ArrayList<String> cars = new ArrayList<String>();
        cars.add("Volvo");
        cars.add("BMW");

        ArrayList<String> valid = new ArrayList<String>();
        valid.add("Volvo");

        cars.retainAll(valid);

        System.out.println(cars); // [Volvo]

    }
```



# HashMap

```java
    // 1. initialize a hash map
    Map<Integer, Integer> hashmap = new HashMap<>();
    // 2. insert a new (key, value) pair
    hashmap.putIfAbsent(0, 0);
    hashmap.putIfAbsent(2, 3);
    // 3. insert a new (key, value) pair or update the value of existed key, return old value if exist or null otherwise.
    int result = hashmap.put(1, 1);
    hashmap.put(1, 2);
	// replace, if old value provide, return true if replaced or false otherwise. if no old value, return old value if exist or null if the entry with the key does not exist.
	int result = hashmap.replace(1,2,3); // key, oldValue, newValue
	int result = hashmap.replace(1,2);
	// getOrDefault
	int v = hashmap.getOrDefault(1,0);
	hashmap.put(1,v+1);
    // 4. get the value of specific key
    System.out.println("The value of key 1 is: " + hashmap.get(1));
    // 5. delete a key
    hashmap.remove(2);
    // 6. check if a key is in the hash map
    if (!hashmap.containsKey(2)) {
        System.out.println("Key 2 is not in the hash map.");
    }
	// check if a value is in the hash map
	if(!hashmap.containsValue(2)){
        System.out.println("Value 2 is not in the hash map.");
    }
    // 7. get the size of the hash map
    System.out.println("The size of hash map is: " + hashmap.size()); 
    // 8. iterate the hash map
    for (Map.Entry<Integer, Integer> entry : hashmap.entrySet()) {
        System.out.print("(" + entry.getKey() + "," + entry.getValue() + ") ");
    }
	hashmap.keySet();
	hashmap.values();
    System.out.println("are in the hash map.");
    // 9. clear the hash map
    hashmap.clear();
    // 10. check if the hash map is empty
    if (hashmap.isEmpty()) {
        System.out.println("hash map is empty now!");
    }
	
```
## 2. Tow Sum
Tag: Hash Table, Array
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for i in range(len(nums)):
            if d.get(target - nums[i]) is None:
                d[nums[i]] = i
            else:
                return [d.get(target - nums[i]), i]
        return []
```

## 3. Longest Substring Without Repeating Characters
![image-20250702001](leetcode.assets/image-20250702001.png)
Tag: Hash Table, Two Pointers, String, Sliding Window
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # TC: O(n)
        # SC: O(n)
        start = 0
        end = 0
        res = 0
        window = set()
        n = len(s)
        while end < n:
            while end < n and s[end] not in window:
                window.add(s[end])
                end += 1
            res = max(res, end - start)
            # while end < n and  s[end] in window:
            window.remove(s[start])
            start += 1
        return res
                
```


## 36. Valid Sudoku
Tag: Array, Hash Table, Matrix
```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        # TC: O(1)
        # SC: O(1)
        rows = [set() for _ in range(9)]
        cols = [set() for _ in range(9)]
        boxes = [set() for _ in range(9)]
        for i in range(9):
            for j in range(9):
                v = board[i][j]
                if v == '.':
                    continue
                box_idx = (i // 3) * 3 + j // 3
                if v in rows[i]  or v in cols[j] or v in boxes[box_idx]:
                    return False
                rows[i].add(v)
                cols[j].add(v)
                boxes[box_idx].add(v)
                
        return True
```

## 49. Group Anagrams
Tag: Hash Table, Array, String
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # TC: O(n * k log k) sort O(k log k)ï¼Œå…¶ä¸­kä¸ºè¦æ’åºçš„å­—ç¬¦ä¸²é•¿åº¦
        # SC: O(nk)
        res = []
        d = {}
        n = len(strs)
        for i in range(n):
            ele = strs[i]
            s = ''.join(sorted(ele))
            if s in d:
                res[d.get(s)].append(ele)
            else:
                d[s] = len(res)
                res.append([ele])
        return res

        # TC: O(n * k)
        # SC: O(26 n) -> O(n)
        res = []
        d = {}
        n = len(strs)
        for i in range(n):
            ele = strs[i]
            temp = [0]*26
            for char in ele:
                temp[ord(char) - ord('a')] += 1
            s = tuple(temp)
            # s = ','.join([str(char) for char in temp])
            if s in d:
                res[d.get(s)].append(ele)
            else:
                d[s] = len(res)
                res.append([ele])
        return res
```

## 136. Single Number
Tag: Hash Table, Array
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def singleNumber(self, nums: List[int]) -> int:
        s = set()
        for ele in nums:
            if ele in s:
                s.remove(ele)
            else:
                s.add(ele)
        return s.pop()
```

## 202. Happy Number
Tag: Hash Table
```python
class Solution:
    def isHappy(self, n: int) -> bool:
        # TC: O()
        # SC: O()
        st = set()
        while n not in st:
            st.add(n)
            s = str(n)
            n = 0
            for i in s:
                v = ord(i) - ord('0')
                n += v**2
            if n == 1:
                return True
        return False

    def isHappy(self, n: int) -> bool:
        # TC: O(n)
        # SC: O(1)
        slow = self.get_value(n)
        fast = self.get_value(n)
        fast = self.get_value(fast)
        while slow != fast:
            slow = self.get_value(slow)
            fast = self.get_value(fast)
            fast = self.get_value(fast)
        return True if slow == 1 else False

    def get_value(self, n: int) -> int:
        sm = 0
        while n:
            tmp = n % 10
            sm += tmp ** 2
            n //= 10
        return sm
```

## 205. Isomorphic Strings
Tag: Hash Table, Array
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        n1 = [-1] * 128
        n2 = [-1] * 128
        for i in range(len(s)):
            a = s[i]
            b = t[i]
            if n1[ord(a)] != n2[ord(b)]:
                return False
            n1[ord(a)] = i
            n2[ord(b)] = i
        return True

        s_t={}
        t_s={}
        for i in range(len(s)):
            if (s_t.get(s[i], t[i]) != t[i]) or (t_s.get(t[i], s[i]) != s[i]):
                return False
            s_t[s[i]] = t[i]
            t_s[t[i]] = s[i]
        return True
```

## 217. Contains Duplicate
Tag: Hash Table, Array
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def containsDuplicate(self, nums: List[int]) -> bool:
        s = set()
        for ele in nums:
            if ele in s:
                return True
            else:
                s.add(ele)
        return False
```

## 219. Contains Duplicate II
Tag: Hash Table, Array, Sliding Window
```python
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        # TC: O(n)
        # SC: O(n)
        # dict
        d = {}
        n = len(nums)
        for i in range(n):
            if nums[i] in d and i - d[nums[i]] <= k:
                return True
            else:
                d[nums[i]] = i
        return False

        
        # TC: O(n)
        # SC: O(n)
        # set sliding window
        s = set()
        n = len(nums)
        for i in range(n):
            if i > k:
                s.discard(nums[i - k - 1])
            if nums[i] in s:
                return True
            else:
                s.add(nums[i])
        return False
```
## 220. Contains Duplicate III
Tag: Math, HashMap, Bucket Sort, Sliding Window
```python
class Solution:
    # TC: O(n)
    # SC: O(indexDiff)
    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:
        d = {}
        size = valueDiff + 1
        for i in range(len(nums)):
            # Python // round to -inf
            id = nums[i] // size
            if id in d:
                return True
            if (id - 1) in d and nums[i] - d.get(id - 1) <= valueDiff:
                return True
            if (id + 1) in d and d.get(id + 1) - nums[i] <= valueDiff:
                return True
            d[id] = nums[i]
            if len(d) > indexDiff:
                d.pop((nums[i - indexDiff] // size), None)
        return False
```

## 349. Intersection of Two Arrays
Tag: Hash Table, Array
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1) & set(nums2))

        # TC: O(n)
        # SC: O(n)
        s = set()
        s2 = set()
        for ele in nums1:
            s.add(ele)
        for ele in nums2:
            if ele in s:
                s2.add(ele)
        return list(s2)
```

## 350. Intersection of Two Arrays II
Tag: Hash Table, Array
```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # TC: O(n)
        # SC: O(n)
        count = {}
        for ele in nums1:
            v = count.setdefault(ele, 0)
            count[ele] = v+1
        res = []
        for ele in nums2:
            v = count.get(ele, 0)
            if v > 0:
                res.append(ele)
                count[ele] -= 1
        return res
```

## 380. Insert Delete GetRandom O(1)
Tag: Hash Table, Array, Randomized
```python
class RandomizedSet:
    # All TC: O(1)
    # SC: O(n)
    def __init__(self):
        self.l = []
        self.d = {}

    def insert(self, val: int) -> bool:
        if val in self.d:
            return False
        else:
            self.d[val] = len(self.l)
            self.l.append(val)
            return True

    def remove(self, val: int) -> bool:
        if val not in self.d:
            return False
        else:
            val_idx = self.d[val]
            last_v = self.l[-1]
            self.l[val_idx] = last_v
            self.d[last_v] = val_idx
            self.l.pop()
            self.d.pop(val)
            return True

    def getRandom(self) -> int:
            return choice(self.l)

```

## 387. First Unique Character in a String
Tag: Hash Table, String
```python
class Solution:
        # TC: O(n)
        # SC: O(1)
        # lowercase letters as list
        nums = [0]*26
        n = len(s)
        for i in range(n):
            nums[ord(s[i]) - ord('a')] += 1
        for i in range(n):
            if nums[ord(s[i]) - ord('a')] == 1:
        return i

        # TC: O(n)
        # SC: O(n)
        # dict    def firstUniqChar(self, s: str) -> int:
        d = {}
        n = len(s)
        for i in range(n):
            if s[i] not in d:
                d[s[i]] = 1
            else:
                d[s[i]] += 1
        for i in range(n):
            if d.get(s[i]) == 1:
                return i
        return -1
```

## 454. 4Sum II
Tag: Hash Table, Array
```python
class Solution:
    ## TC: O(n^2)
    ## SC: O(n^2)
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        s = {}
        for ele1 in nums3:
            for ele2 in nums4:
                v = ele1 + ele2
                s[v] = s.setdefault(v, 0) + 1
        res = 0
        for ele1 in nums1:
            for ele2 in nums2:
                v = -(ele1+ele2)
                if v  in s:
                    res += s[v]
        return res
```

## 599. Minimum Index Sum of Two Lists
Tag: Hash Table
```python
class Solution:
    # TC: O(m + n)
    # SC: O(m)
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d = {}
        for i in range(len(list1)):
            d[list1[i]] = i
        m = len(list1) + len(list2)
        res = []
        for i in range(len(list2)):
            idx1 = d.get(list2[i])
            if idx1 is not None:
                if i + idx1 < m:
                    res.clear()
                    res.append(list2[i])
                    m = i + idx1
                elif i+idx1 == m:
                    res.append(list2[i])
        return res
```
## 771. Jewels and Stones
Tag: Hash Table
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        s = set(jewels)
        res = 0
        for ele in stones:
            if ele in s:
                res += 1
        return res
```


# Tree

## ^^Heap

å †ï¼ˆHeapï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ ‘å½¢æ•°æ®ç»“æ„ï¼Œé€šå¸¸æ˜¯å®Œå…¨äºŒå‰æ ‘ã€‚å®ƒæ»¡è¶³å †å±æ€§ï¼Œå³å¯¹äºæœ€å¤§å †ï¼ˆMax-Heapï¼‰ï¼Œçˆ¶èŠ‚ç‚¹çš„å€¼æ€»æ˜¯å¤§äºæˆ–ç­‰äºå­èŠ‚ç‚¹çš„å€¼ï¼›å¯¹äºæœ€å°å †ï¼ˆMin-Heapï¼‰ï¼Œçˆ¶èŠ‚ç‚¹çš„å€¼æ€»æ˜¯å°äºæˆ–ç­‰äºå­èŠ‚ç‚¹çš„å€¼

### Heap Queue (Python)
```python
# é»˜è®¤æœ€å°å †
import heapq
# 1. Initialize
l = []

# 2. Push
heapq.heappush(l, 5) # push element 5 into l, maintain heap feature

# 3. Pop
v = heapq.heappop(l) # pop the min element

# 4. Peek
l[0] # get the min element

# 5. Get n largets / smallest element
heapq.nsmallest(
    n: int, 
    iterable: Iterable[_S], 
    key: (_S) -> SupportsDunderLT | SupportsDunderGT | None = None) # iterableæ˜¯å¯iterableå¯¹è±¡ï¼Œkeyæ˜¯æ¯”è¾ƒçš„å‡½æ•°ï¼Œä¸sortedé‡Œçš„keyä¸€æ ·ã€‚

# 6. Heapifyï¼ŒæŠŠä¸€ä¸ªæ•°ç»„è½¬åŒ–ä¸ºå †ç»“æ„
heapq.heapify(l) # æ­¤ål[0] å°±æ˜¯æœ€å°çš„äº†

# 7. heappushpop(heap, item)
# å½“ä½ éœ€è¦å°†ä¸€ä¸ªæ–°å…ƒç´ åŠ å…¥å †ï¼Œå¹¶ä¸”åªä¿ç•™å †ä¸­è¾ƒå¤§çš„å…ƒç´ æ—¶ï¼ˆå¸¸ç”¨äºæ„å»ºæœ€å¤§ N ä¸ªå€¼çš„æœ€å°å †ï¼‰ã€‚
# å®ƒçš„æ•ˆç‡æ¯”å•ç‹¬è°ƒç”¨ heappush() å’Œ heappop() æ›´é«˜ï¼Œå› ä¸ºåªéœ€è°ƒæ•´ä¸€æ¬¡å †ç»“æ„ã€‚
heapq.heappushpop(heap, item)
res = heapq.heappushpop(heap, 2) 
```


### PriorityQueue

Javaä¸­æ²¡æœ‰ç›´æ¥å‘½åä¸º`Heap`çš„ç±»ï¼Œä½†æä¾›äº†`PriorityQueue`ç±»ï¼Œå®ƒå†…éƒ¨ä½¿ç”¨å †ç»“æ„æ¥å®ç°ã€‚`PriorityQueue`é»˜è®¤æ˜¯ä¸€ä¸ªæœ€å°å †ï¼ˆMin-Heapï¼‰ï¼Œä¹Ÿå¯ä»¥é€šè¿‡è‡ªå®šä¹‰æ¯”è¾ƒå™¨ï¼ˆComparatorï¼‰æ¥å®ç°æœ€å¤§å †ï¼ˆMax-Heapï¼‰æˆ–å…¶ä»–é¡ºåºã€‚

```java
// This is the default min-heap
int comparator(a1, a2){
	return a1-a2;
}
```

```java
import java.util.PriorityQueue;

public class Main {
    public static void main(String[] args) {
        // åˆ›å»ºä¸€ä¸ªæœ€å°å † (Min-Heap)
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        // æ’å…¥å…ƒç´ 
        minHeap.add(10);
        minHeap.add(4);
        minHeap.add(15);

        // è·å–æœ€å°å€¼ï¼ˆä¸åˆ é™¤ï¼‰
        System.out.println(minHeap.peek()); // è¾“å‡º: 4

        // åˆ é™¤æœ€å°å€¼
        System.out.println(minHeap.poll()); // è¾“å‡º: 4

        // ç°åœ¨çš„æœ€å°å€¼
        System.out.println(minHeap.peek()); // è¾“å‡º: 10

        // åˆ›å»ºä¸€ä¸ªæœ€å¤§å † (Max-Heap)
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

        maxHeap.add(10);
        maxHeap.add(4);
        maxHeap.add(15);

        // è·å–æœ€å¤§å€¼
        System.out.println(maxHeap.peek()); // è¾“å‡º: 15
    }
}
```

offer/add

poll/remove

peek

offerçš„æ—¶é—´å¤æ‚åº¦ä¸º `O(log(n))` nä¸ºqueueçš„size

## 23. Merge k Sorted Lists
Tag: Heap, Linked List, Divide and Conquer, Merge Sort
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    # Heapq
    # TC: O(kn x logk) # k lists, the longest list length is n. Add and pop of priorityqueue is logk
    # SC: O(k)
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        q = []
        h = ListNode(0)
        dummy_h = h
        counter = 0
        for l in lists:
            if l is not None:
                heapq.heappush(q, (l.val, counter, l))
                counter += 1
        while len(q):
            val, _, node = heapq.heappop(q)
            h.next = node
            h = h.next
            if node.next is not None:
                heapq.heappush(q, (node.next.val, counter, node.next))
                counter += 1
        return dummy_h.next

    # Divide and Conquer
    # TC: O(kn x logk) 2n, 4n, ---> 2n + ... + 4n total log k. (2n + 2/k n) log k / 2 = kn logk
    # SC: O(logk)
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        return self.merge(lists, 0, len(lists) - 1)

    def merge(self, lists, l, r):
        if l == r:
            return lists[l]
        if l > r:
            return None
        mid = (l + r) // 2
        return self.mergeTwoLists(self.merge(lists, l, mid), self.merge(lists, mid+1, r))

    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:
        dummy_h = ListNode(0)
        h = dummy_h
        while list1 is not None and list2 is not None:
            if list1.val < list2.val:
                h.next = list1
                list1 = list1.next
            else:
                h.next = list2
                list2 = list2.next
            h = h.next

        while list1 is not None:
            h.next = list1
            h = h.next
            list1 = list1.next
        while list2 is not None:
            h.next = list2
            h = h.next
            list2 = list2.next
        return dummy_h.next

    # Merge each two lists
    # TC: O(k^2 n) n, 2n, 3n, kn ---> (n + kn)k / 2 = kn + k^2 n = k^2 n
    # SC: O(1)
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        # h = ListNode(0)
        cur = None
        for l in lists:
            cur = self.mergeTwoLists(l, cur)
        return cur

    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:
        dummy_h = ListNode(0)
        h = dummy_h
        while list1 is not None and list2 is not None:
            if list1.val < list2.val:
                h.next = list1
                list1 = list1.next
            else:
                h.next = list2
                list2 = list2.next
            h = h.next

        while list1 is not None:
            h.next = list1
            h = h.next
            list1 = list1.next
        while list2 is not None:
            h.next = list2
            h = h.next
            list2 = list2.next
        return dummy_h.next
```

## 239. Sliding Window Maximum
Tag: Heap, 
```python
class Solution:
    # Priority Queue, é¦–å…ˆæ”¾å…¥ -nums[i] å½¢æˆæœ€å¤§å †ï¼Œ æ”¾å…¥tuple (-nums[i], i) å»åˆ¤æ–­indexæ˜¯å¦åœ¨windowä¸­
    # TC: O(n logn)
    # SC: O(n)
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)
        res = [-q[0][0]]
        for i in range(k, n):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] < i-k+1:
                heapq.heappop(q)
            res.append(-q[0][0])
        return res

    # ç»´æŠ¤ä¸€ä¸ªwindowrangeå†…çš„å•è°ƒåŒè¾¹é˜Ÿåˆ—ï¼Œé€’å‡çš„ã€‚å³è¾¹æ·»åŠ çš„æ—¶å€™ï¼ŒæŠŠå°äºè¯¥å€¼çš„popå‡ºå»ï¼Œç„¶åå·¦è¾¹æŠŠä¸åœ¨windowå†…çš„ä¹Ÿpopleftå‡ºå»ã€‚append ç¬¬ä¸€ä¸ªå…ƒç´ å³å¯
    # TC: O(n)
    # SC: O(k)
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        q = deque()
        for i in range(k):
            while q and nums[i] > nums[q[-1]]:
                q.pop()
            q.append(i)
        res = [nums[q[0]]]

        for i in range(k, n):
            while q and nums[i] > nums[q[-1]]:
                q.pop()
            q.append(i)

            while q[0] <= i - k:
                q.popleft()
            res.append(nums[q[0]])
        return res

    # åˆ†å— + é¢„å¤„ç†
    # TC: O(n)
    # SC: O(n)
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        prefix = [0] * n
        suffix = [0] * n
        
        for i in range(0, n, k):
            m1 = float('-inf')
            m2 = float('-inf')
            for j in range(i, min(i + k, n)):
                m1 = max(m1, nums[j])
                prefix[j] = m1
            for j in range(min(i + k, n) - 1, i - 1, -1):
                m2 = max(m2, nums[j])
                suffix[j] = m2

        res = []
        for i in range(n - k + 1):
            res.append(max(suffix[i], prefix[i + k - 1]))
        return res


```

## 264. Ugly Number II
Tag: Heap, Hash Table, Math, Dynamic Programming

![image-20250710230451564](./leetcode.assets/image-20250710230451564.png)

```python
class Solution:
    # TC: O(n logn)
    # SC: O(n)
    def nthUglyNumber(self, n: int) -> int:
        l = []
        heapq.heappush(l, 1)
        last = None
        s = set()
        while n > 0:
            last = heapq.heappop(l)
            if 2*last not in s:
                heapq.heappush(l, 2*last)
                s.add(2*last)
            if 3*last not in s:
                heapq.heappush(l, 3*last)
                s.add(3*last)
            if 5*last not in s:
                heapq.heappush(l, 5*last)
                s.add(5*last)
            n -= 1
        return last

    # TC: O(n)
    # SC: O(n)
    def nthUglyNumber(self, n: int) -> int:
        dp = [0] * (n+1)
        dp[1] = 1
        p2 = p3 = p5 = 1
        for i in range(2, n+1):
            m = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)
            dp[i] = m
            if m == dp[p2] * 2:
                p2 += 1
            if m == dp[p3] * 3:
                p3 += 1
            if m == dp[p5] * 5:
                p5 += 1
        return dp[n]
```

## 347. Top K Frequent Elements
Tag: Array, Hash Table, Heap (Priority Queue), Counting, Sorting, Bucket Sort, Quickselect, Divide and Conquer
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # TC: O(n*logk)
        # SC: O(m) # m is unique keys
        counter = Counter(nums) # O(n) O(m)
        return heapq.nlargest(k, counter, counter.get) # O(n*logk)
        
        # TC: O(n*logk)
        # SC: O(m) # m is unique keys
        d = {}
        for ele in nums:
            d[ele] = d.setdefault(ele, 0) + 1
        v = list(d.values())
        v.sort(reverse=True)
        m = v[k-1]
        res = [k for k,v in d.items() if v >= m]
        return res
```
## 652. Find Duplicate Subtrees
Tag: Hash Table, Tree, Depth-First Search, Binary Tree
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    # TC: O(n^2)
    # SC: O(n^2) # n is number of tree node
    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        hm = {}
        res = []
        self.traverse(hm,res,root)
        return res

    # preorder traverse
    def traverse(self, hm: dict, res: List[Optional[TreeNode]], root: Optional[TreeNode]) -> str:
        if root == None:
            return 'None'
        serializer = str(root.val) + ',' + self.traverse(hm, res, root.left) + ',' + self.traverse(hm, res, root.right)
        if serializer in hm and hm.get(serializer) == 2:
            res.append(root)
        hm[serializer] =  hm.setdefault(serializer, 1) + 1
        return serializer
```

## ^^Binary Tree

## 94. Binary Tree Inorder Traversal
Tag: Bianry Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root == None:
            return res
        res.extend(self.inorderTraversal(root.left))
        res.append(root.val)
        res.extend(self.inorderTraversal(root.right))
        return res
```

## 102. Binary Tree Level Order Traversal
Tag: Bianry Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []
        q = deque()
        if root is None:
            return res
        q.append(root)
        while len(q):
            r = []
            for _ in range(len(q)):
                node = q.popleft()
                r.append(node.val)
                if node.left is not None:
                    q.append(node.left)
                if node.right is not None:
                    q.append(node.right)
            res.append(r)
        return res
```
## 106. Construct Binary Tree from Inorder and Postorder Traversal
Tag: Recursion, Binary Tree
```python
# 1. Use index instead of slice arrays in every round
# 2. Use a dict to save the inorder values and index instead of index search everytime
# TC: O(n)
# SC: O()
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:

        def helper(in_left, in_right, post_left, post_right):
            if in_left > in_right:
                return None

            root = postorder[post_right]
            root_index = inorder_hashmap[root]
            left_size = root_index - in_left
            root_node = TreeNode(
                val=root,
                left=helper(in_left, root_index-1, post_left, post_left + left_size - 1),
                right=helper(root_index+1, in_right, post_left + left_size, post_right-1)
            )
            return root_node
        inorder_hashmap = {}
        for i, v in enumerate(inorder):
            inorder_hashmap[v] = i
        return helper(0, len(inorder) - 1, 0, len(postorder) - 1)
```
## 110. Balanced Binary Tree
Tag: Binary Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def dfs(node):
            if node is None:
                return 0
            left = dfs(node.left)
            right = dfs(node.right)
            if abs(left - right)  > 1 or left == -1 or right == -1:
                return -1
            return 1 + max(left, right)
        return dfs(root) != -1
```
## 112. Path Sum
Tag: Binary Tree, Math, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root is None:
            return False
        if root is not None and root.left is None and root.right is None:
            return True if targetSum == root.val else False
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```
## 116. Populating Next Right Pointers in Each Node
Tag: Binary Tree, Queue
```python
class Solution:
    # TC: O(n)
    # SC: O(1)
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if root is None:
            return root
        head = root
        while head.left:
            leftmost = head
            while head is not None:
                head.left.next = head.right
                if head.next:
                    head.right.next = head.next.left
                head = head.next
            head = leftmost.left
        return root
        
    # TC: O(n)
    # SC: O(n)
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        q = deque()
        if root is None:
            return root

        q.append(root)
        while len(q):
            n = len(q)
            start = None
            for _ in range(n):
                next = q.popleft()
                if next.left is not None:
                    q.append(next.left)
                if next.right is not None:
                    q.append(next.right)
                if start is not None:
                    start.next = next
                start = next
        return root
```

## 144. Binary Tree Preorder Traversal
Tag: Bianry Tree, Recursion
```python
class Solution:
    # TC: O(n) n is total node
    # SC: O(h) h is the height of the tree
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        self.traverse(root,res)
        return res

    def traverse(self, root, res):
        if root is None:
            return
        res.append(root.val)
        self.traverse(root.left, res)
        self.traverse(root.right, res)
    # TC: O(n)
    # SC: O(h)
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root is None:
            return res
        res.append(root.val)
        res.extend(self.preorderTraversal(root.left))
        res.extend(self.preorderTraversal(root.right))
        return res
```

## 145. Binary Tree Postorder Traversal
Tag: Bianry Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root == None:
            return res
        res.extend(self.postorderTraversal(root.left))
        res.extend(self.postorderTraversal(root.right))
        res.append(root.val)
        return res
```
## 236. Lowest Common Ancestor of a Binary Tree
Tag: Binary Tree, Recursion
```python
class Solution:
    # If the func does not found any p q in root, return None
    # If the func found one node, return the node
    # If the func found two nodes, return their root
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root == None or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left != None and right != None:
            return root
        return left if left is not None else right
```
## 297. Serialize and Deserialize Binary Tree
Tag: Binary Tree, Recursion
```python
class Codec:
    # TC: O(n)
    # SC: O(h)
    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = []
        self.helper(root, res)
        return ",".join(str(i) for i in res)

    def helper(self, root, res):
        if root is not None:
            res.append(root.val)
            self.helper(root.left, res)
            self.helper(root.right, res)
        else:
            res.append(None)
            return

    # TC: O(n)
    # SC: O(h)
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        idx = 0
        data = data.split(",")
        data = [int(i) if i != "None" else None for i in data]
        
        def helper():
            nonlocal idx
            if data[idx] is None:
                idx += 1
                return None
            root = TreeNode(data[idx])
            idx += 1
            left = helper()
            right = helper()
            root.left = left
            root.right = right
            return root

        return helper()
```


## ^^Trie
Typically, a trie is used to store strings, and it split the string part by part, Each Trie node represents a string (a prefix). Each node might have several children nodes while the paths to different children nodes represent different characters.
![image.png](./leetcode.assets/image-20250717001.png)

Also know as **prefix tree** cause all descendants of a node has common prefix
Represent a Trie
```python
class TrieNode:
    N = 26
    children = new TrieNode[N]

from typing import Dict
class TrieNode:
    children: Dict[str, TrieNode] = {}
    
    // you might need some extra values according to different cases

```

## 208. Implement Trie (Prefix Tree)
Tag: Trie, Array, Hash Table
```python
# dict
class Trie:
    def __init__(self):
        self.d = {}

    # TC: O(n) # n is word len
    # SC: O(s*n) # s is each word, n is len
    def insert(self, word: str) -> None:
        trie = self
        for c in word:
            if c not in trie.d:
                trie.d[c] = Trie()
            trie = trie.d[c]
        trie.d['is_end'] = True

    def search(self, word: str) -> bool:
        trie = self
        for c in word:
            if c not in trie.d:
                return False
            trie = trie.d[c]
        return True if trie.d.get('is_end') else False

    def startsWith(self, prefix: str) -> bool:
        trie = self
        for c in prefix:
            if c not in trie.d:
                return False
            trie = trie.d[c]
        return True

class Trie:
    # TC: O(1)
    # SC: O(1)
    def __init__(self):
        self.children = [0] * 26
        self.is_word = False

    # TC: O(n) # n is word len
    # SC: O(s*n*26) # s is each word, n is len
    def insert(self, word: str) -> None:
        cur = self
        for i in range(len(word)):
            c = word[i]
            idx = ord(c) - ord('a')
            if cur.children[idx] == 0:
                cur.children[idx] = Trie()
            cur = cur.children[idx]
        cur.is_word = True

    def search(self, word: str) -> bool:
        cur = self
        for c in word:
            idx = ord(c) - ord('a')
            if cur.children[idx] == 0:
                return False
            cur = cur.children[idx]
        return True if cur.is_word else False

    def startsWith(self, prefix: str) -> bool:
        cur = self
        for c in prefix:
            idx = ord(c) - ord('a')
            if cur.children[idx] == 0:
                return False
            cur = cur.children[idx]
        return True
```
## 211. Design Add and Search Words Data Structure
Tag: Trie, Hash Map, Array, String
```python
class Trie:
    def __init__(self):
        self.children = {}
        self.is_word = False

class WordDictionary:

    def __init__(self):
        self.node = Trie()
    
    # TC: O(len(w))
    # SC: O(len(w)*w count)
    def addWord(self, word: str) -> None:
        node = self.node
        for w in word:
            if w not in node.children:
                node.children[w] = Trie()
            node = node.children[w]
        node.is_word = True

    # TC: O() all added word characters count
    def search(self, word: str) -> bool:
        return self.search_with_node(word, self.node)

    def search_with_node(self, word: str, node: Trie) -> bool:
        for i in range(len(word)):
            w = word[i]
            if w == '.':
                for v in node.children.values():
                    if self.search_with_node(word[i+1:], v):
                        return True
            if w not in node.children:
                return False
            node = node.children[w]
        return True if node.is_word else False
```

## 336. Palindrome Pairs
Tag: String, Array, Hash Table, Trie
```python

class Solution:
    # TC: O(n*w*w) n len(words), w len(word), prefix = word[:j] O(w), is_palindrome O(w)
    # SC: O(n)
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backwords, res = {}, []
        backwords = {word[::-1]: i for i,word in enumerate(words)}

        for i, word in enumerate(words):
            if word in backwords and i != backwords[word]:
                res.append([i, backwords[word]])
            if word != '' and '' in backwords and word == word[::-1]:
                res.append([i, backwords['']])
                res.append([backwords[''], i])
            for j in range(len(word)):
                if word[:j] in backwords and word[j:] == word[:j-1:-1]:
                    res.append([i, backwords[word[:j]]])
                if word[j:] in backwords and word[:j] == word[j-1::-1]:
                    res.append([backwords[word[j:]], i])
        return res

class Solution:

    def is_palindrome(self, s):
        return s == s[::-1]
    # TC: O(n*w*w) n len(words), w len(word), prefix = word[:j] O(w), is_palindrome O(w)
    # SC: O(n)
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        res = set()
        word_to_idx = {word: i for i, word in enumerate(words)}
        for i, word in enumerate(words):
            for j in range(len(word) + 1):
                prefix = word[:j]
                suffix = word[j:]
                if self.is_palindrome(prefix):
                    reversed_suffix = suffix[::-1]
                    if reversed_suffix in word_to_idx and word_to_idx[reversed_suffix] != i:
                        res.add(f'{word_to_idx[reversed_suffix]},{i}')
                if self.is_palindrome(suffix):
                    reversed_prefix = prefix[::-1]
                    if reversed_prefix in word_to_idx and word_to_idx[reversed_prefix] != i:
                        res.add(f'{i},{word_to_idx[reversed_prefix]}')
        return [[int(part) for part in item.split(',')] for item in list(res)]
```
## 421. Maximum XOR of Two Numbers in an Array
Tag: Trie, Bit Manipulation
```python
class Solution:
    # TC: O(n*31)
    # SC: O(31*2 = 1)
    def findMaximumXOR(self, nums: List[int]) -> int:
        root = Trie()
        self.add(root, nums[0])
        res = 0
        for i in range(1, len(nums), 1):
            res = max(self.check(root, nums[i]), res)
            self.add(root,nums[i])
        return res

    def add(self, node, num):
        N = 30
        for i in range(N, -1, -1):
            cur_bit = num >> i & 1
            if cur_bit == 1:
                if node.left is None:
                    node.left = Trie()
                node = node.left
            else:
                if node.right is None:
                    node.right = Trie()
                node = node.right

    def check(self, node, num):
        N = 30
        x = 0
        for i in range(N, -1, -1):
            cur_bit = num >> i & 1
            if cur_bit == 1:
                if node.right:
                    node = node.right
                    x = x * 2 + 1
                else:
                    node = node.left
                    x = x * 2
            else:
                if node.left:
                    node = node.left
                    x = x * 2 + 1
                else:
                    node = node.right
                    x = x * 2
        return x

class Trie:
    def __init__(self):
        self.left = None
        self.right = None
```
## 212. Word Search II
Tag: Trie, Recursion, DFS
```python
class Solution:
    # TC: O(len(words)*len(word) + m*n*4^len(word))
    # SC: O(len(words)*len(word) + len(word))
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        root = Trie()
        for word in words:
            self.add(root, word)
        m = len(board)
        n = len(board[0])
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]

        res = set()
        def dfs(node, i, j):
            if board[i][j] not in node.children:
                return
            # è®°å½•iï¼Œjï¼Œè®¾ç½®#ï¼Œç»“æŸåè®¾ç½®å›æ¥ï¼Œå»é‡
            ch = board[i][j]
            nxt = node.children.get(board[i][j])
            if nxt.word is not None:
                res.add(nxt.word)
                # å‰ªæ
                nxt.word = None
                # è¿™é‡Œä¸returnï¼Œä¹Ÿä¸remove nxtï¼Œæ˜¯å› ä¸ºæƒ…å†µ abc , abçš„æ—¶å€™ï¼Œå¦‚æœå…ˆèµ°äº†abï¼Œæå‰å‰ªæï¼Œä¼šå¯¼è‡´abcæ‰¾ä¸åˆ°
            board[i][j] = "#"
            for xi, yi in dirs:
                x = i + xi
                y = j + yi
                if 0 <= x < m and 0 <= y < n:
                    dfs(nxt, x, y)
            board[i][j] = ch
            # è¯¥èŠ‚ç‚¹æ²¡ç”¨çš„æ—¶å€™ï¼Œå‰ªæ
            if len(nxt.children) == 0:
                node.children.pop(ch, None)

        for i in  range(m):
            for j in range(n):
                dfs(root, i, j)
        return list(res)
    
    def add(self, node, word):
        for w in word:
            if w not in node.children:
                node.children[w] = Trie()
            node = node.children.get(w)
        node.word = word

class Trie:
    def __init__(self):
        self.children = {}
        self.word = None
```

## 648. Replace Words
Tag: Trie, Hash Map, Array, String
```python
class Trie:
    def __init__(self):
        self.children = {}
        self.is_root = False

class Solution:
    # TC: O(dn) d is dict, s is sentence, n is average len of word
    # SC: O(dn)
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        dummy_h = Trie()
        for root in dictionary:
            head = dummy_h
            for k in root:
                if k not in head.children:
                    head.children[k] = Trie()
                head = head.children[k]
            head.is_root = True

        res = []
        words = sentence.split(' ')
        for word in words:
            i = 0
            head = dummy_h
            for k in word:
                if k not in head.children:
                    i = len(word)
                    break
                head = head.children[k]
                i += 1
                if head.is_root:
                    break
            res.append(word[0:i])
        return " ".join(res)
```

## 677. Map Sum Pairs
Tag: Trie, Hash Map
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.total = 0

class MapSum:
    def __init__(self):
        self.map = {}
        self.trienode = TrieNode()
    # TC: O(n) n is key len
    # SC: O(n*k) k is total inserted k
    def insert(self, key: str, val: int) -> None:
        delta = val - self.map.get(key, 0)
        trie = self.trienode
        for k in key:
            if k not in trie.children:
                trie.children[k] = TrieNode()
            trie = trie.children[k]
            trie.total += delta
        self.map[key] = val

    def sum(self, prefix: str) -> int:
        trie = self.trienode
        for k in prefix:
            if k not in trie.children:
                return 0
            trie = trie.children[k]
        return trie.total
```
## ^^N-ary Tree
```python
# Definition for a Node.
class Node:
    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):
        self.val = val
        self.children = children
```

## 429. N-ary Tree Level Order Traversal
Tag: N-ary Tree, Recursion
```python
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        res = []
        q = deque()
        if root is not None:
            q.append(root)
        while len(q):
            size = len(q)
            res.append([])
            for _ in range(size):
                node = q.popleft()
                res[-1].append(node.val)
                for c in node.children:
                    q.append(c)
        return res
```
## 559. Maximum Depth of N-ary Tree
Tag: N-ary Tree, Recursion, Dynamic Programming, Top-down, Bottom-up
```python
class Solution:
    # Bottom-up, calculation bottom node first, then up to the root
    # TC: O(n)
    # SC: O(h)
    def maxDepth(self, root: 'Node') -> int:
        if root is None:
            return 0
        return 1 + max((self.maxDepth(c) for c in root.children), default = 0)

class Solution:
    # Top-down
    # TC: O(n)
    # SC: O(h)
    def maxDepth(self, root: 'Node') -> int:
        self.ans = 0
        def dfs(node, depth):
            if node is None:
                return
            self.ans = max(self.ans, depth + 1)
            for c in node.children:
                dfs(c, depth + 1)
        dfs(root, 0)
        return self.ans
```

## 589. N-ary Tree Preorder Traversal
Tag: N-ary Tree, Recursion
```python
class Solution:
    # TC: O(n) # n is total node count
    # SC: O(h) # h is tree height
    def preorder(self, root: 'Node') -> List[int]:
        res = []
        def helper(node):
            if node is None:
                return
            res.append(node.val)
            for c in node.children:
                helper(c)
        helper(root)
        return res
```

## 590. N-ary Tree Postorder Traversal
Tag: N-ary Tree, Recursion
```python
class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        res = []
        def helper(node):
            if node is None:
                return
            for c in node.children:
                helper(c)
            res.append(node.val)
        helper(root)
        return res
```


## ^^Binary Search Tree (BST)
A binary search tree (BST), a special form of a binary tree, satisfies the binary search property:

- The value in each node must be greater than (or equal to) any values stored in its left subtree.
- The value in each node must be less than (or equal to) any values stored in its right subtree.


- Inorder of BST is sorted


## 98. Validate Binary Search Tree
Tag: Binary Search Tree, Recursion

For method 1, the path is all the way up from left below to right above
![image.png](./leetcode.assets/image-20250717002.png)
And if there is right node, it works like this, the root of the right node has already been poped, and the right node is in between of it's left and parent of it's root
![image.png](./leetcode.assets/image-20250717003.png)
If only go right, it push one, pop one, check each node along the way
![image.png](./leetcode.assets/image-20250717004.png)
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    # Along the left nodes direction, all the way to the end
    # and then go up, and right
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        smallest = float('-inf')
        stack = []
        while root is not None or len(stack):
            while root is not None:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if root.val <= smallest:
                return False
            smallest = root.val
            root = root.right
        return True

    # TC: O(n)
    # SC: O(h)
    # The smallest and largest are defined by the nodes along the way to the specific node. That's also the defination of Binary Search Tree. Insert a new node to the left if it's less the root or right if larger than the root
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        return self.helper(root, float('-inf'), float('inf'))
    def helper(self, root, smallest, largest):
        if root is None:
            return True
        if root.val <= smallest or root.val >= largest:
            return False
        return self.helper(root.left, smallest, root.val) and self.helper(root.right, root.val, largest)
```
## 108. Convert Sorted Array to Binary Search Tree
Tag: Binary Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def helper(left, right):
            if left > right:
                return None
            mid = (left + right) // 2
            root = TreeNode(nums[mid])
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root
        return helper(0, len(nums) - 1)
```
## 173. Binary Search Tree Iterator
Tag: Binary Search Tree, Recursion
```python
class BSTIterator:
    # TC: O(n)
    # SC: O(n)
    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        self.root = root

    def next(self) -> int:
        while self.root:
            self.stack.append(self.root)
            self.root = self.root.left
        next = self.stack.pop()
        self.root = next.right
        return next.val

    def hasNext(self) -> bool:
        return self.root is not None or len(self.stack) > 0
```
## 235. Lowest Common Ancestor of a Binary Search Tree
Tag: Binary Search Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root is None:
            return root
        if q.val < root.val and p.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return  root

        # while True:
        #     if q.val < root.val and p.val < root.val:
        #         root = root.left
        #     elif p.val > root.val and q.val > root.val:
        #         root = root.right
        #     else:
        #         return  root

    # TC: O(n)
    # SC: O(h)
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root is None or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left is not None and right is not None:
            return root
        return left if left is not None else right
```

## 450. Delete Node in a BST
Tag: Binary Search Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if root is None:
            return root
        if key < root.val:
            root.left = self.deleteNode(root.left, key)
        elif key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            if root.left is None:
                return root.right
            if root.right is None:
                return root.left
            node = self.get_successor(root.right)
            root.val = node.val
            root.right = self.deleteNode(root.right, node.val)
        return root

    def get_successor(self, root):
        while root.left:
            root = root.left
        return root
```

## 700. Search in a Binary Search Tree
Tag: Binary Search Tree, Recursion
```python
# TC: O(logn) n is the total nodes, normally balance tree. O(n) the worst case
# SC: O(logn). O(n) the worst case
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root == None:
            return None
        
        if root.val == val:
            return root
        elif root.val < val:
            return self.searchBST(root.right, val)
        else:
            return self.searchBST(root.left, val)
```
## 701. Insert into a Binary Search Tree
Tag: BST, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root is None:
            return TreeNode(val)
        if root.val > val:
                root.left = self.insertIntoBST(root.left,val)
        else:
                root.right = self.insertIntoBST(root.right, val)
        return root

    # TC: O(n)
    # SC: O(1)
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root is None:
            return TreeNode(val)
        parent = None
        cur = root
        while cur is not None:
            parent = cur
            if cur.val > val:
                cur = cur.left
            else:
                cur = cur.right
        node = TreeNode(val)
        if parent.val > val:
            parent.left = node
        else:
            parent.right = node
        return root
```
## 703. Kth Largest Element in a Stream
Tag: Binary Search Tree, Recursion, Heap
```python
class KthLargest:
    # TC: O(n) heapify, O(logn) push pop
    # SC: O(k)
    def __init__(self, k: int, nums: List[int]):
        # TC: O(n) heapify On
        heapq.heapify(nums)
        self.k = k
        self.minheap = nums
        while len(self.minheap) > k:
            heapq.heappop(self.minheap)
        
    def add(self, val: int) -> int:
        if len(self.minheap) < self.k:
            heapq.heappush(self.minheap, val)
        else:
            heapq.heappushpop(self.minheap, val)
        return self.minheap[0]

    # ä½¿ç”¨äºŒå‰æ ‘ï¼Œæ€è·¯è§ https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/142/conclusion/1009/
    # å½“æ„æˆå¹³è¡¡äºŒå‰æ ‘çš„æ—¶å€™æ‰å¯ä»¥ï¼Œä¸å¹³è¡¡çš„æ—¶å€™ä¼šæ ‘ç»“æ„ä¸å¥½ï¼Œä¼šè¶…æ—¶
#     def __init__(self, k: int, nums: List[int]):
#         self.root = None
#         self.k = k
#         for i in range(len(nums)):
#             self.root=self.insert(self.root, nums[i])

#     def add(self, val: int) -> int:
#         self.root = self.insert(self.root, val)
#         return self.find(self.root, self.k)

#     def find(self, head, k):
#         right_count = head.right.count if head.right is not None else 0
#         total_right_count = right_count + head.weight
#         if right_count < k <= total_right_count:
#             return head.val
#         elif k > total_right_count:
#             return self.find(head.left, k-total_right_count)
#         else:
#             return self.find(head.right, k)

#     def insert(self, head, val):
#         if head is None:
#             return Node(val)
#         head.count += 1
#         if val < head.val:
#             head.left = self.insert(head.left,val)
#         elif val > head.val:
#             head.right = self.insert(head.right,val)
#         else:
#             head.weight += 1
#         return head


# class Node:
#     def __init__(self, val:int, count:int=1,weight:int=1,left:'Node'=None,right:'Node'=None):
#         self.val = val
#         self.count = count
#         self.weight = weight
#         self.left = left
#         self.right = right
```

# TreeSet

```java
// ä»å°åˆ°å¤§æ’åºçš„

// 1. create treeset
TreeSet<Integer> treeSet = new TreeSet<>();
// 2. add element
treeset.add(5);
// 3. remove element
treeset.remove(5);
// 4. size
treeset.size();
// 5. query
treeset.contains(5);
// 6. query first
treeset.first();
// 7. query last
treeset.last();
// 8. equal or larget given element
treeset.ceiling(3); // 5
treeset.higher(4); // only larger
// 9. equal or smaller than given element
treeset.floor(5); // 5
treeset.lower(5); // only smaller
// 10. delete first
treeset.pollFirst();
// 11. delete last
treeset.pollLast();
```





# Queue

**FIFO**

the first element added to the queue will be processed first

![image-20241106104525767](./leetcode.assets/image-20241106104525767.png)

**Enqueue**

Add at the end of the queue

**Dequeue**

Remove the first element

```python
from collections import deque
# deque is a two ends queue
# 1. Initialize
q = deque()

# 2. Add element (append at right)
q.append(1)
q.append(2)

q.appendleft(2)

# 3. Add and remove from left
q.popleft() # Queue, FIFO

# 4. Pop elemnt (remove from right)
q.pop() # Stack, FILO

# 5. Lenght
len(q)

# 6. Queue is empty
not q

# 7. Rotate n times
q.rotate(n)

# 8. Clear
q.clear()

# 9. Extend queue
q.extend([4,5])
q.extendleft([4,5])

# 10. Set size of queue
dq = deque(maxlen=3) # æœ€å¤šä¿ç•™3ä¸ªå…ƒç´ ï¼Œè¶…å‡ºä¼šè‡ªåŠ¨ä»å¦ä¸€ç«¯(å·¦è¾¹)å¼¹å‡º
```

```java
public class Main {
    public static void main(String[] args) {
        // 1. Initialize a queue.
        Queue<Integer> q = new LinkedList();
        // 2. Get the first element - return null if queue is empty.
        System.out.println("The first element is: " + q.peek());
        // 3. Push new element.
        q.offer(5);
        q.offer(13);
        q.offer(8);
        q.offer(6);
        // 4. Pop an element.
        q.poll();
        // 5. Get the first element.
        System.out.println("The first element is: " + q.peek());
        // 7. Get the size of the queue.
        System.out.println("The size is: " + q.size());
    }
}
```

## BSF
```java
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue<Node> queue;  // store all nodes which are waiting to be processed
    int step = 0;       // number of steps needed from root to current node
    // initialize
    add root to queue;
    // BFS
    while (queue is not empty) {
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                add next to queue;
            }
            remove the first node from queue;
        }
        step = step + 1;
    }
    return -1;          // there is no path from root to target
}
```


## Deque or LinkedList

```java
LinkedList<Integer> deque = new LinkedList<>();
// 1. add first
deque.addFirst(10); // [10]
// 2. add to last
deque.addLast(20);  // [10, 20]
// 3. remove first
deque.removeFirst();
// 4. remove last
deque.removeLast();
```

## 200. Number of Islands
Tag: BFS, Matrix, Array
```python
    def numIslands(self, grid: List[List[str]]) -> int:
        q = deque()
        islands = 0
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]

        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    q.append([i,j])
                    islands+=1
                while len(q):
                    size = len(q)
                    for _ in range(size):
                        node = q.popleft()
                        for dir in dirs:
                            x = dir[0] + node[0] 
                            y = dir[1] + node[1]
                            if x >= 0 and x < len(grid) and y >= 0 and y < len(grid[0]) and grid[x][y] == '1':
                                grid[x][y] = '0'
                                q.append([x,y])
        return islands
```

## 279. Perfect Squares
Tag: Queue, Math
```python
class Solution:
    # TC: O(n logn)
    # SC: O(n)
    def numSquares(self, n: int) -> int:
        squares = [i**2 for i in range(1,n+1,1)]
        visited = set()
        step = 0
        q = deque()
        q.append(n)
        while len(q):
            size = len(q)
            step += 1
            for _ in range(size):
                cur = q.popleft()
                for square in squares:
                    reminder = cur - square
                    if reminder == 0:
                        return step
                    if reminder < 0:
                        break
                    if reminder not in visited:
                        q.append(reminder)
                        visited.add(reminder)
        return -1
```

## 542. 01 Matrix 
Tag: Queue, Matrix
```python
class Solution:
    # TC: O(m x n)
    # SC: O(1)
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])
        res = [[float('inf')] * n for _ in range(m) ]
        q = deque()
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    q.append([i, j])
                else:
                    mat[i][j] = -1
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]
        while len(q):
            size = len(q)
            for _ in range(size):
                node = q.popleft()
                for i,j in dirs:
                    x = node[0] + i
                    y = node[1] + j
                    if 0 <= x < m and 0 <= y < n and mat[x][y] == -1:
                        mat[x][y] = mat[node[0]][node[1]] + 1
                        q.append([x,y])
        return mat

# DFS timeoutï¼Œ å¤ªå¤šé‡å¤çš„åœ°æ–¹ï¼Œå‰ªæä¸å¤Ÿ
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])
        res = [[float('inf')] * n for _ in range(m) ]
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    res[i][j] = 0
                    self.dfs(mat,i ,j, res)
        return res

    def dfs(self, mat, r, c, res):
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]
        for dx, dy in dirs:
            x = r + dx
            y = c + dy
            if x >= 0 and x < len(mat) and y >= 0 and y < len(mat[0]) and res[x][y] > res[r][c] + 1:
                res[x][y] = res[r][c] + 1
                self.dfs(mat, x, y, res)
```

## 622. Design Circular Queue
Tag: Queue
```java
class MyCircularQueue {
    private int[] queue;
    private int size;
    private int front;
    private int rear;
    public MyCircularQueue(int k) {
        queue = new int[k+1];
        size=k+1;
        front=0;
        rear=0;
    }
    
    public boolean enQueue(int value) {
        if(isFull()){
            return false;
        }
        queue[rear] = value;
        rear = (rear+1)%size;
        return true;
    }
    
    public boolean deQueue() {
        if(isEmpty()){
            return false;
        }
        front = (front+1)%size;
        return true;
    }
    
    public int Rear() {
        if(isEmpty()){
            return -1;
        }
        return queue[(rear-1+size)%size];
    }
    
    public int Front() {
        if(isEmpty()){
            return -1;
        }
        return queue[front];
    }
    
    public boolean isEmpty() {
        return front==rear;
    }
    
    public boolean isFull() {
        return (rear+1)%size==front;
    }
}
```

## 841. Keys and Rooms
Tag: Queue
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        q = deque()
        n = len(rooms)
        res = [False] * n
        q.append(0)

        while len(q):
            key = q.popleft()
            res[key] = True
            for k in rooms[key]:
                if not res[k]:
                    q.append(k)
        return all(res)
```

# Stack

**LIFO**

the newest element added to the queue will be processed first

**Add**

added at the end of the stack

**Remove**

remove the last element

```python
# 1. Initialize stack
stack = []

# 2. Append element
stack.append(1)
stack.append(2)

# 3. Pop element, return the poped item
value = stack.pop()

# 4. Peek element
top = stack[-1]

# 5. Length and empty
len(stack)

# 6. Search element
len(stack) -1 - stack.index(value)

```


```java
// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        // 1. Initialize a stack.
        Stack<Integer> s = new Stack<>();
        // 2. Push new element.
        s.push(5);
        s.push(13);
        s.push(8);
        s.push(6);
        // 3. Check if stack is empty.
        if (s.empty() == true) {
            System.out.println("Stack is empty!");
            return;
        }
        // 4. Pop an element.
        s.pop();
        // 5. Get the top element.
        System.out.println("The top element is: " + s.peek());
        // 6. Get the size of the stack.
        System.out.println("The size is: " + s.size());
        // 7. Search the element position in stack from head, from 1
        stack.search("Cherry");
    }
}
```



## DSF

```java
/*
 * Return true if there is a path from cur to target.
 * Using system call stack
 */
boolean DFS(Node cur, Node target, Set<Node> visited) {
    return true if cur is target;
    for (next : each neighbor of cur) {
        if (next is not in visited) {
            add next to visited;
            return true if DFS(next, target, visited) == true;
        }
    }
    return false;
}


/*
 * Return true if there is a path from cur to target.
 * DFS using an explicit stack
 */
boolean DFS(int root, int target) {
    Set<Node> visited;
    Stack<Node> stack;
    add root to visited;
    add root to stack;
    while (stack is not empty) {
        Node cur = the top element in stack;
        remove the cur from the stack;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to visited;
                add next to stack;
            }
        }
    }
    return false;
}
```
## 20. Valid Parentheses
Tag: Stack
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def isValid(self, s: str) -> bool:
        stack = []
        d = {
            "(": ")",
            "[": "]",
            "{": "}",
        }
        for char in s:
            if char in d:
                stack.append(char)
            elif len(stack) == 0:
                return False
            elif d.get(stack[-1]) == char:
                stack.pop()
            else:
                return False
        return True if len(stack) == 0 else False
```
## 84. Largest Rectangle in Histogram
Tag: Stack, Array, Monotonic Stack
```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        left, right = [0] * n, [n] * n
        mono_stack = []
        for i in range(n):
            while len(mono_stack) and heights[i] < heights[mono_stack[-1]]:
                right[mono_stack[-1]] = i
                mono_stack.pop()
            left[i] = (mono_stack[-1] +1) if len(mono_stack) else 0
            mono_stack.append(i)
        res = max( ((right[i] - left[i])) * heights[i] for i in range(n) )
        return res
    # TC: O(n)
    # SC: O(n)
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        n = len(heights)
        res = 0
        stack.append((0, -1))
        for i in range(n):
            height = heights[i]
            left_idx = i
            while height < stack[-1][0]:
                top_value, left_idx  = stack.pop()
                res = max(res, top_value * (i-left_idx))
            stack.append((height, left_idx))
        while len(stack) > 0:
            top_value, left_idx  = stack.pop()
            res = max(res, top_value * (n-left_idx))
        return res
        
```
## 133. Clone Graph
Tag: DFS, Node
```python
from typing import Optional
class Solution:
    # TC: O(n*m)  n is node number, m is the most edge in nodes
    # SC: O(1)
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        d = [0]*101
        
        return self.dfs(node, d)
    
    def dfs(self, node:  Optional['Node'], d: list['Node']) -> Optional['Node']:
        if node is None:
            return node
        
        if d[node.val]:
            return d[node.val]

        cp_node = Node(node.val)
        d[cp_node.val] = cp_node
        for neighbor in node.neighbors:
            cp_node.neighbors.append(self.dfs(neighbor, d))
        return cp_node

    # use dict
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        d = {}
        
        return self.dfs(node, d)
    
    def dfs(self, node:  Optional['Node'], d: dict[int, str]) -> Optional['Node']:
        if node is None:
            return node
        
        if d.get(node.val):
            return d.get(node.val)

        cp_node = Node(node.val)
        d[cp_node.val] = cp_node
        for neighbor in node.neighbors:
            cp_node.neighbors.append(self.dfs(neighbor, d))
        return cp_node
```

## 150. Evaluate Reverse Polish Notation
Tag: Stack, Math
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        s = ['+', '-', '*', '/']
        for ele in tokens:
            if ele not in s:
                stack.append(int(ele))
            else:
                var2 = stack.pop()
                var1 = stack.pop()
                if ele == '+':
                    stack.append(var1 + var2)
                elif ele == '-':
                    stack.append(var1 - var2)
                elif ele == '*':
                    stack.append(var1 * var2)
                elif ele == '/':
                    stack.append(int(var1 / var2))
        return stack[-1]
```

## 155. Min Stack
Tag: Stack, Node
```python
class MinStack:
    # TC: O(1)
    # SC: O(1) if output does not count as space consume
    def __init__(self):
        self.head=None

    def push(self, val: int) -> None:
        if self.head == None:
            self.head = Node(val, None, val)
        else:
            self.head = Node(val, self.head, min(val, self.head.min))

    def pop(self) -> None:
        self.head = self.head.next

    def top(self) -> int:
        return self.head.val

    def getMin(self) -> int:
        return self.head.min


class Node:
    def __init__(self, val: int, next: 'Node', min: int):
        self.val = val
        self.next = next
        self.min = min
```

## 200. Number of Islands
Tag: DFS, Matrix, Array
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        islands = 0
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    self.dfs(grid, i, j, dirs)
                    islands+=1
        return islands

    def dfs(self, grid: List[List[str]], i:int, j:int, dirs: List[List[int]]) -> None:
        grid[i][j] = '0'
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):
            return
        for dir in dirs:
            x = dir[0] + i
            y = dir[1] + j
            if x >= 0 and x < len(grid) and y >= 0 and y < len(grid[0]) and grid[x][y] == '1':
                self.dfs(grid, x, y, dirs)
```

## 225. Implement Stack using Queues
Tag: Stack, Queue
```python
class MyStack:

    def __init__(self):
        self.q = deque()    
    # TC: O(n)
    # SC: O(1)
    def push(self, x: int) -> None:
        self.q.append(x)
        for i in range(1, len(self.q), 1):
            self.q.append(self.q.popleft())

    def pop(self) -> int:
        return self.q.popleft()

    def top(self) -> int:
        return self.q[0] if not self.empty() else None 

    def empty(self) -> bool:
        return False if len(self.q) else True
```

## 232. Implement Queue using Stacks
Tag: Queue, Stack
```python
class MyQueue:
    # SC: O(n)
    def __init__(self):
        self.s1 = []
        self.s2 = []
        self.front = None

    # TC: O(1)
    def push(self, x: int) -> None:
        if len(self.s1) == 0:
            self.front = x
        self.s1.append(x)

    # TC: O(n)
    def pop(self) -> int:
        if len(self.s2) == 0:
            while len(self.s1):
                self.s2.append(self.s1.pop())
        return self.s2.pop()    

    # TC: O(1)
    def peek(self) -> int:
        if len(self.s2):
            return self.s2[-1]
        return self.front

    # TC: O(1)
    def empty(self) -> bool:
        return len(self.s1) == 0 and len(self.s2) == 0


class MyQueue:
    # SC: O(n) or O(1) if temp space does not count as complexity
    def __init__(self):
        self.s1 = []
        self.s2 = []

    # TC: O(n)
    def push(self, x: int) -> None:
        while len(self.s1):
            self.s2.append(self.s1.pop())
        self.s2.append(x)
        while len(self.s2):
            self.s1.append(self.s2.pop())

    # TC: O(1)
    def pop(self) -> int:
        return self.s1.pop()        

    # TC: O(1)
    def peek(self) -> int:
        return self.s1[-1]

    # TC: O(1)
    def empty(self) -> bool:
        return len(self.s1) == 0 and len(self.s2) == 0
```

## 394. Decode String
Tag: Stack, String

![image-20250708145453405](./leetcode.assets/image-20250708145453405.png)

```python
class Solution:
    # TC: O(n)  2n -> n
    # SC: O(n)
    def decodeString(self, s: str) -> str:
        stack = []
        for ele in s:
            if ele != ']':
                stack.append(ele)
            else:
                temp = ''
                while stack[-1] != '[':
                    temp = stack.pop() + temp
                stack.pop()
                times = ''
                while len(stack) and len(stack[-1]) == 1 and ord('0') <= ord(stack[-1]) <= ord('9'):
                    times = stack.pop() + times 
                multi_temp = ''
                for i in range(int(times)):
                    multi_temp += temp
                stack.append(multi_temp)
        res = ''
        while len(stack):
            res = stack.pop() + res
        return res
```

```java
class Solution {
    
    StringBuilder sb = new StringBuilder();
    
    public String decodeString(String s) {
        Queue<Character> queue = new LinkedList<>();
        for(char c: s.toCharArray()) queue.offer(c);
        return helper(queue);
    }

    String helper(Queue<Character> queue){
        StringBuilder sb = new StringBuilder();
        int num = 0;
        while(!queue.isEmpty()){
            char c = queue.poll();
            if(Character.isDigit(c)){
                num = num * 10 + c - '0';
            }else if(c == '['){
                String str = helper(queue);
                for(int i = 0; i < num; i++) sb.append(str);
                num = 0;
            }else if(c == ']'){
                break;
            }else{
                sb.append(c);
            }
        }
        return sb.toString();
    }
}
```

## 733. Flood Fill
Tag: Matrix, DFS
```python
class Solution:
    # TC: O(m x n)
    # SC: O(m x n) 1. stack, 2. visited
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        target = image[sr][sc]
        dirs = [
            [0,1],
            [0,-1],
            [1,0],
            [-1,0],
        ]
        m = len(image)
        n = len(image[0])
        visited = []
        for _ in range(m):
            visited.append([False] * n)
        
        self.dfs(image, sr,sc, target, dirs, color,visited)
        return image

    def dfs(self, image, sr, sc, target, dirs, color,visited):
        visited[sr][sc] = True
        image[sr][sc] = color

        for dir in dirs:
            r = sr + dir[0]
            c = sc + dir[1]
            if r >= 0 and r < len(image) and c >= 0 and c < len(image[0]) and not visited[r][c] and image[r][c] == target:
                self.dfs(image, r,c,target,dirs,color, visited)
```

## 739. Daily Temperatures
Tag: Stack
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        # From front to end
        stack = []
        n = len(temperatures)
        result = [0]*n
        for i in range(n):
            while len(stack) and temperatures[i] > temperatures[stack[-1]]:
                index = stack.pop()
                result[index] = i  - index
            stack.append(i)
        return result

        # # From back to front
        # stack = []
        # n = len(temperatures)
        # result = [0]*n
        # for i in range(n-1, -1, -1):
        #     while len(stack) and temperatures[stack[-1]] <= temperatures[i]:
        #         index = stack.pop()
        #     result[i] = stack[-1] - i if len(stack) else 0 
        #     stack.append(i)

        # return result
```

# Binary Search

Basic, check whether target in nums, O(logn)

```java
int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length - 1;
  while(left <= right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid - 1; }
  }

  // End Condition: left > right
  return -1;
}
```

Advanced, check the largest index that smaller than target, or smallest index that larger than target

``` java
int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length - 1;
  while(left < right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; } // or no this
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid; }
  }

  // Post-processing:
  // End Condition: left == right
  if(nums[left] == target) return left;
  return -1;
}
```



```java
int binarySearch(int[] nums, int target) {
    if (nums == null || nums.length == 0)
        return -1;

    int left = 0, right = nums.length - 1;
    while (left + 1 < right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    // Post-processing:
    // End Condition: left + 1 == right
    if(nums[left] == target) return left;
    if(nums[right] == target) return right;
    return -1;
}
```

## 4. Median of Two Sorted Arrays
Tag: Binary Search, Array
```python
# TC: O(log(m + n))
# SC: O(1)
'''
a0, a1, a2, a3, a4, | a5, a6, a7, a8
b0, b1, b2, b3, b4, | b5, b6, b7, b8, b9

nums1_upper_bound = (0 + m) // 2, find the upper bound of nums1
total_left = m + ((n - m + 1) // 2)
    we want the total left elements equal to or larger 1 than total right elements, so we add 1 here
nums2_mid_lower_bound = total_left - nums1_upper_bound - 1
nums2_upper_bound = total_left - nums1_upper_bound

We want to find the nums2 lower bound value's upper bound, so we use BS upper bound search, where b4 as the target value. That's the nums1[mid] >= nums2[total_left - mid - 1] equal equation mean.

i = l
j = total_left - i
There two are all upper bound index
'''
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1
        m = len(nums1) # short
        n = len(nums2) # long
        l, r = 0, m
        # After split two arrays, total left elements are equal to or more than 1 to the totall right elements 
        total_left = m + ((n - m + 1) // 2)
        while l < r:
            mid = (l + r) // 2
            # The equal maintains the upper bound restriction
            if nums1[mid] >= nums2[total_left - mid - 1]:
                r = mid
            else:
                l = mid + 1
        i = l
        j = total_left - i

        i_small = float('-inf') if i == 0 else nums1[i-1] 
        i_large = float('inf') if i == m else nums1[i] 
        j_small = float('-inf') if j == 0 else nums2[j-1] 
        j_large = float('inf') if j == n else nums2[j] 
        # Find the middle two values' median
        if (m+n) % 2 == 0:
            return (max(i_small, j_small) + min(i_large, j_large)) / 2
        # Find the largest among two smallest values
        else:
            return max(i_small, j_small)
        
        
```

## 33. Search in Rotated Sorted Array
Tag: Binary Search
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # TC: O(logn)
        # SC: O(1)
        # find rotate point
        left = 0
        right = len(nums) -1
        if nums[left] > nums[right]:
            while left < right:
                mid = left + (right - left) // 2
                if nums[mid] >= nums[0]:
                    left = mid + 1
                elif nums[mid] < nums[0]:
                    right = mid
        start = left
        left = 0
        right = len(nums) - 1
        if start != 0:
            if target >= nums[left]:
                right = start - 1
            elif target < nums[left]:
                left = start

        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
```

## 34. Find First and Last Position of Element in Sorted Array
Tag: Binary Search
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        if n == 0:
            return [-1,-1]
        # Upper bound
        left = 0
        right = n
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid
        upper = left
        # Lower bound
        left = 0
        right = n - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] >= target:
                right = mid
            else:
                left = mid + 1
        lower = left
        if nums[lower] != target:
            return [-1,-1]
        return [lower, upper-1]
```

## 69. Sqrt(x)
Tag: Binary Search
```python
class Solution:
    # TC: O(logx)
    # SC: O(1)
    def mySqrt(self, x: int) -> int:
        # upper bound
        left = 0
        right = x+1
        while left < right:
            mid = left + (right - left) // 2
            if mid ** 2 == x:
                return mid
            elif mid ** 2 < x:
                left = mid + 1
            else:
                right = mid
        return left - 1
```

## 153. Find Minimum in Rotated Sorted Array
Tag: Binary Search
```python
    # TC: O(logn)
    # SC: O(1)
    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            elif nums[mid] < nums[right]:
                right = mid
        return nums[left]


    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        if nums[left] < nums[right]:
            return nums[left]
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] >= nums[0]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

## 154. Find Minimum in Rotated Sorted Array II
Tag: Binary Search
```python
class Solution:
    # TC: O(n)
    # SC: O(1)
    def findMin(self, nums: List[int]) -> int:
        n = len(nums)
        left = 0
        right = n - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            elif nums[mid] < nums[right]:
                right = mid
            else:
                right -= 1

        return nums[left]
```
## 162. Find Peak Element
Tag: Binary Search
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def findPeakElement(self, nums: List[int]) -> int:
        left = 0
        n = len(nums)
        right = n - 1
        def get(i):
            if i == -1 or i == n:
                return float('-inf')
            return nums[i]
        while left <= right :
            mid = left + (right - left) // 2
            if get(mid - 1) < get(mid) > get(mid + 1):
                return mid
            if get(mid) < get(mid+1):
                left = mid + 1
            else:
                right = mid - 1
        return left
```

## 278. First Bad Version
Tag: Binary Search
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def firstBadVersion(self, n: int) -> int:
        left = 0
        right = n
        while left < right:
            mid = left + (right - left) // 2
            if isBadVersion(mid):
                right = mid
            else:
                left = mid + 1
        return left
```

## 367. Valid Perfect Square
Tag: Binary Search
```python
class Solution:
    # TC: O(log num)
    # SC: O(1)
    def isPerfectSquare(self, num: int) -> bool:
        left = 0
        right = num
        while left <= right:
            mid = left + (right - left) // 2
            v = mid * mid
            if v == num:
                return True
            elif v < num:
                left = mid + 1
            else:
                right = mid - 1
        return False if left * left != num else True
```

## 374. Guess Number Higher or Lower
Tag: Binary Search
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def guessNumber(self, n: int) -> int:
        left = 1
        right = n
        while left <= right:
            mid = left + (right - left) // 2
            v = guess(mid)
            if v == -1:
                right = mid - 1
            elif v == 1:
                left = mid + 1
            else:
                return mid
        return 0
```

## 410. Split Array Largest Sum
Tag: Binary Search, Array 
```python
class Solution:
    # TC: O(n logD) D is max to sum nums
    # SC: O(1)
    '''
        1. åˆ†å‰²kä»½åï¼Œæœ€å°çš„å’Œä¸€å®šå¤§äºæ•°ç»„ä¸­æœ€å¤§çš„å€¼ï¼Œç¡®å®šleft
        2. sumä¸ºright
        3. ç®—å‡ºmidï¼Œä¸ºç­”æ¡ˆæœ€å¤§çš„å’Œ midï¼Œæ‰€ä»¥åœ¨is_largerä¸­ï¼Œæ¯ä»½çš„åˆ†æ•°ç»„çš„å’Œå¿…é¡» å°äºç­‰äº mid
        4. å…¶ä¸­ï¼Œæ€»ä»½å„¿æ•°å°äº midï¼Œè¯´æ˜æ¯ä»½çš„å’ŒåŠ èµ·æ¥å¤ªå¤§äº†ï¼Œæœ€åä¸å¤Ÿåˆ†äº†ï¼Œmidåº”è¯¥ç¼©å°ï¼Œright = mid
        5. æ€»åˆ†æ•°ç­‰äºmidï¼Œåˆ™å¯èƒ½æ˜¯æ­£ç¡®ç­”æ¡ˆï¼Œéœ€è¦è¿›ä¸€æ­¥æ”¶ç¼©left right
    '''
    def splitArray(self, nums: List[int], k: int) -> int:
        # The smallest largest sum is the largest value in the array
        l = max(nums)
        r = sum(nums)

        while l < r:
            mid = (l+r) //2
            # The rightmost
            if self.is_larger(nums, mid, k):
                r = mid
            else:
                l = mid+1
        return l

    # Every sums must be smaller than the mid
    def is_larger(self, nums, mid, k):
        sums = 0
        # After compute valid sums, the last part has been left, so add 1 to the cnt
        cnt = 1
        for ele in nums:
            if sums + ele <= mid:
                sums+=ele
            else:
                sums = ele
                cnt += 1
        if cnt <= k:
            return True
        else:
            return False
```

## 658. Find K Closest Elements
Tag: Binary Search, Two Pointers
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        left, right = 0, len(arr) - k
        while left<right:
            mid = left + (right - left) // 2
            if x - arr[mid] <= arr[mid + k] - x:
                right = mid
            else:
                left = mid + 1
        return arr[left: left + k]

    # TC: O(logn + k)
    # SC: O(1)
    # Binary search and two pointer
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        # Lower bound
        left = 0
        right = len(arr) - 1
        while left < right:
            mid = left + (right - left) // 2
            if arr[mid] < x:
                left = mid + 1
            else:
                right = mid
        m = None
        if left > 0 and abs(arr[left - 1] - x) <= abs(arr[left] - x):
            m = left - 1
        else:
            m = left
        l = m
        r = m

        while k > 1:
            k -= 1
            if l == 0:
                r += 1
                continue
            if r == len(arr)-1:
                l -= 1
                continue
            if abs(arr[l - 1] - x) <= abs(arr[r + 1] - x):
                l -= 1
            else:
                r += 1
        return arr[l: r+1]
            
```

## 704. Binary Search
Tag: Binary Search, Array
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def search(self, nums: List[int], target: int) -> int:
        start = 0
        end = len(nums) -1
        while start <= end:
            mid = ( start + end ) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                end = mid -  1
            else:
                start = mid + 1
        return -1

    # Find upper bound to insert the target. The upper bound is the least value greater than target
    # Find lower bound to insert the target. The lower bound is the largest value greater than or equal to the target

    # The bound is where to insert the target to make the array keep sorted.
    # And when insert for example to index 2, it means the target now is inserted to index 2, and rest value from index 2, move right 1 position
    
    # [-1,2,2,2,2,12] target 2
    #             ^
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid
        # Now left == right and is at the upper bound index
        # If upper bound is at 0, it means the target is smaller than the smallest value in the array
        if  left > 0 and nums[left -1] == target:
            return left - 1
        return -1
        
    # The lower bound of insertion
    # [-1,2,2,2,2,12] target 2
    #     ^
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        if left < len(nums) and nums[left] == target:
            return left
        return -1
```

## 719. Find K-th Smallest Pair Distance
Tag: Binary Search, Array, Two Pointers
```python
class Solution:
    # TC: O(nlogn + nlogD) nlogn is nums.sort, nlogD: D is max nums value - min nums value. BS logD, inside it is O(n), so nlogD
    # SC: O(nlogn)

    '''
        1. å…ˆæ’åº
        2. å…ƒç´ ä¹‹é—´çš„è·ç¦»ï¼Œæœ€å°ä¸º0ï¼Œæœ€å¤§ä¸ºé¦–å°¾ä¸¤é¡¹çš„å·®
        3. æˆ‘ä»¬é€šè¿‡äºŒåˆ†æŸ¥æ‰¾ï¼Œè®¡ç®—è·ç¦»ä¸ºmidçš„æ—¶å€™ï¼Œä¸€å…±æœ‰å¤šå°‘ç»„å…ƒç´ å°äºç­‰äºå®ƒï¼Œé‚£ä¹ˆmidå°±æ˜¯ç¬¬å‡ ä¸ªå…ƒç´ 
        4. æ”¶ç¼©l r
            4.1 ä½¿ç”¨æ¡ä»¶ cnt <= k
                å½“cntå¤§äºkçš„æ—¶å€™ï¼Œå½“å‰midä»æœ‰å¯èƒ½æ˜¯ç­”æ¡ˆï¼Œæ¯”å¦‚å½“å‰è·ç¦»midæœ‰å¾ˆå¤šç»„ï¼Œè¿™äº›ç»„åŠ èµ·æ¥åˆšå¥½è¶…è¿‡käº†ï¼Œä½†è·ç¦»midä»æ˜¯ç­”æ¡ˆï¼Œæ‰€ä»¥ä½¿ç”¨r = midä¿ç•™midï¼Œæ‰€ä»¥ä¸æ˜¯r = mid - 1
                    æ¯”å¦‚ 1,2,3,4,5,6,7,100. k=4. è¿™é‡Œè·ç¦»ä¸º1çš„å¾ˆå¤šï¼Œæ¯”å¦‚midä¸º1çš„æ—¶å€™ï¼Œcntç»Ÿè®¡å‡ºæ¥ä¸º6ï¼Œè™½ç„¶å®ƒå¤§äº4ï¼Œä½†æ˜¯è·ç¦»midä»éœ€è¦ä¿ç•™ã€‚ç­‰å¾…è¿›ä¸€æ­¥äºŒåˆ†ç¼©å°å³å¯
                å½“cnt == kæ—¶ï¼Œå½“å‰è·ç¦»midå¾ˆæœ‰å¯èƒ½å¹¶æ²¡æœ‰åœ¨ä»»ä½•æ•°ç»„å¯¹ä¸­
                    æ¯”å¦‚ 1,100,500. k=2. ç¬¬ä¸€æ¬¡çš„æ—¶å€™mid=250ï¼Œè™½ç„¶è®¡ç®—å‡ºæ¥çš„cntæ˜¯1ï¼ˆ1ï¼Œ100ï¼‰.ä½†æ˜¯è·ç¦»250ä¸æ˜¯ä»»ä½•æ•°ç»„å¯¹çš„è·ç¦»ã€‚æ‰€ä»¥éœ€è¦è¿›ä¸€æ­¥ç¼©å°ï¼Œè€Œä¸è¦æå‰è¿”å›ã€‚å³cnt==kçš„æ—¶å€™ï¼Œä»ç»§ç»­æ‰€ä»¥ l å’Œ r
    '''
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        n = len(nums)
        nums.sort()
        l = 0
        r = nums[n-1]
        while l < r:
            mid = (l + r) // 2
            cnt = 0
            i = 0
            for j in range(n):
                while nums[j] - nums[i] > mid:
                    i += 1
                cnt += j - i
            if cnt >= k:
                r = mid
            else:
                l = mid + 1
        return l
```

## 744. Find Smallest Letter Greater Than Target
Tag: Binary Search
```python
class Solution:
    # TC: O(logn)
    # SC: O(1)
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        n = len(letters)
        target_v = ord(target)
        if ord(letters[0]) >target_v or ord(letters[n-1]) <= target_v:
            return letters[0]
        
        # Upper bound
        left = 1
        right = n-1
        while left < right:
            mid = left + (right - left) // 2
            if ord(letters[mid]) <= target_v:
                left = mid + 1
            else:
                right = mid
        return letters[left]
```

## 1051. Height Checker
Tag: Array, Sort
![image-20230614225500049](leetcode.assets/image-20230614225500049.png)

```python
# TC: O(max(sort, n))
# SC: O(n)
class Solution(object):
    def heightChecker(self, heights):
        """
        :type heights: List[int]
        :rtype: int
        """
        original_height = [ele for ele in heights]
        heights.sort()
        res = 0
        for i in range(len(heights)):
            if original_height[i] != heights[i]:
                res += 1
        return res
```

å…ˆsortï¼Œå†æ¯”è¾ƒ

```
class Solution {
    public int heightChecker(int[] heights) {
                int[] originHeights = heights.clone();
        Arrays.sort(originHeights);
        int diffNum = 0;
        for (int i = 0; i < heights.length; i++) {
            if(heights[i] != originHeights[i]){
                diffNum++;
            }
        }
        return diffNum;
    }
}
```



# Sorting æ’åºç®—æ³•

## å¿«æ’ QuickSort

**Partition**

Find the kth most element

1. è·å–å…ƒç´ ã€‚å¦‚æœæ˜¯å¯¹æœ¬èº«å¤§å°æ¯”è¾ƒï¼Œä¸ç”¨å¤šä½™æ“ä½œã€‚å¦‚æœæ˜¯freqç­‰ç›¸å…³è”çš„åˆ¤æ–­ï¼Œåˆ™é€šè¿‡hashmap å­˜å‚¨å€¼å’Œå®ƒå¯¹åº”çš„å¤§å°ï¼ˆfreqç­‰ï¼‰
2. é€‰å®šleftï¼Œrightï¼Œå’Œä¸­é—´çš„ä¸€ä¸ªéšæœºå…ƒç´ ï¼ˆrandom.nextIntï¼‰ï¼Œå¼€å§‹partition
3. å°†pivot indexä¸rightäº¤æ¢
4. ä»leftåˆ°right -1 éå†ï¼Œä½¿ç”¨åŒæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€ä¸ªå°äºpivotå…ƒç´ è¯¥æ”¾ç½®çš„ä½ç½®storeIndexï¼Œä¸€ä¸ªéå†i
5. å°äºpivotï¼ˆfreqï¼‰çš„ç§»åŠ¨åˆ°storeIndexï¼Œ++
6. çŸ¥é“iåˆ°right-1
7. rightä¸storeIndexäº¤æ¢
8. å®ç°äº†storeIndex ä¹Ÿå°±æ˜¯ pivotå…ƒç´ å·¦è¾¹ï¼ˆåˆ°leftï¼‰æ¯”å®ƒå°ï¼Œå³è¾¹ï¼ˆåˆ°rightï¼‰æ¯”å®ƒå¤§
9. æ­¤æ—¶storeIndexä½ç½®ä¸ºn-kæœ€å¤§çš„ä½ç½®

```java

int partition(int left, int right){
	Random random = new Random();
    int pivot_index = random.nextInt(right - left + 1) + left;
    
    // Optional: int value = hashmap.get(pivot_index);
    swap(nums, pivot_index, right);
    int storeIndex = left;
    for(int i = left; i < right; i++){
        if(hashmap.get(nums[i]) < value){
            swap(i, storeIndex);
            storeIndex ++;
        }
    }
    
    swap(right, storeIndex);
    return storeIndex;
}
```

## 912. Sort an Array

## Merge Sort
```python
class Solution:
    # Top down
    # å‡å¦‚æœ‰8ä¸ªæ•°å­—ï¼Œå…ˆåˆ†æˆ4ä¸ª4ä¸ªåˆå¹¶ï¼Œç„¶ååˆ†æˆ2ä¸ª2ä¸ªåˆå¹¶ï¼Œç„¶ååˆ†æˆ1ä¸ª1ä¸ªåˆå¹¶
    # TC: O(n logn)
    def sortArray(self, nums: List[int]) -> List[int]:
        # Merge sort
        n = len(nums)
        if n <= 1:
            return nums
        mid = n // 2
        merged_left = self.sortArray(nums[0: mid])
        merged_right = self.sortArray(nums[mid: n])
        return self.merge(merged_left, merged_right)

    def merge(self, nums1, nums2):
        m = len(nums1)
        n = len(nums2)
        p = 0
        q = 0
        res = []
        while p<m and q<n:
            if nums1[p] < nums2[q]:
                res.append(nums1[p])
                p += 1
            else:
                res.append(nums2[q])
                q+=1
        while p < m:
            res.append(nums1[p])
            p+=1
        while q < n:
            res.append(nums2[q])
            q+=1
        return res
    # Bottom up
    # æŠŠæ¯ä¸ªæ•°å­—çœ‹æˆä¸€ä»½ï¼Œå…ˆ1ä¸ª1ä¸ªåˆå¹¶ï¼Œç„¶å2ä¸ª2ä¸ªåˆå¹¶ï¼Œç„¶å4ä¸ª4ä¸ªåˆå¹¶
    class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        # Merge sort
        width = 1
        n = len(nums)
        while width < n:
            for i in range(0, n, width * 2):
                mid = i + width
                nums1 = nums[i: i + width]
                nums2 = nums[i+ width: i + width * 2]
                merged = self.merge(nums1, nums2)
                nums[i: i+len(merged)] = merged
            width *= 2
        return nums

    def merge(self, nums1, nums2):
        m = len(nums1)
        n = len(nums2)
        p = 0
        q = 0
        res = []
        while p<m and q<n:
            if nums1[p] < nums2[q]:
                res.append(nums1[p])
                p += 1
            else:
                res.append(nums2[q])
                q+=1
        while p < m:
            res.append(nums1[p])
            p+=1
        while q < n:
            res.append(nums2[q])
            q+=1
        return res

    # Quick sort
    def sortArray(self, nums: List[int]) -> List[int]:
        # Quick sort
        self.qsort(nums, 0, len(nums) - 1)
        
    
    def qsort(self, nums, lo, hi):
        if lo < hi:
            pivot = self.partition(nums, lo, hi)
            self.qsort(nums, lo, pivot - 1)
            self.qsort(nums, pivot + 1, hi)
    
    def partition(self, nums, lo, hi):
        idx = random.randint(lo, hi)
        nums[idx], nums[hi] = nums[hi], nums[idx]
        target = nums[hi]
        i = lo
        for j in range(lo, hi):
            if nums[j] < target:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        nums[i], nums[hi] = nums[hi], nums[i]
        return i
```

### ?couting sortï¼Ÿ


# Bit manupulation (python)

```python

# äºŒè¿›åˆ¶ï¼ˆ0b å¼€å¤´ï¼‰ï¼Œå€¼æ˜¯ 5
print(0b101)  # è¾“å‡º: 5

# Java ä¸­çš„ 0e1011 æ˜¯ç§‘å­¦è®¡æ•°æ³•ï¼ˆ0 * 10^1011 = 0.0ï¼‰
# Python ä¸­ç±»ä¼¼å†™æ³•ä¸ºï¼š
print(0e1011)  # è¾“å‡º: 0.0

# å…«è¿›åˆ¶ï¼ˆ0o å¼€å¤´ï¼‰ï¼Œ011 åœ¨ Java æ˜¯å…«è¿›åˆ¶ 11ï¼Œå³åè¿›åˆ¶ 9
print(0o11)  # è¾“å‡º: 9

# åè¿›åˆ¶
print(11)  # è¾“å‡º: 11

# åå…­è¿›åˆ¶ï¼ˆ0x å¼€å¤´ï¼‰ï¼Œ0x11C æ˜¯åè¿›åˆ¶ 284
print(0x11C)  # è¾“å‡º: 284

# æ ¼å¼åŒ–ä¸º 10 ä½å®½åº¦çš„åå…­è¿›åˆ¶ï¼Œå°å†™ï¼Œå·¦ä¾§è¡¥ 0
print("{:010x}".format(7))  # è¾“å‡º: 0000000007

# æ ¼å¼åŒ–ä¸º 10 ä½å®½åº¦çš„å…«è¿›åˆ¶ï¼Œå·¦ä¾§è¡¥ 0
print("{:010o}".format(13))  # è¾“å‡º: 0000000015

# æ™®é€šåå…­è¿›åˆ¶æ ¼å¼åŒ–
print("{:x}".format(7))  # è¾“å‡º: 7

# æ™®é€šå…«è¿›åˆ¶æ ¼å¼åŒ–
print("{:o}".format(13))  # è¾“å‡º: 15

# å°†æ•´æ•°è½¬ä¸ºäºŒè¿›åˆ¶å­—ç¬¦ä¸²
print(bin(11)[2:])  # è¾“å‡º: 1011

# å¾—åˆ°æœ€åä¸€ä½1
x & (-x)

# å»é™¤æœ€ä½ä¸€ä½1
x & (x-1)

# å–å
~x

# è´Ÿæ•°
-x

# å·¦ç§»ï¼ˆä¹˜ä»¥2ï¼‰
x << 1

# å³ç§»ï¼ˆé™¤ä»¥2ï¼‰
x >> 1
```



# Bit manipulation

## è¿›åˆ¶

![image-20230620122335323](./leetcode.assets/image-20230620122335323.png)

![image-20230620122349416](./leetcode.assets/image-20230620122349416.png)

## è®¡ç®—æœºä¸­çš„æ•´æ•°è¡¨ç¤º

![image-20230620122154047](./leetcode.assets/image-20230620122154047.png)

![image-20230620122254983](./leetcode.assets/image-20230620122254983.png)![image-20230620122302812](./leetcode.assets/image-20230620122302812.png)

## ä½è¿ç®—çš„æ¦‚è¿°å’Œæ€§è´¨

![image-20230620123514732](./leetcode.assets/image-20230620123514732.png)![image-20230620123536970](./leetcode.assets/image-20230620123536970.png)![image-20230620123552227](./leetcode.assets/image-20230620123552227.png)

## Javaä¸­çš„äºŒè¿›åˆ¶è¾“å‡º

```java

System.out.println(0b101);//äºŒè¿›åˆ¶:5  ï¼ˆ0bå¼€å¤´çš„ï¼‰
System.out.println(0e1011);//0.0
System.out.println(011);//å…«è¿›åˆ¶:9 (0å¼€å¤´çš„)
System.out.println(11);//åè¿›åˆ¶:11
System.out.println(0x11C);//åå…­è¿›åˆ¶:284 Â  ï¼ˆ0xå¼€å¤´çš„ï¼‰
System.out.printf("%010x\n",7);//0000000007 Â  æŒ‰10ä½åå…­è¿›åˆ¶è¾“å‡ºï¼Œå‘å³é é½ï¼Œå·¦è¾¹ç”¨0è¡¥é½
System.out.printf("%010o\n",13);//0000000015 Â   æŒ‰10ä½å…«è¿›åˆ¶è¾“å‡ºï¼Œå‘å³é é½ï¼Œå·¦è¾¹ç”¨0è¡¥é½
System.out.printf("%x\n",7);//7 Â  æŒ‰16è¿›åˆ¶è¾“å‡º
System.out.printf("%o\n",13);//15 Â  æŒ‰8è¿›åˆ¶è¾“å‡º
System.out.println(Integer.toBinaryString(11));//1011 äºŒè¿›åˆ¶
```

## Javaä½è¿ç®—

```java
// 1. æŒ‰ä½ä¸ï¼ˆ&ï¼‰å¯¹ä¸¤ä¸ªæ•°çš„æ¯ä¸€ä½æ‰§è¡Œä¸è¿ç®—ï¼Œåªæœ‰å½“å¯¹åº”çš„ä½éƒ½ä¸º 1 æ—¶ç»“æœæ‰ä¸º 1ã€‚
int a = 5;  // 0101
int b = 3;  // 0011
int result = a & b;  // 0001 -> 1
// 2. æŒ‰ä½æˆ–ï¼ˆ|ï¼‰å¯¹ä¸¤ä¸ªæ•°çš„æ¯ä¸€ä½æ‰§è¡Œæˆ–è¿ç®—ï¼Œåªè¦æœ‰ä¸€ä¸ªå¯¹åº”çš„ä½ä¸º 1ï¼Œç»“æœå°±ä¸º 1ã€‚
int a = 5;  // 0101
int b = 3;  // 0011
int result = a | b;  // 0111 -> 7
// 3. æŒ‰ä½å¼‚æˆ–ï¼ˆ^ï¼‰å¯¹ä¸¤ä¸ªæ•°çš„æ¯ä¸€ä½æ‰§è¡Œå¼‚æˆ–è¿ç®—ï¼Œåªæœ‰å½“ä¸¤ä¸ªä½ä¸åŒï¼ˆä¸€ä¸ªä¸º 1ï¼Œä¸€ä¸ªä¸º 0ï¼‰æ—¶ï¼Œç»“æœæ‰ä¸º 1ã€‚
int a = 5;  // 0101
int b = 3;  // 0011
int result = a ^ b;  // 0110 -> 6
// 4. æŒ‰ä½å–åï¼ˆ~ï¼‰å¯¹ä¸€ä¸ªæ•°çš„æ¯ä¸€ä½å–åï¼Œå°† 1 å˜ä¸º 0ï¼Œ0 å˜ä¸º 1ã€‚æ³¨æ„ï¼š Java ä¸­æ•´æ•°ä»¥è¡¥ç å½¢å¼å­˜å‚¨ï¼Œæ‰€ä»¥å¯¹æ­£æ•°å–åä¼šå¾—åˆ°è´Ÿæ•°ã€‚
int a = 5;  // 0101
int result = ~a;  // 1010 (å–å) -> -6
// 5. å·¦ç§»ï¼ˆ<<ï¼‰å°†ä¸€ä¸ªæ•°çš„ä½å‘å·¦ç§»åŠ¨æŒ‡å®šçš„ä½æ•°ï¼Œä½ä½è¡¥ 0ã€‚ç›¸å½“äºä¹˜ä»¥ 2^ğ‘›
int a = 5;  // 0000 0101
int result = a << 2;  // 0001 0100 -> 20
// 6. ç®—æœ¯å³ç§»ï¼ˆ>>ï¼‰å°†ä¸€ä¸ªæ•°çš„ä½å‘å³ç§»åŠ¨æŒ‡å®šçš„ä½æ•°ï¼Œé«˜ä½ç”¨ç¬¦å·ä½å¡«å……ï¼ˆæ­£æ•°è¡¥ 0ï¼Œè´Ÿæ•°è¡¥ 1ï¼‰ï¼Œç›¸å½“äºå¯¹ 2 çš„å¹‚æ¬¡å–æ•´é™¤ï¼ˆå¸¦ç¬¦å·ï¼‰ã€‚
int a = 5;    // 0000 0101
int result = a >> 1;  // 0000 0010 -> 2

int b = -5;   // 1111 1011 (è¡¥ç å½¢å¼)
int result = b >> 1;  // 1111 1101 -> -3\
// 7. æ— ç¬¦å·å³ç§»ï¼ˆ>>>ï¼‰æ— ç¬¦å·å³ç§»æ—¶ï¼Œä¸ç®¡æ­£è´Ÿï¼Œé«˜ä½éƒ½ç”¨ 0 å¡«å……ï¼Œä¸ä¿ç•™ç¬¦å·ä½ã€‚é€‚ç”¨äºå¤„ç†æ— ç¬¦å·æ•°ã€‚
int a = -5;   // 1111 1011 (è¡¥ç å½¢å¼)
int result = a >>> 1;  // 0111 1101 -> 2147483645
// 8. å¤åˆè¿ç®—ç¬¦ä½è¿ç®—çš„å¤åˆèµ‹å€¼æ“ä½œç¬¦ï¼Œä¾‹å¦‚ &=, |=, ^=, <<=, >>=, >>>= ç­‰ï¼Œç”¨äºå¯¹åŸå€¼è¿›è¡Œä½æ“ä½œå¹¶èµ‹å€¼ã€‚
int a = 5;     // 0101
a |= 3;        // 0111 -> 7
```







## 137. Single Number II

å¦‚æœå‡ºç°0æ¬¡ï¼Œoneså’Œtwoséƒ½æ˜¯0ï¼Œ

å¦‚æœå‡ºç°1æ¬¡ï¼Œåˆ™onesä¸ºå€¼ï¼Œtwosä¸º0ï¼Œ

å¦‚æœå‡ºç°2æ¬¡ï¼Œåˆ™twosä¸ºå€¼ï¼Œonesä¸º0ï¼Œ

å¦‚æœå‡ºç°3æ¬¡ï¼Œåˆ™onesä¸º0ï¼Œtwosä¸º0

```java
    public int singleNumber(int[] nums) {
                int ones = 0;
        int twos = 0;

        for (int i = 0; i < nums.length; i++) {
            ones = (ones ^ nums[i]) & ~twos;
            twos = (twos ^ nums[i]) & ~ones;
        }
        return ones;
    }
```

## 160. Intersection of Two Linked Lists
Tag: Linked List, Two Pointers
![image-20230720214811176](leetcode.assets/image-20230720214811176.png)

![image-20230720214831352](leetcode.assets/image-20230720214831352.png)

![image-20230720214928497](leetcode.assets/image-20230720214928497.png)

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
# TC: O(n)
# SC: O(1)
class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        p1 = headA
        p2 = headB

        while p1 is not p2:
            p1 = p1.next if p1 is not None else headB
            p2 = p2.next if p2 is not None else headA
        return p1
        
```

æ–¹æ³•ä¸€ï¼š

ä¸€æ¡çº¿èµ°Aï¼Œèµ°å®ŒAèµ°B

ä¸€æ¡çº¿èµ°Bï¼Œèµ°å®ŒBèµ°A

è¿™æ ·å°±è¾¾åˆ°ä¸¤ä¸ªé•¿åº¦æ‹¼æ¥èµ·æ¥çš„æ•ˆæœï¼Œä¹Ÿå°±æ˜¯ä¸€æ ·é•¿ï¼ˆA+Bï¼‰



```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        ListNode b = headB;

        while(a != b){
            a = a == null ? headB : a.next;
            b = b == null ? headA : b.next;
        }

        return a;


        // ListNode a = headA;
        // ListNode b = headB;
        // int sizeA = 0;
        // int sizeB = 0;
        // while(a != null){
        //     sizeA ++;
        //     a = a.next;
        // }
        // while(b != null){
        //     sizeB ++;
        //     b = b.next;
        // }

        // a = headA;
        // b = headB;
        // int diff = sizeA - sizeB;
        
        // if(diff != 0){
        //     if(diff > 0){
        //         while(diff != 0){
        //             a = a.next;
        //             diff--;
        //         }
        //     }else{
        //         while (diff != 0){
        //             b = b.next;
        //             diff++;
        //         }
        //     }
        // }
        
        // while(a != null){
        //     if(a.equals(b)){
        //         return a;
        //     }
        //     a = a.next;
        //     b = b.next;
        // }
        // return null;
    }
```







## [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)
![æˆªå±2023-06-20 21.47.43](./leetcode.assets/æˆªå±2023-06-20 21.47.43.png)



```java
    public int reverseBits(int n) {
        int reversed = 0, power = 31;
        while (n != 0) {
            reversed += (n & 1) << power;
            n >>>= 1;
            power--;
        }
        return reversed;
    }
```



## [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)

![image-20230620215332289](./leetcode.assets/image-20230620215332289.png)

![image-20230620215412916](./leetcode.assets/image-20230620215412916.png)

```java
    public int hammingWeight(int n) {
        int count = 0;
        for (int i = 0; i < 32; i++) {
            count += (n >> i) & 1;
        }
        return count;
    }
    
    // ä½è¿ç®—
    
        public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            n = n & (n - 1);
            count++;
        }
        return count;
    }

```



## 218. Bitwise AND of Numbers Range



â€‹	![image-20230621175541188](./leetcode.assets/image-20230621175541188.png)



è§„å¾‹ï¼š

èµ·å§‹ä½å’Œç»ˆæ­¢ä½å¾€å³è¾¹ç§»åŠ¨ï¼Œç§»åŠ¨åˆ°ä¸¤ä¸ªæ•°å­—ç›¸åŒçš„æ—¶å€™ï¼ˆåŠ ä¸Šä¸­é—´çš„æ•°å­—è¿™ä¸ªæ—¶å€™éƒ½ä¼šç›¸åŒï¼‰ï¼Œå³æ˜¯æ‰€æœ‰æ•°å­—çš„å…±åŒéƒ¨åˆ†

ç„¶åå†é‡æ–°è¡¥0è¿˜åŸæ•°å­—

æ–¹æ³•1ï¼š

ç§»ä½ï¼Œç”¨ä¸Šè¿°è§„å¾‹ç§»åŠ¨leftå’Œrightï¼Œç›´åˆ°ç›¸åŒæ—¶ï¼Œå¾€åè¡¥0

```
class Solution {
    public int rangeBitwiseAnd(int left, int right) {
        
        int shift = 0;
        while (left != 0){
            if(left == right){
                break;
            }
            left>>=1;
            right>>=1;
            shift++;
        }
        while (shift!=0){
            left = left << 1;
            shift--;
        }
        return left;
    }
    
    å†™æ³•2ï¼š
    public int rangeBitwiseAnd(int m, int n) {
        int shift = 0;
        // æ‰¾åˆ°å…¬å…±å‰ç¼€
        while (m < n) {
            m >>= 1;
            n >>= 1;
            ++shift;
        }
        return m << shift;
    }

}
```



æ–¹æ³•2ï¼š

### Brian Kernighan ç®—æ³•

```
        while (m < n) {
        	n &= n-1;
        }
        return n;
```

## 371. Sum of Two Integers

![image-20230620223137032](./leetcode.assets/image-20230620223137032.png)

```java
    public int getSum(int a, int b) {
        
        while (b!=0){
            int temp = a^b; // å½“å‰ä½
            b = (a&b) << 1; // è¿›ä½
            a = temp;
        }
        return a;
    }
```

## 421. Maximum XOR of Two Numbers in an Array
Tag: Trie, Bit Manupulation, Hash Table
```python
class Solution:
    # TC: O(31*n)
    # SC: O(n)
    def findMaximumXOR(self, nums: List[int]) -> int:
        s = set()
        x = 0
        for i in range(30,-1,-1):
            for num in nums:
                s.add(num >> i)
            xNext = x*2+1
            found = False
            for num in nums:
                if (num >> i) ^ xNext in s:
                    found = True
                    break
            if found:
                x = xNext
            else:
                x = xNext - 1
            s.clear()
        return x
```



# æ»‘åŠ¨çª—å£

## [674. Longest Continuous Increasing Subsequ](https://leetcode.com/problems/longest-continuous-increasing-subsequence/)

![image-20230618155022686](./leetcode.assets/image-20230618155022686.png)

æ»‘åŠ¨çª—å£

```java
        int ans = 0;
        int i = 0;
        int j = 0;
        while (j < nums.length){
            if(j > 0 && nums[j] >= nums[j-1]){
                i = j;
            }
            ans = Math.max(ans, j - i + 1);
            j++;

        }
    
    // solution2
    
    public int findLengthOfLCIS(int[] nums) {
        int ans = 1;
        int len = 1;
        for (int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i-1]){
                len ++;
            }else{
                ans = Math.max(ans, len);
                len = 1;
            }
        }
        ans = Math.max(ans, len);
        return ans;
    }
```

# Recursion
## 22. Generate Parentheses
Tag: Recursion, Backtracking
```python
class Solution:
    # TC: O(2^n)
    # OC: O(n)
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def generate(s, op, close):
            if close == n:
                res.append(s)
                return
            if op < n:
                generate(s + '(', op + 1, close)
            if close < op:
                generate(s + ')', op, close + 1)
        generate('', 0,0)
        return res

    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        lst = []
        def backtracking(openN, closeN):
            if closeN == n:
                res.append(''.join(lst))
                return
            if openN < n:
                lst.append('(')
                backtracking(openN + 1, closeN)
                lst.pop()
            if closeN < openN:
                lst.append(')')
                backtracking(openN, closeN+1)
                lst.pop()
        backtracking(0,0)
        return res

    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        lst = []
        options = ['(', ')']

        self.left_count = 0
        self.right_count = 0
        def is_valid(parenthese):
            if parenthese == '(':
                return True if self.left_count < n else False
            else:
                return True if self.right_count < self.left_count else False
        def backtracking():
            if len(lst) == n*2:
                res.append(''.join(lst))
                return
            for option in options:
                if is_valid(option):
                    lst.append(option)
                    if option == '(':
                        self.left_count += 1
                    else:
                        self.right_count += 1
                    backtracking()
                    if option == '(':
                        self.left_count -= 1
                    else:
                        self.right_count -= 1
                    lst.pop()
        backtracking()
        return res
```
## 24. Swap Nodes in Pairs
Tag: Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None or head.next == None:
            return head
        
        n_round = head.next.next

        next = head.next
        next.next = head
        head.next = self.swapPairs(n_round)
        return next
```
## 37. Sudoku Solver
Tag: Recursion, Backtracking, Matrix
```python
class Solution:
    # TC: O(9^k) k is empty box number
    # SC: O(k)
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows = [set() for i in range(9)]
        cols = [set() for i in range(9)]
        blocks = [set() for i in range(9)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    value = board[i][j]
                    rows[i].add(value)
                    cols[j].add(value)
                    idx = i // 3 * 3 + j // 3
                    blocks[idx].add(value)

        def backtracking(i, j):
            if i==9:
                return True
            if j==9:
                return backtracking(i+1,0)
            if board[i][j] != '.':
                return backtracking(i, j+1)

            idx = i // 3 * 3 + j // 3
            for num in range(1, 10, 1):
                str_num = str(num)
                if str_num not in rows[i] and str_num not in cols[j] and str_num not in blocks[idx]:
                    rows[i].add(str_num)
                    cols[j].add(str_num)
                    blocks[idx].add(str_num)
                    board[i][j] = str_num

                    res = backtracking(i, j + 1)
                    if res == True:
                        return True
                    board[i][j] = '.'
                    rows[i].remove(str_num)
                    cols[j].remove(str_num)
                    blocks[idx].remove(str_num)
            return False

        backtracking(0, 0)

    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """

        def is_valid(i, j, num):
            for k in range(9):
                if num == board[i][k] or num == board[k][j] or board[i // 3 * 3 + (k // 3)][j // 3 * 3 + (k % 3)] == num:
                    return False
            return True

        def backtracking(i, j):
            if i==9:
                return True
            if j==9:
                return backtracking(i+1,0)
            if board[i][j] != '.':
                return backtracking(i, j+1)

            idx = i // 3 * 3 + j // 3
            for num in range(1, 10, 1):
                str_num = str(num)
                if is_valid(i, j, str_num):
                    board[i][j] = str_num
                    res = backtracking(i, j + 1)
                    if res == True:
                        return True
                    board[i][j] = '.'
            return False

        backtracking(0, 0)
```
## 51. N-Queens
Tag: Recursion, Backtracking, Bit Manipulation
```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        cols = set()
        diag1 = set()
        diag2 = set()
        res = []

        def backtracking(row, lst):
            if row == n:
                res.append(lst.copy())
                return
            for col in range(n):
                if col not in cols and row + col not in diag1 and row - col not in diag2:
                    cols.add(col)
                    diag1.add(row + col)
                    diag2.add(row - col)
                    s = ''
                    for i in range(n):
                        s += 'Q' if i == col else '.'
                    lst.append(s)
                    backtracking(row + 1, lst)
                    cols.remove(col)
                    diag1.remove(row + col)
                    diag2.remove(row - col)
                    lst.pop()
        backtracking(0, [])
        return res
```
## 52. N-Queens II
Tag: Recursion, Backtracking, Bit Manipulation
```python
class Solution:
    # TC: O(n!)
    # SC: O(1)
    def totalNQueens(self, n: int) -> int:
        def solve(row, cols, diag1, diag2):
            if row == n:
                return 1
            count = 0
            availablePositions = ((1<<n) - 1) & ~(cols | diag1 | diag2)
            while availablePositions:
                position =  availablePositions & (-availablePositions)
                availablePositions = availablePositions & (availablePositions-1)
                count += solve(row + 1, cols | position, (diag1 | position) << 1, (diag2 | position) >> 1)
            return count
        return solve(0, 0, 0, 0)

    # TC: O(n!)
    # SC: O(n)
    def totalNQueens(self, n: int) -> int:
        def backtrack_nqueen(row):
            if row == n:
                return 1
            count = 0
            for col in range(n):
                # iterate through columns at the curent row.
                if col not in columns and row - col not in diag1 and row + col not in diag2:
                    # explore this partial candidate solution, and mark the attacking zone
                    columns.add(col)
                    diag1.add(row - col)
                    diag2.add(row + col)
                    count += backtrack_nqueen(row + 1)
                    columns.remove(col)
                    diag1.remove(row - col)
                    diag2.remove(row + col)
            return count
        columns = set()
        diag1 = set()
        diag2 = set()
        return backtrack_nqueen(0)

    # TC: O(n!)
    # SC: O(n)
    def totalNQueens(self, n: int) -> int:
        placed = set()
        
        def is_not_under_attack( row, col):
            for queen in placed:
                r = queen[0]
                c = queen[1]
                if row == r or col == c or r+c == row + col or r-row == c-col:
                    return  False
            return True

        def place_queen( row, col):
            placed.add((row,col,))

        def remove_queen( row, col):
            placed.remove((row,col,))

        def backtrack_nqueen(row, count):
            for col in range(n):
                # iterate through columns at the curent row.
                if is_not_under_attack(row, col):
                    # explore this partial candidate solution, and mark the attacking zone
                    place_queen(row, col)
                    if row + 1 == n:
                        # we reach the bottom, i.e. we find a solution!
                        count += 1
                    else:
                        # we move on to the next row
                        count = backtrack_nqueen(row + 1, count)
                    # backtrack, i.e. remove the queen and remove the attacking zone.
                    remove_queen(row, col)
            return count

        return backtrack_nqueen(0, 0)
```
## 70. Climbing Stairs
Tag: Recursion, Math, Dynamic Programming

```python
class Solution:

    # TC: O(n)
    # SC: O(1)
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        d = [0] * 46
        d[1] = 1
        d[2] = 2
        for i in range(3, n+1, 1):
            d[i] = d[i-1] + d[i-2]
        return d[n]
    
    # TC: O(n)
    # SC: O(n)
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2
        d = {}
        d[1] = 1
        d[2] = 2
        return self.climbStairs_d(n,d)

    def climbStairs_d(self, n: int, d) -> int:
        if d.get(n) is not None:
            return d.get(n)
        res = self.climbStairs_d(n-1, d)+self.climbStairs_d(n-2, d)
        d[n]=res
        return res
```
## 77. Combinations
Tag: Recursion, Backtracking
```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        def backtracking(num, lst):
            if len(lst) == k:
                res.append(lst.copy())
                return
            for i in range(num, n+1):
                lst.append(i)
                backtracking(i+1, lst)
                lst.pop()
        backtracking(1, [])
        return res
```
## 95. Unique Binary Search Trees II
Tag: Tree, Recursion
```python
class Solution:
    # å¡ç‰¹å…°æ•°ï¼ˆCatalan Numberï¼‰
    # Cn = (2n)! / (n+1)2n!
    # TC: O(Cn)
    # SC: O(Cn)
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:
        memo = {}
        return self.generateTreess(1, n, memo)

    def generateTreess(self, start, end, memo):
        res = []
        if start > end:
            res.append(None)
            return res
        if (start,end) in memo:
            return memo[(start,end)]
        for i in range(start, end+1, 1):
            left = self.generateTreess(start, i-1, memo)
            right = self.generateTreess(i+1, end, memo)
            for l in left:
                for r in right:
                    root = TreeNode(i)
                    root.left = l
                    root.right = r
                    res.append(root)
        memo[(start,end)]=res
        return res
```
## 100. Same Tree
Tag: Recursion, Tree
```python

class Solution:
    # TC: O(n)
    # SC: O(h) h is height of the tree
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        if p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

    # TC: O(n)
    # SC: O(max) max tree node in a layer
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        def check(p, q):
            if p is None and q is None:
                return True
            if p is None or q is None:
                return False
            if p.val != q.val:
                return False
            return True
        queue = deque()
        queue.append((p,q))
        while len(queue):
            for _ in range(len(queue)):
                pair = queue.popleft()
                if check(pair[0], pair[1]):
                    if pair[0] is not None:
                        queue.append((pair[0].left, pair[1].left))
                        queue.append((pair[0].right, pair[1].right))
                else:
                    return False
        return True

```

## 101. Symmetric Tree
Tag: Binary Tree, Recursion
```python
class Solution:
    # TC: O(n)
    # SC: O(h)
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if root == None:
            return True
        return self.helper(root.left, root.right)
    def helper(self, left, right):
        if left is None and right is None:
            return True
        if left is None or right is None:
            return False
        if left.val == right.val:
            return self.helper(left.left, right.right) and self.helper(left.right, right.left)
        else:
            return False
```

## 104. Maximum Depth of Binary Tree
Tag: Recursion, Tree
```python
class Solution:
    # TC: O(N) N is total node count
    # SC: O(n) n is the max depth
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```
## 240. Search a 2D Matrix II
Tag: Recursion, Matrix, Divide and Conquer
```python
class Solution:
    # TC: O(m + n)
    # SC: O(1)
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix)
        n = len(matrix[0])
        x = 0
        y = n-1
        while x < m and y >= 0:
            var = matrix[x][y]
            if var == target:
                return True
            elif var < target:
                x += 1
            else:
                y -= 1
        return False
    # Divide and conquer
    # TC: O(m*n)
    # SC: O(m+n)
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix) - 1
        n = len(matrix[0]) - 1
        m0 = 0
        n0 = 0
        return self.search(matrix, target, m0, m, n0, n)
    
    def search(self, matrix, target, m0, m, n0, n):
        if m0>m or n0 > n:
            return False
        
        x = m0
        y = n0
        while x <= m and y <= n and matrix[x][y] < target:
            x += 1
            y += 1
        if x <= m and y <= n and matrix[x][y] == target:
            return True
        rightTop = (m0, x - 1, y, n)
        leftBottom = (x, m, n0, y - 1)
        return self.search(matrix, target, *rightTop) or self.search(matrix,target,*leftBottom)

```
## 509. Fibonacci Number
Tag: Recursion, Math, Dynamic Programming
```python

class Solution:
    # TC: O(n)
    # SC: O(1)
    def fib(self, n: int) -> int:
        d = [0] * 31
        d[1] = 1
        i = 2
        while i <= n:
            d[i] = d[i-1] + d[i-2]
            i+=1
        return d[n]

    # TC: O(n)
    # SC: O(n)
    def fib(self, n: int) -> int:
        if n <= 1:
            return n
        d = {}
        d[0] = 0
        d[1] = 1
        return self.fib_d(n, d)

    def fib_d(self, n, d):
        if d.get(n) is not None:
            return d.get(n)
        res = self.fib_d(n-1,d) + self.fib_d(n-2,d)
        d[n] = res
        return res
```

## 779. K-th Symbol in Grammar
Tag: Recursion, Math
```python
class Solution:
    # TC: O(n)
    # SC: O(n)
    def kthGrammar(self, n: int, k: int) -> int:
        if n == 1:
            return 0
        last_level = (k + 1) // 2
        reminder = (k+1) % 2
        last = self.kthGrammar(n-1, last_level)
        if last == 0:
            return 0 if reminder == 0 else 1
        else:
            return 1 if reminder ==0 else 0
```
